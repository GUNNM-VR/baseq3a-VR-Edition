data
export loadedHUDfilePath
align 4
LABELV loadedHUDfilePath
address $87
code
proc HUD_AmmoSoftLimit 4 0
file "..\..\..\..\code\cgame\cg_parsehud.c"
line 34
;1:#include "cg_local.h"
;2:#ifdef USE_NEOHUD
;3:
;4:#include "../ui/menudef.h"			// for the voice chats
;5:
;6:#define HASH_TABLE_SIZE		2048
;7:#define MEM_POOL_SIZE		128 * 1024 // 1024 * 1024 in UI_GAME
;8:#define KEYWORDHASH_SIZE	512
;9:
;10:#define SPEED_SOFT_LIMIT	500
;11:#define HOLDABLE_ITEM_SOFT_LIMIT	60 // fixme: find appropriate limit
;12:
;13:const char * loadedHUDfilePath = "";
;14:
;15:extern cgs_t cgs;
;16:extern cg_t cg;
;17:
;18:vec4_t health_colors[4];
;19:vec4_t armor_colors[4];
;20:vec4_t ammo_colors[4];
;21:vec4_t teams_colors[4];
;22:
;23:static char	memoryPool[MEM_POOL_SIZE];
;24:static int	allocPoint, outOfMemory;
;25:int FPS;
;26:
;27:#if defined MISSIONPACK || defined USE_NEOHUD
;28:extern float CG_Cvar_Get(const char *cvar);
;29:#endif
;30:
;31:// Choose some arbitrary values more realistic
;32:// as weapon soft limit, because AMMO_HARD_LIMIT,
;33:// 200, is too much for most weapons
;34:static int HUD_AmmoSoftLimit(int weapon) {
line 35
;35:	switch (weapon)
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $89
ADDRLP4 0
INDIRI4
CNSTI4 11
GTI4 $89
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $100
ADDP4
INDIRP4
JUMPV
data
align 4
LABELV $100
address $99
address $99
address $91
address $92
address $93
address $94
address $95
address $96
address $97
address $98
address $99
address $99
code
line 36
;36:	{
LABELV $91
line 38
;37:	case WP_MACHINEGUN:
;38:		return 100;
CNSTI4 100
RETI4
ADDRGP4 $88
JUMPV
line 39
;39:		break;
LABELV $92
line 41
;40:	case WP_SHOTGUN:
;41:		return 10;
CNSTI4 10
RETI4
ADDRGP4 $88
JUMPV
line 42
;42:		break;
LABELV $93
line 44
;43:	case WP_GRENADE_LAUNCHER:
;44:		return 10;
CNSTI4 10
RETI4
ADDRGP4 $88
JUMPV
line 45
;45:		break;
LABELV $94
line 47
;46:	case WP_ROCKET_LAUNCHER:
;47:		return 10;
CNSTI4 10
RETI4
ADDRGP4 $88
JUMPV
line 48
;48:		break;
LABELV $95
line 50
;49:	case WP_LIGHTNING:
;50:		return 100;
CNSTI4 100
RETI4
ADDRGP4 $88
JUMPV
line 51
;51:		break;
LABELV $96
line 53
;52:	case WP_RAILGUN:
;53:		return 20;
CNSTI4 20
RETI4
ADDRGP4 $88
JUMPV
line 54
;54:		break;
LABELV $97
line 56
;55:	case WP_PLASMAGUN:
;56:		return 50;
CNSTI4 50
RETI4
ADDRGP4 $88
JUMPV
line 57
;57:		break;
LABELV $98
line 59
;58:	case WP_BFG:
;59:		return 20;
CNSTI4 20
RETI4
ADDRGP4 $88
JUMPV
line 60
;60:		break;
LABELV $99
LABELV $89
line 82
;61:#ifdef MISSIONPACK
;62:		//TODO check values in Mission Pack
;63:	case WP_NAILGUN:
;64:		return 100;
;65:		break;
;66:	case WP_PROX_LAUNCHER:
;67:		return 100;
;68:		break;
;69:	case WP_CHAINGUN:
;70:		return 100;
;71:		break;
;72:#endif
;73:	case WP_NONE:
;74:#ifdef USE_GRAPPLING_HOOK
;75:	case WP_GRAPPLING_HOOK:
;76:#endif
;77:	case WP_GAUNTLET:
;78:#ifdef USE_VR
;79:	case WP_VR_CONTROLLER:
;80:#endif
;81:	default:
;82:		return 0;
CNSTI4 0
RETI4
line 83
;83:		break;
LABELV $88
endproc HUD_AmmoSoftLimit 4 0
proc HUD_SoftLimit 52 4
line 89
;84:	}
;85:}
;86:
;87://get soft limit for Health | Armor | Ammo | Weapon | Score | Time | HoldableItem | FPS | Speed | Fraglimit | Timelimit
;88://in order to draw a gradient texture, or select according color
;89:static int HUD_SoftLimit(int property, int param) {
line 90
;90:	switch (property)
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 1024
EQI4 $111
ADDRLP4 0
INDIRI4
CNSTI4 1024
GTI4 $131
LABELV $130
ADDRLP4 4
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 32
EQI4 $110
ADDRLP4 4
INDIRI4
CNSTI4 32
GTI4 $133
LABELV $132
ADDRLP4 8
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 8
EQI4 $104
ADDRLP4 8
INDIRI4
CNSTI4 8
GTI4 $135
LABELV $134
ADDRFP4 0
INDIRI4
CNSTI4 4
EQI4 $108
ADDRGP4 $102
JUMPV
LABELV $135
ADDRFP4 0
INDIRI4
CNSTI4 16
EQI4 $106
ADDRGP4 $102
JUMPV
LABELV $133
ADDRLP4 12
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 128
EQI4 $125
ADDRLP4 12
INDIRI4
CNSTI4 128
GTI4 $137
LABELV $136
ADDRFP4 0
INDIRI4
CNSTI4 64
EQI4 $124
ADDRGP4 $102
JUMPV
LABELV $137
ADDRLP4 16
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 256
EQI4 $122
ADDRLP4 16
INDIRI4
CNSTI4 256
LTI4 $102
LABELV $138
ADDRFP4 0
INDIRI4
CNSTI4 512
EQI4 $127
ADDRGP4 $102
JUMPV
LABELV $131
ADDRLP4 20
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 16384
EQI4 $122
ADDRLP4 20
INDIRI4
CNSTI4 16384
GTI4 $140
LABELV $139
ADDRLP4 24
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 4096
EQI4 $118
ADDRLP4 24
INDIRI4
CNSTI4 4096
GTI4 $142
LABELV $141
ADDRFP4 0
INDIRI4
CNSTI4 2048
EQI4 $111
ADDRGP4 $102
JUMPV
LABELV $142
ADDRFP4 0
INDIRI4
CNSTI4 8192
EQI4 $120
ADDRGP4 $102
JUMPV
LABELV $140
ADDRLP4 28
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 65536
EQI4 $129
ADDRLP4 28
INDIRI4
CNSTI4 65536
GTI4 $144
LABELV $143
ADDRFP4 0
INDIRI4
CNSTI4 32768
EQI4 $129
ADDRGP4 $102
JUMPV
LABELV $144
ADDRLP4 32
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 131072
EQI4 $129
ADDRLP4 32
INDIRI4
CNSTI4 131072
LTI4 $102
LABELV $145
ADDRFP4 0
INDIRI4
CNSTI4 262144
EQI4 $128
ADDRGP4 $102
JUMPV
line 91
;91:	{
LABELV $104
line 93
;92:	case VAL_HEALTH:
;93:		return cg.snap->ps.stats[STAT_MAX_HEALTH];
ADDRGP4 cg+36
INDIRP4
CNSTI4 252
ADDP4
INDIRI4
RETI4
ADDRGP4 $101
JUMPV
LABELV $106
line 95
;94:	case VAL_ARMOR:
;95:		return cg.snap->ps.stats[STAT_MAX_HEALTH];
ADDRGP4 cg+36
INDIRP4
CNSTI4 252
ADDP4
INDIRI4
RETI4
ADDRGP4 $101
JUMPV
LABELV $108
line 97
;96:	case VAL_AMMO:
;97:	{
line 99
;98:		// AMMO_HARD_LIMIT (200) is too much for most weapons
;99:		centity_t *cent = &cg_entities[cg.snap->ps.clientNum];
ADDRLP4 36
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
CNSTI4 1236
MULI4
ADDRGP4 cg_entities
ADDP4
ASGNP4
line 100
;100:		int weapon = cent->currentState.weapon;
ADDRLP4 40
ADDRLP4 36
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
ASGNI4
line 101
;101:		return HUD_AmmoSoftLimit(weapon);
ADDRLP4 40
INDIRI4
ARGI4
ADDRLP4 44
ADDRGP4 HUD_AmmoSoftLimit
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
RETI4
ADDRGP4 $101
JUMPV
LABELV $110
line 104
;102:	}
;103:	case VAL_WEAPON:
;104:		return HUD_AmmoSoftLimit(param);
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
ADDRGP4 HUD_AmmoSoftLimit
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
RETI4
ADDRGP4 $101
JUMPV
LABELV $111
line 107
;105:	case VAL_SCORE:
;106:	case VAL_CAPFRAG_LIMIT:
;107:		return (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 4
LTI4 $116
ADDRLP4 40
ADDRGP4 cgs+31512
INDIRI4
ASGNI4
ADDRGP4 $117
JUMPV
LABELV $116
ADDRLP4 40
ADDRGP4 cgs+31508
INDIRI4
ASGNI4
LABELV $117
ADDRLP4 40
INDIRI4
RETI4
ADDRGP4 $101
JUMPV
LABELV $118
line 109
;108:	case VAL_FRAG_LIMIT:
;109:		return cgs.fraglimit;
ADDRGP4 cgs+31508
INDIRI4
RETI4
ADDRGP4 $101
JUMPV
LABELV $120
line 111
;110:	case VAL_CAPTURE_LIMIT:
;111:		return cgs.capturelimit;
ADDRGP4 cgs+31512
INDIRI4
RETI4
ADDRGP4 $101
JUMPV
LABELV $122
line 114
;112:	case VAL_TIMER:
;113:	case VAL_TIME_LIMIT:
;114:		return cgs.timelimit;
ADDRGP4 cgs+31516
INDIRI4
RETI4
ADDRGP4 $101
JUMPV
LABELV $124
line 116
;115:	case VAL_HOLDABLE_ITEM:
;116:		return HOLDABLE_ITEM_SOFT_LIMIT;
CNSTI4 60
RETI4
ADDRGP4 $101
JUMPV
LABELV $125
line 118
;117:	case VAL_FPS:
;118:	{
line 119
;119:		int com_maxfps = (int)CG_Cvar_Get( "com_maxfps" );
ADDRGP4 $126
ARGP4
ADDRLP4 48
ADDRGP4 CG_Cvar_Get
CALLF4
ASGNF4
ADDRLP4 44
ADDRLP4 48
INDIRF4
CVFI4 4
ASGNI4
line 120
;120:		return com_maxfps;
ADDRLP4 44
INDIRI4
RETI4
ADDRGP4 $101
JUMPV
LABELV $127
line 125
;121:		// or use magic number as soft value ?
;122:		// return 240;
;123:	}
;124:	case VAL_SPEED:
;125:		return SPEED_SOFT_LIMIT;
CNSTI4 500
RETI4
ADDRGP4 $101
JUMPV
LABELV $128
line 127
;126:	case VAL_PLAYERS_NB_TEAM:
;127:		return TEAM_MAXOVERLAY; //MAX_CLIENTS; //not really TEAM_MAXOVERLAY. What is the maximum player in a team?
CNSTI4 32
RETI4
ADDRGP4 $101
JUMPV
LABELV $129
LABELV $102
line 133
;128:	//those are string, so return 0
;129:	case VAL_FOLLOW_NAME:
;130:	case VAL_SNAPSHOT:
;131:	case VAL_LOCATION:
;132:	default:
;133:		return 0;
CNSTI4 0
RETI4
LABELV $101
endproc HUD_SoftLimit 52 4
proc GetTeamPlayerstat 4 0
line 137
;134:	}
;135:}
;136:
;137:static int GetTeamPlayerstat(item_t *itm, statIndex_t STAT_X) {
line 138
;138:	if (itm->propFlags & PROP_TEAM_PLAYER) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $147
line 139
;139:		if (!itm->team_player) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
NEI4 $149
line 140
;140:			return cg.snap->ps.stats[STAT_X];
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 228
ADDP4
ADDP4
INDIRI4
RETI4
ADDRGP4 $146
JUMPV
LABELV $149
line 142
;141:		}
;142:		if (itm->team_player < 0) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
GEI4 $152
line 143
;143:			if (cg_currentSelectedPlayer.integer == cg.snap->ps.clientNum)
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
NEI4 $154
line 144
;144:				return cg.snap->ps.stats[STAT_X];
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 228
ADDP4
ADDP4
INDIRI4
RETI4
ADDRGP4 $146
JUMPV
LABELV $154
line 145
;145:			else {
line 148
;146:				// for team players
;147:				clientInfo_t	*ci;
;148:				ci = &cgs.clientinfo[cg_currentSelectedPlayer.integer];
ADDRLP4 0
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 1680
MULI4
ADDRGP4 cgs+41012
ADDP4
ASGNP4
line 149
;149:				if (STAT_X == STAT_ARMOR)
ADDRFP4 4
INDIRI4
CNSTI4 3
NEI4 $161
line 150
;150:					return ci->armor;
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
RETI4
ADDRGP4 $146
JUMPV
LABELV $161
line 151
;151:				else if (STAT_X == STAT_HEALTH)
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $153
line 152
;152:					return ci->health;
ADDRLP4 0
INDIRP4
CNSTI4 76
ADDP4
INDIRI4
RETI4
ADDRGP4 $146
JUMPV
line 153
;153:			}
line 154
;154:		}
LABELV $152
line 155
;155:		else if (itm->team_player >= 1) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 1
LTI4 $165
line 158
;156:			// if a team player is explicitely asked
;157:			clientInfo_t	*ci;
;158:			ci = &cgs.clientinfo[itm->team_player];
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 1680
MULI4
ADDRGP4 cgs+41012
ADDP4
ASGNP4
line 159
;159:			if (STAT_X == STAT_ARMOR)
ADDRFP4 4
INDIRI4
CNSTI4 3
NEI4 $168
line 160
;160:				return ci->armor;
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
RETI4
ADDRGP4 $146
JUMPV
LABELV $168
line 161
;161:			else if (STAT_X == STAT_HEALTH)
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $170
line 162
;162:				return ci->health;
ADDRLP4 0
INDIRP4
CNSTI4 76
ADDP4
INDIRI4
RETI4
ADDRGP4 $146
JUMPV
LABELV $170
line 163
;163:		}
LABELV $165
LABELV $153
line 164
;164:	}
LABELV $147
line 165
;165:	return cg.snap->ps.stats[STAT_X];
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 228
ADDP4
ADDP4
INDIRI4
RETI4
LABELV $146
endproc GetTeamPlayerstat 4 0
proc CG_getScore 0 0
line 168
;166:}
;167:
;168:static int CG_getScore(int param) {
line 170
;169:	// Red score
;170:	if (param == 1) {
ADDRFP4 0
INDIRI4
CNSTI4 1
NEI4 $174
line 171
;171:		return cgs.scores1;
ADDRGP4 cgs+34840
INDIRI4
RETI4
ADDRGP4 $173
JUMPV
LABELV $174
line 174
;172:	}
;173:	// Blue score
;174:	else if (param == 2) {
ADDRFP4 0
INDIRI4
CNSTI4 2
NEI4 $177
line 175
;175:		return cgs.scores2;
ADDRGP4 cgs+34844
INDIRI4
RETI4
ADDRGP4 $173
JUMPV
LABELV $177
line 178
;176:	}
;177:	// Enemy score
;178:	else if (param == 3) {
ADDRFP4 0
INDIRI4
CNSTI4 3
NEI4 $180
line 179
;179:		if (cg.snap->ps.persistant[PERS_SCORE] == cgs.scores1)
ADDRGP4 cg+36
INDIRP4
CNSTI4 292
ADDP4
INDIRI4
ADDRGP4 cgs+34840
INDIRI4
NEI4 $182
line 180
;180:			return cgs.scores2;
ADDRGP4 cgs+34844
INDIRI4
RETI4
ADDRGP4 $173
JUMPV
LABELV $182
line 182
;181:		else
;182:			return cgs.scores1;
ADDRGP4 cgs+34840
INDIRI4
RETI4
ADDRGP4 $173
JUMPV
LABELV $180
line 185
;183:	}
;184:	// Player score	
;185:	else {
line 186
;186:		return cg.snap->ps.persistant[PERS_SCORE];
ADDRGP4 cg+36
INDIRP4
CNSTI4 292
ADDP4
INDIRI4
RETI4
LABELV $173
endproc CG_getScore 0 0
proc CG_getPleayersNumber 8 0
line 190
;187:	}
;188:}
;189:
;190:static int CG_getPleayersNumber(int param) {
line 191
;191:	int nbPlyr = cg.numScores;//this is surely not the better way of having opposite team member. 
ADDRLP4 0
ADDRGP4 cg+238236
INDIRI4
ASGNI4
line 193
;192:
;193:	int team = cg.snap->ps.persistant[PERS_TEAM];
ADDRLP4 4
ADDRGP4 cg+36
INDIRP4
CNSTI4 304
ADDP4
INDIRI4
ASGNI4
line 195
;194:	// Red team players number
;195:	if (param == 1) {
ADDRFP4 0
INDIRI4
CNSTI4 1
NEI4 $192
line 196
;196:		if (team == TEAM_RED)
ADDRLP4 4
INDIRI4
CNSTI4 1
NEI4 $194
line 197
;197:			return numSortedTeamPlayers;
ADDRGP4 numSortedTeamPlayers
INDIRI4
RETI4
ADDRGP4 $189
JUMPV
LABELV $194
line 198
;198:		else if (nbPlyr <= 0)
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $196
line 199
;199:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $189
JUMPV
LABELV $196
line 201
;200:		else
;201:			return nbPlyr - numSortedTeamPlayers;
ADDRLP4 0
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
SUBI4
RETI4
ADDRGP4 $189
JUMPV
LABELV $192
line 204
;202:	}
;203:	// Blue team players number
;204:	else if (param == 2) {
ADDRFP4 0
INDIRI4
CNSTI4 2
NEI4 $198
line 205
;205:		if (team == TEAM_BLUE)
ADDRLP4 4
INDIRI4
CNSTI4 2
NEI4 $200
line 206
;206:			return numSortedTeamPlayers;
ADDRGP4 numSortedTeamPlayers
INDIRI4
RETI4
ADDRGP4 $189
JUMPV
LABELV $200
line 207
;207:		else if (nbPlyr <= 0)
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $202
line 208
;208:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $189
JUMPV
LABELV $202
line 210
;209:		else
;210:			return nbPlyr - numSortedTeamPlayers;
ADDRLP4 0
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
SUBI4
RETI4
ADDRGP4 $189
JUMPV
LABELV $198
line 213
;211:	}
;212:	// Opposing team players number
;213:	else if (param == 3) {
ADDRFP4 0
INDIRI4
CNSTI4 3
NEI4 $204
line 214
;214:		if (nbPlyr <= 0)
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $206
line 215
;215:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $189
JUMPV
LABELV $206
line 216
;216:		else if (cgs.gametype < GT_TEAM)
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 3
GEI4 $208
line 217
;217:			return nbPlyr - 1;
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
RETI4
ADDRGP4 $189
JUMPV
LABELV $208
line 219
;218:		else
;219:			return nbPlyr - numSortedTeamPlayers;
ADDRLP4 0
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
SUBI4
RETI4
ADDRGP4 $189
JUMPV
LABELV $204
line 222
;220:	}
;221:	// Own team players number	
;222:	else {
line 223
;223:		if (cgs.gametype < GT_TEAM)
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 3
GEI4 $211
line 224
;224:			return 1;
CNSTI4 1
RETI4
ADDRGP4 $189
JUMPV
LABELV $211
line 226
;225:		else
;226:			return numSortedTeamPlayers;
ADDRGP4 numSortedTeamPlayers
INDIRI4
RETI4
LABELV $189
endproc CG_getPleayersNumber 8 0
proc CG_getTimer 8 0
line 230
;227:	}
;228:}
;229:
;230:static int CG_getTimer( void ) {
line 232
;231:	int msec, seconds;
;232:	msec = cg.time - cgs.levelStartTime;
ADDRLP4 0
ADDRGP4 cg+234764
INDIRI4
ADDRGP4 cgs+34836
INDIRI4
SUBI4
ASGNI4
line 233
;233:	seconds = msec / 1000;
ADDRLP4 4
ADDRLP4 0
INDIRI4
CNSTI4 1000
DIVI4
ASGNI4
line 234
;234:	return seconds;
ADDRLP4 4
INDIRI4
RETI4
LABELV $214
endproc CG_getTimer 8 0
proc CG_getAmmo 4 0
line 237
;235:}
;236:
;237:static int CG_getAmmo( void ) {
line 239
;238:	centity_t *cent;
;239:	cent = &cg_entities[cg.snap->ps.clientNum];
ADDRLP4 0
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
CNSTI4 1236
MULI4
ADDRGP4 cg_entities
ADDP4
ASGNP4
line 240
;240:	if (cent->currentState.weapon) {
ADDRLP4 0
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 0
EQI4 $219
line 241
;241:		return cg.snap->ps.ammo[cent->currentState.weapon];
ADDRLP4 0
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
RETI4
ADDRGP4 $217
JUMPV
LABELV $219
line 243
;242:	}
;243:	return 0;
CNSTI4 0
RETI4
LABELV $217
endproc CG_getAmmo 4 0
proc HUD_PropValue 64 8
line 247
;244:}
;245:
;246://get value for Health | Armor | Ammo | Weapon | Score | Time | HoldableItem | FPS | Speed | Fraglimit | Timelimit
;247:static int HUD_PropValue(item_t *itm, int oneFlag, int param) {
line 248
;248:	switch (oneFlag)
ADDRLP4 0
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 1024
EQI4 $230
ADDRLP4 0
INDIRI4
CNSTI4 1024
GTI4 $253
LABELV $252
ADDRLP4 4
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 32
EQI4 $228
ADDRLP4 4
INDIRI4
CNSTI4 32
GTI4 $255
LABELV $254
ADDRLP4 8
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 8
EQI4 $225
ADDRLP4 8
INDIRI4
CNSTI4 8
GTI4 $257
LABELV $256
ADDRFP4 4
INDIRI4
CNSTI4 4
EQI4 $227
ADDRGP4 $223
JUMPV
LABELV $257
ADDRFP4 4
INDIRI4
CNSTI4 16
EQI4 $226
ADDRGP4 $223
JUMPV
LABELV $255
ADDRLP4 12
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 128
EQI4 $235
ADDRLP4 12
INDIRI4
CNSTI4 128
GTI4 $259
LABELV $258
ADDRFP4 4
INDIRI4
CNSTI4 64
EQI4 $233
ADDRGP4 $223
JUMPV
LABELV $259
ADDRLP4 16
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 256
EQI4 $232
ADDRLP4 16
INDIRI4
CNSTI4 256
LTI4 $223
LABELV $260
ADDRFP4 4
INDIRI4
CNSTI4 512
EQI4 $236
ADDRGP4 $223
JUMPV
LABELV $253
ADDRLP4 20
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 16384
EQI4 $249
ADDRLP4 20
INDIRI4
CNSTI4 16384
GTI4 $262
LABELV $261
ADDRLP4 24
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 4096
EQI4 $245
ADDRLP4 24
INDIRI4
CNSTI4 4096
GTI4 $264
LABELV $263
ADDRFP4 4
INDIRI4
CNSTI4 2048
EQI4 $238
ADDRGP4 $223
JUMPV
LABELV $264
ADDRFP4 4
INDIRI4
CNSTI4 8192
EQI4 $247
ADDRGP4 $223
JUMPV
LABELV $262
ADDRLP4 28
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 65536
EQI4 $251
ADDRLP4 28
INDIRI4
CNSTI4 65536
GTI4 $266
LABELV $265
ADDRFP4 4
INDIRI4
CNSTI4 32768
EQI4 $251
ADDRGP4 $223
JUMPV
LABELV $266
ADDRLP4 32
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 131072
EQI4 $251
ADDRLP4 32
INDIRI4
CNSTI4 131072
LTI4 $223
LABELV $267
ADDRFP4 4
INDIRI4
CNSTI4 262144
EQI4 $231
ADDRGP4 $223
JUMPV
line 249
;249:	{
LABELV $225
line 251
;250:	case VAL_HEALTH:
;251:		return GetTeamPlayerstat(itm, STAT_HEALTH);
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 36
ADDRGP4 GetTeamPlayerstat
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $226
line 253
;252:	case VAL_ARMOR:
;253:		return GetTeamPlayerstat(itm, STAT_ARMOR);
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 3
ARGI4
ADDRLP4 40
ADDRGP4 GetTeamPlayerstat
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $227
line 255
;254:	case VAL_AMMO:
;255:		return CG_getAmmo();
ADDRLP4 44
ADDRGP4 CG_getAmmo
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $228
line 257
;256:	case VAL_WEAPON:
;257:		return cg.snap->ps.ammo[param];
ADDRFP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $230
line 259
;258:	case VAL_SCORE:
;259:		return CG_getScore(param);
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 48
ADDRGP4 CG_getScore
CALLI4
ASGNI4
ADDRLP4 48
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $231
line 261
;260:	case VAL_PLAYERS_NB_TEAM:
;261:		return CG_getPleayersNumber(param);
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 52
ADDRGP4 CG_getPleayersNumber
CALLI4
ASGNI4
ADDRLP4 52
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $232
line 263
;262:	case VAL_TIMER:
;263:		return CG_getTimer();
ADDRLP4 56
ADDRGP4 CG_getTimer
CALLI4
ASGNI4
ADDRLP4 56
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $233
line 265
;264:	case VAL_HOLDABLE_ITEM:
;265:		return cg.snap->ps.stats[STAT_HOLDABLE_ITEM];
ADDRGP4 cg+36
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $235
line 267
;266:	case VAL_FPS:
;267:		return FPS;
ADDRGP4 FPS
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $236
line 269
;268:	case VAL_SPEED:
;269:		return (int)cg.xyspeed;
ADDRGP4 cg+245736
INDIRF4
CVFI4 4
RETI4
ADDRGP4 $222
JUMPV
LABELV $238
line 271
;270:	case VAL_CAPFRAG_LIMIT:
;271:		return (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 4
LTI4 $243
ADDRLP4 60
ADDRGP4 cgs+31512
INDIRI4
ASGNI4
ADDRGP4 $244
JUMPV
LABELV $243
ADDRLP4 60
ADDRGP4 cgs+31508
INDIRI4
ASGNI4
LABELV $244
ADDRLP4 60
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $245
line 273
;272:	case VAL_FRAG_LIMIT:
;273:		return cgs.fraglimit;
ADDRGP4 cgs+31508
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $247
line 275
;274:	case VAL_CAPTURE_LIMIT:
;275:		return cgs.capturelimit;
ADDRGP4 cgs+31512
INDIRI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $249
line 278
;276:	case VAL_TIME_LIMIT:
;277:		//seconds only
;278:		return ((cgs.timelimit) * 60);
ADDRGP4 cgs+31516
INDIRI4
CNSTI4 60
MULI4
RETI4
ADDRGP4 $222
JUMPV
LABELV $251
line 283
;279:	// those are string
;280:	case VAL_LOCATION:
;281:	case VAL_FOLLOW_NAME:
;282:	case VAL_SNAPSHOT:
;283:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $222
JUMPV
LABELV $223
line 285
;284:	default:
;285:		return 0;
CNSTI4 0
RETI4
LABELV $222
endproc HUD_PropValue 64 8
export HUD_ItemCaptionValue
proc HUD_ItemCaptionValue 112 12
line 289
;286:	}
;287:}
;288:
;289:int HUD_ItemCaptionValue(item_t *itm) {
line 291
;290:
;291:	if (itm->propFlags & PROP_TEAM_PLAYER) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $269
line 295
;292:		clientInfo_t *ci;
;293:		int clientNum;
;294:
;295:		if (itm->propFlags & PROP_TEAM_PLAYER) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $271
line 296
;296:			if (!itm->team_player)
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
NEI4 $273
line 297
;297:				clientNum = cg.snap->ps.clientNum;
ADDRLP4 4
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $274
JUMPV
LABELV $273
line 298
;298:			else if (itm->team_player < 0) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
GEI4 $276
line 299
;299:				clientNum = cg_currentSelectedPlayer.integer;
ADDRLP4 4
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ASGNI4
line 300
;300:			}
ADDRGP4 $277
JUMPV
LABELV $276
line 301
;301:			else if (itm->team_player >= 1) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 1
LTI4 $279
line 302
;302:				clientNum = itm->team_player;
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ASGNI4
line 303
;303:			}
LABELV $279
LABELV $277
LABELV $274
line 304
;304:		}
LABELV $271
line 305
;305:		ci = cgs.clientinfo + sortedTeamPlayers[clientNum];
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
CNSTI4 1680
MULI4
ADDRGP4 cgs+41012
ADDP4
ASGNP4
line 307
;306:
;307:		if (ci->infoValid && ci->team == cg.snap->ps.persistant[PERS_TEAM]) {
ADDRLP4 8
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRI4
CNSTI4 0
EQI4 $282
ADDRLP4 8
INDIRP4
CNSTI4 36
ADDP4
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 304
ADDP4
INDIRI4
NEI4 $282
line 308
;308:			if (itm->text.flags & VAL_HEALTH)		return ci->health;
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $285
ADDRLP4 0
INDIRP4
CNSTI4 76
ADDP4
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $285
line 309
;309:			else if (itm->text.flags & VAL_ARMOR)	return ci->armor;
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $287
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $287
line 310
;310:		}
LABELV $282
line 311
;311:	}
LABELV $269
line 313
;312:
;313:	if (itm->text.flags & VAL_HEALTH)				return HUD_PropValue(itm, VAL_HEALTH, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $289
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 8
ARGI4
ADDRLP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $289
line 314
;314:	else if (itm->text.flags & VAL_FPS)				return HUD_PropValue(itm, VAL_FPS, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $291
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 128
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $291
line 315
;315:	else if (itm->text.flags & VAL_ARMOR)			return HUD_PropValue(itm, VAL_ARMOR, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $293
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
ARGP4
CNSTI4 16
ARGI4
ADDRLP4 16
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $293
line 316
;316:	else if (itm->text.flags & VAL_AMMO)			return HUD_PropValue(itm, VAL_AMMO, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $295
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
ARGP4
CNSTI4 4
ARGI4
ADDRLP4 24
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 28
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $295
line 317
;317:	else if (itm->text.flags & VAL_WEAPON)			return HUD_PropValue(itm, VAL_WEAPON, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $297
ADDRLP4 32
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 32
INDIRP4
ARGP4
CNSTI4 32
ARGI4
ADDRLP4 32
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 36
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $297
line 318
;318:	else if (itm->text.flags & VAL_SCORE)			return HUD_PropValue(itm, VAL_SCORE, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CNSTU4 0
EQU4 $299
ADDRLP4 40
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 40
INDIRP4
ARGP4
CNSTI4 1024
ARGI4
ADDRLP4 40
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 44
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $299
line 319
;319:	else if (itm->text.flags & VAL_TIMER)			return HUD_PropValue(itm, VAL_TIMER, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $301
ADDRLP4 48
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 48
INDIRP4
ARGP4
CNSTI4 256
ARGI4
ADDRLP4 48
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 52
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 52
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $301
line 320
;320:	else if (itm->text.flags & VAL_SPEED)			return HUD_PropValue(itm, VAL_SPEED, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $303
ADDRLP4 56
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 56
INDIRP4
ARGP4
CNSTI4 512
ARGI4
ADDRLP4 56
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 60
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 60
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $303
line 321
;321:	else if (itm->text.flags & VAL_CAPFRAG_LIMIT)	return HUD_PropValue(itm, VAL_CAPFRAG_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 2048
BANDU4
CNSTU4 0
EQU4 $305
ADDRLP4 64
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 64
INDIRP4
ARGP4
CNSTI4 2048
ARGI4
ADDRLP4 64
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 68
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 68
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $305
line 322
;322:	else if (itm->text.flags & VAL_FRAG_LIMIT)		return HUD_PropValue(itm, VAL_FRAG_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4096
BANDU4
CNSTU4 0
EQU4 $307
ADDRLP4 72
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 72
INDIRP4
ARGP4
CNSTI4 4096
ARGI4
ADDRLP4 72
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 76
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 76
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $307
line 323
;323:	else if (itm->text.flags & VAL_CAPTURE_LIMIT)	return HUD_PropValue(itm, VAL_CAPTURE_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $309
ADDRLP4 80
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 80
INDIRP4
ARGP4
CNSTI4 8192
ARGI4
ADDRLP4 80
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 84
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 84
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $309
line 324
;324:	else if (itm->text.flags & VAL_TIME_LIMIT)		return HUD_PropValue(itm, VAL_TIME_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $311
ADDRLP4 88
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 88
INDIRP4
ARGP4
CNSTI4 16384
ARGI4
ADDRLP4 88
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 92
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 92
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $311
line 325
;325:	else if (itm->text.flags & VAL_HOLDABLE_ITEM)	return HUD_PropValue(itm, VAL_HOLDABLE_ITEM, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $313
ADDRLP4 96
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 96
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRLP4 96
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 100
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 100
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $313
line 326
;326:	else if (itm->text.flags & VAL_PLAYERS_NB_TEAM)	return HUD_PropValue(itm, VAL_PLAYERS_NB_TEAM, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 262144
BANDU4
CNSTU4 0
EQU4 $315
ADDRLP4 104
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 104
INDIRP4
ARGP4
CNSTI4 262144
ARGI4
ADDRLP4 104
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 108
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 108
INDIRI4
RETI4
ADDRGP4 $268
JUMPV
LABELV $315
line 331
;327:	// Those are string, no need to send them
;328:	//else if (itm->text.flags & VAL_FOLLOW_NAME)	return HUD_PropValue(itm, VAL_FOLLOW_NAME, itm->param);
;329:	//else if (itm->text.flags & VAL_SNAPSHOT)		return HUD_PropValue(itm, VAL_SNAPSHOT, itm->param);
;330:	//else if (itm->text.flags & VAL_LOCATION)		return HUD_PropValue(itm, VAL_LOCATION, itm->param);
;331:	else return 0;
CNSTI4 0
RETI4
LABELV $268
endproc HUD_ItemCaptionValue 112 12
proc HUD_ItemSoftLimit 56 8
line 334
;332:}
;333:
;334:static int HUD_ItemSoftLimit(item_t *itm) {
line 335
;335:	if (itm->text.flags & VAL_HEALTH)				return HUD_SoftLimit(VAL_HEALTH, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $318
CNSTI4 8
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 0
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $318
line 336
;336:	else if (itm->text.flags & VAL_FPS)				return HUD_SoftLimit(VAL_FPS, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $320
CNSTI4 128
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $320
line 337
;337:	else if (itm->text.flags & VAL_ARMOR)			return HUD_SoftLimit(VAL_ARMOR, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $322
CNSTI4 16
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $322
line 338
;338:	else if (itm->text.flags & VAL_AMMO)			return HUD_SoftLimit(VAL_AMMO, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $324
CNSTI4 4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $324
line 339
;339:	else if (itm->text.flags & VAL_WEAPON)			return HUD_SoftLimit(VAL_WEAPON, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $326
CNSTI4 32
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $326
line 340
;340:	else if (itm->text.flags & VAL_SCORE)			return HUD_SoftLimit(VAL_SCORE, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CNSTU4 0
EQU4 $328
CNSTI4 1024
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $328
line 341
;341:	else if (itm->text.flags & VAL_TIMER)			return HUD_SoftLimit(VAL_TIMER, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $330
CNSTI4 256
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 24
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $330
line 342
;342:	else if (itm->text.flags & VAL_SPEED)			return HUD_SoftLimit(VAL_SPEED, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $332
CNSTI4 512
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 28
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $332
line 343
;343:	else if (itm->text.flags & VAL_CAPFRAG_LIMIT)	return HUD_SoftLimit(VAL_CAPFRAG_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 2048
BANDU4
CNSTU4 0
EQU4 $334
CNSTI4 2048
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 32
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $334
line 344
;344:	else if (itm->text.flags & VAL_FRAG_LIMIT)		return HUD_SoftLimit(VAL_FRAG_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4096
BANDU4
CNSTU4 0
EQU4 $336
CNSTI4 4096
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 36
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $336
line 345
;345:	else if (itm->text.flags & VAL_CAPTURE_LIMIT)	return HUD_SoftLimit(VAL_CAPTURE_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $338
CNSTI4 8192
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 40
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $338
line 346
;346:	else if (itm->text.flags & VAL_TIME_LIMIT)		return HUD_SoftLimit(VAL_TIME_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $340
CNSTI4 16384
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 44
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $340
line 347
;347:	else if (itm->text.flags & VAL_HOLDABLE_ITEM)	return HUD_SoftLimit(VAL_HOLDABLE_ITEM, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $342
CNSTI4 64
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 48
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 48
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $342
line 348
;348:	else if (itm->text.flags & VAL_PLAYERS_NB_TEAM)	return HUD_SoftLimit(VAL_PLAYERS_NB_TEAM, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 262144
BANDU4
CNSTU4 0
EQU4 $344
CNSTI4 262144
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 52
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 52
INDIRI4
RETI4
ADDRGP4 $317
JUMPV
LABELV $344
line 352
;349:	//else if (itm->text.flags & VAL_FOLLOW_NAME)	return HUD_SoftLimit(VAL_FOLLOW_NAME, itm->param);
;350:	//else if (itm->text.flags & VAL_SNAPSHOT)		return HUD_SoftLimit(VAL_SNAPSHOT, itm->param);
;351:	//else if (itm->text.flags & VAL_LOCATION)		return HUD_SoftLimit(VAL_LOCATION, itm->param);
;352:	else return 0;
CNSTI4 0
RETI4
LABELV $317
endproc HUD_ItemSoftLimit 56 8
proc cvarTest 0 0
line 355
;353:}
;354:
;355:static qboolean cvarTest(int flag) {
line 356
;356:	if (flag & CV_cg_drawStatus			&& !cg_drawStatus.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $347
ADDRGP4 cg_drawStatus+12
INDIRI4
CNSTI4 0
NEI4 $347
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $347
line 357
;357:	if (flag & CV_cg_drawWeaponSelect	&& !cg_drawWeaponSelect.integer)	return qfalse;//without the ! ?
ADDRFP4 0
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $350
ADDRGP4 cg_drawWeaponSelect+12
INDIRI4
CNSTI4 0
NEI4 $350
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $350
line 358
;358:	if (flag & CV_cg_drawAttacker		&& !cg_drawAttacker.integer)		return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $353
ADDRGP4 cg_drawAttacker+12
INDIRI4
CNSTI4 0
NEI4 $353
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $353
line 359
;359:	if (flag & CV_cg_drawTeamOverlay	&& !cg_drawTeamOverlay.integer)		return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 8
BANDI4
CNSTI4 0
EQI4 $356
ADDRGP4 cg_drawTeamOverlay+12
INDIRI4
CNSTI4 0
NEI4 $356
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $356
line 360
;360:	if (flag & CV_cg_drawCrosshairNames && !cg_drawCrosshairNames.integer)	return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $359
ADDRGP4 cg_drawCrosshairNames+12
INDIRI4
CNSTI4 0
NEI4 $359
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $359
line 361
;361:	if (flag & CV_cg_drawIcons			&& !cg_drawIcons.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 32
BANDI4
CNSTI4 0
EQI4 $362
ADDRGP4 cg_drawIcons+12
INDIRI4
CNSTI4 0
NEI4 $362
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $362
line 362
;362:	if (flag & CV_cg_draw3dIcons		&& !cg_draw3dIcons.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 64
BANDI4
CNSTI4 0
EQI4 $365
ADDRGP4 cg_draw3dIcons+12
INDIRI4
CNSTI4 0
NEI4 $365
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $365
line 363
;363:	if (flag & CV_cg_drawFPS			&& !cg_drawFPS.integer)				return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 128
BANDI4
CNSTI4 0
EQI4 $368
ADDRGP4 cg_drawFPS+12
INDIRI4
CNSTI4 0
NEI4 $368
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $368
line 364
;364:	if (flag & CV_cg_drawSpeed			&& !cg_drawSpeed.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 256
BANDI4
CNSTI4 0
EQI4 $371
ADDRGP4 cg_drawSpeed+12
INDIRI4
CNSTI4 0
NEI4 $371
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $371
line 365
;365:	if (flag & CV_cg_drawTimer			&& !cg_drawTimer.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 512
BANDI4
CNSTI4 0
EQI4 $374
ADDRGP4 cg_drawTimer+12
INDIRI4
CNSTI4 0
NEI4 $374
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $374
line 366
;366:	if (flag & CV_cg_lagometer			&& !cg_lagometer.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 1024
BANDI4
CNSTI4 0
EQI4 $377
ADDRGP4 cg_lagometer+12
INDIRI4
CNSTI4 0
NEI4 $377
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $377
line 367
;367:	if (flag & CV_cg_drawPing			&& !cg_drawPing.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 2048
BANDI4
CNSTI4 0
EQI4 $380
ADDRGP4 cg_drawPing+12
INDIRI4
CNSTI4 0
NEI4 $380
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $380
line 368
;368:	if (flag & CV_cg_drawSnapshot		&& !cg_drawSnapshot.integer)		return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
EQI4 $383
ADDRGP4 cg_drawSnapshot+12
INDIRI4
CNSTI4 0
NEI4 $383
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $383
line 369
;369:	if (flag & CV_cg_drawStatus			&& !cg_drawStatus.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $386
ADDRGP4 cg_drawStatus+12
INDIRI4
CNSTI4 0
NEI4 $386
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $386
line 370
;370:	if (flag & CV_cg_drawRewards		&& !cg_drawRewards.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 8192
BANDI4
CNSTI4 0
EQI4 $389
ADDRGP4 cg_drawRewards+12
INDIRI4
CNSTI4 0
NEI4 $389
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $389
line 371
;371:	if (flag & CV_cg_drawAmmoWarning	&& !cg_drawAmmoWarning.integer)		return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 16384
BANDI4
CNSTI4 0
EQI4 $392
ADDRGP4 cg_drawAmmoWarning+12
INDIRI4
CNSTI4 0
NEI4 $392
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $392
line 372
;372:	if (flag & CV_cg_drawCrosshair		&& !cg_drawCrosshair.integer)		return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 32768
BANDI4
CNSTI4 0
EQI4 $395
ADDRGP4 cg_drawCrosshair+12
INDIRI4
CNSTI4 0
NEI4 $395
CNSTI4 0
RETI4
ADDRGP4 $346
JUMPV
LABELV $395
line 373
;373:	return qtrue;
CNSTI4 1
RETI4
LABELV $346
endproc cvarTest 0 0
export isDisconnect
proc isDisconnect 112 8
line 378
;374:}
;375:
;376:// Allow the drawing of the phone jack
;377:// if we are completely past our buffers
;378:qboolean isDisconnect() {
line 381
;379:	int			cmdNum;
;380:	usercmd_t	cmd;
;381:	cmdNum = trap_GetCurrentCmdNumber() - CMD_BACKUP + 1;
ADDRLP4 104
ADDRGP4 trap_GetCurrentCmdNumber
CALLI4
ASGNI4
ADDRLP4 100
ADDRLP4 104
INDIRI4
CNSTI4 64
SUBI4
CNSTI4 1
ADDI4
ASGNI4
line 382
;382:	trap_GetUserCmd(cmdNum, &cmd);
ADDRLP4 100
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRGP4 trap_GetUserCmd
CALLI4
pop
line 383
;383:	if (cmd.serverTime <= cg.snap->ps.commandTime
ADDRLP4 108
ADDRLP4 0
INDIRI4
ASGNI4
ADDRLP4 108
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 44
ADDP4
INDIRI4
LEI4 $403
ADDRLP4 108
INDIRI4
ADDRGP4 cg+234764
INDIRI4
LEI4 $399
LABELV $403
line 384
;384:		|| cmd.serverTime > cg.time) {	// special check for map_restart // bk 0102165 - FIXME
line 385
;385:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $398
JUMPV
LABELV $399
line 387
;386:	}
;387:	return qfalse;
CNSTI4 0
RETI4
LABELV $398
endproc isDisconnect 112 8
proc check_vis_gen_cases 28 0
line 390
;388:}
;389:
;390:static qboolean check_vis_gen_cases(const unsigned int visArray[2], int arrayIdx) {
line 392
;391:	qboolean isCFT, inMenu;
;392:	int flags = visArray[arrayIdx];
ADDRLP4 0
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
line 394
;393:
;394:	qboolean visible = (arrayIdx == 0);
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $406
ADDRLP4 16
CNSTI4 1
ASGNI4
ADDRGP4 $407
JUMPV
LABELV $406
ADDRLP4 16
CNSTI4 0
ASGNI4
LABELV $407
ADDRLP4 4
ADDRLP4 16
INDIRI4
ASGNI4
line 397
;395:
;396:	// never show item
;397:	if (visible && flags & VIS_NEVER)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $408
ADDRLP4 0
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $408
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $408
line 400
;398:
;399:	//showScores
;400:	if (cg.showScores) {
ADDRGP4 cg+243116
INDIRI4
CNSTI4 0
EQI4 $410
line 401
;401:		if (visible && !(flags & VIS_IN_SCORE))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $413
ADDRLP4 0
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
NEI4 $413
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $413
line 402
;402:		if (!visible && flags & VIS_IN_SCORE)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $415
ADDRLP4 0
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $415
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $415
line 403
;403:	}
LABELV $410
line 406
;404:
;405:	//inMenu
;406:	inMenu = (cg.snap->ps.eFlags & EF_TALK);
ADDRLP4 12
ADDRGP4 cg+36
INDIRP4
CNSTI4 148
ADDP4
INDIRI4
CNSTI4 4096
BANDI4
ASGNI4
line 407
;407:	if (inMenu) {
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $418
line 411
;408:#ifndef USE_NEOHUD // deactivated with USE_NEOHUD : easier to choose a HUD file
;409:		if (visible && !(flags & VIS_IN_MENU))	return qfalse;
;410:#endif
;411:		if (!visible && (flags & VIS_IN_MENU))		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $420
ADDRLP4 0
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $420
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $420
line 412
;412:	}
LABELV $418
line 415
;413:
;414:	//follow
;415:	if (flags & VIS_PMF_FOLLOW) {
ADDRLP4 0
INDIRI4
CNSTI4 8
BANDI4
CNSTI4 0
EQI4 $422
line 416
;416:		if (visible && !(cg.snap->ps.pm_flags & PMF_FOLLOW))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $424
ADDRGP4 cg+36
INDIRP4
CNSTI4 56
ADDP4
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
NEI4 $424
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $424
line 417
;417:		if (!visible && cg.snap->ps.pm_flags & PMF_FOLLOW)		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $427
ADDRGP4 cg+36
INDIRP4
CNSTI4 56
ADDP4
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
EQI4 $427
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $427
line 418
;418:	}
LABELV $422
line 421
;419:
;420:	//low ammo
;421:	if (flags & VIS_LOW_AMMO_WARNING) {
ADDRLP4 0
INDIRI4
CNSTI4 32
BANDI4
CNSTI4 0
EQI4 $430
line 422
;422:		if (visible && !(cg.lowAmmoWarning == 1))						return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $432
ADDRGP4 cg+245304
INDIRI4
CNSTI4 1
EQI4 $432
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $432
line 423
;423:		if (!visible && cg.lowAmmoWarning && cg.lowAmmoWarning != 2)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $435
ADDRGP4 cg+245304
INDIRI4
CNSTI4 0
EQI4 $435
ADDRGP4 cg+245304
INDIRI4
CNSTI4 2
EQI4 $435
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $435
line 424
;424:	}
LABELV $430
line 427
;425:
;426:	// out of ammo
;427:	if (flags & VIS_OUT_OF_AMMO) {
ADDRLP4 0
INDIRI4
CNSTI4 64
BANDI4
CNSTI4 0
EQI4 $439
line 428
;428:		if (visible && !(cg.lowAmmoWarning == 2))						return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $441
ADDRGP4 cg+245304
INDIRI4
CNSTI4 2
EQI4 $441
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $441
line 429
;429:		if (!visible && cg.lowAmmoWarning && cg.lowAmmoWarning == 2)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $444
ADDRGP4 cg+245304
INDIRI4
CNSTI4 0
EQI4 $444
ADDRGP4 cg+245304
INDIRI4
CNSTI4 2
NEI4 $444
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $444
line 430
;430:	}
LABELV $439
line 433
;431:
;432:	//warmup
;433:	if (flags & VIS_WARMUP) {
ADDRLP4 0
INDIRI4
CNSTI4 128
BANDI4
CNSTI4 0
EQI4 $448
line 434
;434:		if (visible && !(cg.warmup))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $450
ADDRGP4 cg+245608
INDIRI4
CNSTI4 0
NEI4 $450
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $450
line 435
;435:		if (!visible && cg.warmup)		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $453
ADDRGP4 cg+245608
INDIRI4
CNSTI4 0
EQI4 $453
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $453
line 436
;436:	}
LABELV $448
line 439
;437:
;438:	// local server
;439:	if (flags & VIS_LOCAL_SERVER) {
ADDRLP4 0
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $456
line 440
;440:		if (visible && !cgs.localServer)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $458
ADDRGP4 cgs+31492
INDIRI4
CNSTI4 0
NEI4 $458
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $458
line 441
;441:		if (!visible && cgs.localServer)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $461
ADDRGP4 cgs+31492
INDIRI4
CNSTI4 0
EQI4 $461
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $461
line 442
;442:	}
LABELV $456
line 445
;443:
;444:	// disconnect
;445:	if (flags & VIS_DISCONNECTED) {
ADDRLP4 0
INDIRI4
CNSTI4 512
BANDI4
CNSTI4 0
EQI4 $464
line 446
;446:		if (visible && isDisconnect())		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $466
ADDRLP4 20
ADDRGP4 isDisconnect
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $466
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $466
line 447
;447:		if (!visible && !isDisconnect())	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $468
ADDRLP4 24
ADDRGP4 isDisconnect
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $468
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $468
line 448
;448:	}
LABELV $464
line 451
;449:
;450:	//blink the 'Connection Interrupted' message & icon
;451:	if (flags & VIS_BLINK) {
ADDRLP4 0
INDIRI4
CNSTI4 1024
BANDI4
CNSTI4 0
EQI4 $470
line 452
;452:		if (visible && (cg.time >> 9) & 1)		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $472
ADDRGP4 cg+234764
INDIRI4
CNSTI4 9
RSHI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $472
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $472
line 453
;453:		if (!visible && !((cg.time >> 9) & 1))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $475
ADDRGP4 cg+234764
INDIRI4
CNSTI4 9
RSHI4
CNSTI4 1
BANDI4
CNSTI4 0
NEI4 $475
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $475
line 454
;454:	}
LABELV $470
line 457
;455:
;456:	//powerup
;457:	if (flags & VIS_POWERUP_1) {
ADDRLP4 0
INDIRI4
CNSTI4 8192
BANDI4
CNSTI4 0
EQI4 $478
line 458
;458:		if (visible && !cg.snap->ps.powerups[1])	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $480
ADDRGP4 cg+36
INDIRP4
CNSTI4 360
ADDP4
INDIRI4
CNSTI4 0
NEI4 $480
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $480
line 459
;459:		if (!visible && cg.snap->ps.powerups[1])	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $483
ADDRGP4 cg+36
INDIRP4
CNSTI4 360
ADDP4
INDIRI4
CNSTI4 0
EQI4 $483
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $483
line 460
;460:	}
LABELV $478
line 463
;461:
;462:	//ItemPickup really worked
;463:	if (flags & VIS_PICKUP_ITEM) {
ADDRLP4 0
INDIRI4
CNSTI4 16384
BANDI4
CNSTI4 0
EQI4 $486
line 464
;464:		if (visible && !cg.itemPickup)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $488
ADDRGP4 cg+245620
INDIRI4
CNSTI4 0
NEI4 $488
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $488
line 465
;465:		if (!visible && cg.itemPickup)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $491
ADDRGP4 cg+245620
INDIRI4
CNSTI4 0
EQI4 $491
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $491
line 466
;466:	}
LABELV $486
line 469
;467:
;468:	//firing
;469:	if (flags & VIS_FIRING) {
ADDRLP4 0
INDIRI4
CNSTI4 32768
BANDI4
CNSTI4 0
EQI4 $494
line 470
;470:		if (visible && !(cg.snap->ps.eFlags & EF_FIRING))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $496
ADDRGP4 cg+36
INDIRP4
CNSTI4 148
ADDP4
INDIRI4
CNSTI4 256
BANDI4
CNSTI4 0
NEI4 $496
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $496
line 471
;471:		if (!visible && cg.snap->ps.eFlags & EF_FIRING)		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $499
ADDRGP4 cg+36
INDIRP4
CNSTI4 148
ADDP4
INDIRI4
CNSTI4 256
BANDI4
CNSTI4 0
EQI4 $499
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $499
line 472
;472:	}
LABELV $494
line 475
;473:
;474:	// VIS_BLUE_FLAG_TAKEN
;475:	isCFT = (cgs.gametype == GT_CTF);
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 4
NEI4 $504
ADDRLP4 20
CNSTI4 1
ASGNI4
ADDRGP4 $505
JUMPV
LABELV $504
ADDRLP4 20
CNSTI4 0
ASGNI4
LABELV $505
ADDRLP4 8
ADDRLP4 20
INDIRI4
ASGNI4
line 480
;476:#ifdef MISSIONPACK
;477:	isCFT = (cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF)
;478:#endif
;479:
;480:	if (isCFT && (flags & VIS_BLUE_FLAG_TAKEN)) {
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $506
ADDRLP4 0
INDIRI4
CNSTI4 2048
BANDI4
CNSTI4 0
EQI4 $506
line 481
;481:		if (visible && !cgs.blueflag)	return qfalse; // blue flag is not at base
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $508
ADDRGP4 cgs+34852
INDIRI4
CNSTI4 0
NEI4 $508
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $508
line 482
;482:		if (!visible && cgs.blueflag)	return qfalse; // blue flag at base
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $511
ADDRGP4 cgs+34852
INDIRI4
CNSTI4 0
EQI4 $511
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $511
line 483
;483:	}
LABELV $506
line 486
;484:
;485:	// VIS_RED_FLAG_TAKEN
;486:	if (isCFT && (flags & VIS_RED_FLAG_TAKEN)) {
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $514
ADDRLP4 0
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
EQI4 $514
line 487
;487:		if (visible && !cgs.redflag)	return qfalse; // red flag is not at base
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $516
ADDRGP4 cgs+34848
INDIRI4
CNSTI4 0
NEI4 $516
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $516
line 488
;488:		if (!visible && cgs.redflag)	return qfalse; // red flag at base
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $519
ADDRGP4 cgs+34848
INDIRI4
CNSTI4 0
EQI4 $519
CNSTI4 0
RETI4
ADDRGP4 $404
JUMPV
LABELV $519
line 489
;489:	}
LABELV $514
line 491
;490:
;491:	return qtrue;
CNSTI4 1
RETI4
LABELV $404
endproc check_vis_gen_cases 28 0
proc check_vis_GT_cases 40 0
line 494
;492:}
;493:
;494:static qboolean check_vis_GT_cases(const unsigned int visArray[2], int arrayIdx) {
line 497
;495:	qboolean solo, isCFT;
;496:	int team;
;497:	int flags = visArray[arrayIdx];
ADDRLP4 0
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
line 499
;498:
;499:	qboolean visible = (arrayIdx == 0);
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $524
ADDRLP4 20
CNSTI4 1
ASGNI4
ADDRGP4 $525
JUMPV
LABELV $524
ADDRLP4 20
CNSTI4 0
ASGNI4
LABELV $525
ADDRLP4 4
ADDRLP4 20
INDIRI4
ASGNI4
line 502
;500:
;501:	// check game type
;502:	solo = (cgs.gametype < GT_TEAM);
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 3
GEI4 $528
ADDRLP4 24
CNSTI4 1
ASGNI4
ADDRGP4 $529
JUMPV
LABELV $528
ADDRLP4 24
CNSTI4 0
ASGNI4
LABELV $529
ADDRLP4 12
ADDRLP4 24
INDIRI4
ASGNI4
line 503
;503:	if (flags & VIS_TEAM_PLAY) {
ADDRLP4 0
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $530
line 504
;504:		if (visible && solo)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $532
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $532
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $532
line 505
;505:		if (!visible && !solo)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $534
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $534
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $534
line 506
;506:	}
LABELV $530
line 509
;507:
;508:	// blue team
;509:	team = cg.snap->ps.persistant[PERS_TEAM];
ADDRLP4 8
ADDRGP4 cg+36
INDIRP4
CNSTI4 304
ADDP4
INDIRI4
ASGNI4
line 510
;510:	if (flags & VIS_TEAM_BLUE) {
ADDRLP4 0
INDIRI4
CNSTI4 512
BANDI4
CNSTI4 0
EQI4 $537
line 511
;511:		if (visible && team != TEAM_BLUE)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $539
ADDRLP4 8
INDIRI4
CNSTI4 2
EQI4 $539
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $539
line 512
;512:		if (!visible && team == TEAM_BLUE)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $541
ADDRLP4 8
INDIRI4
CNSTI4 2
NEI4 $541
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $541
line 513
;513:	}
LABELV $537
line 516
;514:
;515:	// red team
;516:	if (flags & VIS_TEAM_RED) {
ADDRLP4 0
INDIRI4
CNSTI4 1024
BANDI4
CNSTI4 0
EQI4 $543
line 517
;517:		if (visible && team != TEAM_RED)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $545
ADDRLP4 8
INDIRI4
CNSTI4 1
EQI4 $545
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $545
line 518
;518:		if (!visible && team == TEAM_RED)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $547
ADDRLP4 8
INDIRI4
CNSTI4 1
NEI4 $547
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $547
line 519
;519:	}
LABELV $543
line 522
;520:
;521:	//spectator team
;522:	if (flags & VIS_TEAM_SPECTATOR) {
ADDRLP4 0
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
EQI4 $549
line 523
;523:		if (visible && team != TEAM_SPECTATOR)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $551
ADDRLP4 8
INDIRI4
CNSTI4 3
EQI4 $551
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $551
line 524
;524:		if (!visible && team == TEAM_SPECTATOR)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $553
ADDRLP4 8
INDIRI4
CNSTI4 3
NEI4 $553
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $553
line 525
;525:	}
LABELV $549
line 528
;526:
;527:	// in a team (bue or red)
;528:	if (flags & VIS_TEAM_BLUE_OR_RED) {
ADDRLP4 0
INDIRI4
CNSTI4 2048
BANDI4
CNSTI4 0
EQI4 $555
line 529
;529:		if (visible && (team != TEAM_BLUE && team != TEAM_RED))	 return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $557
ADDRLP4 8
INDIRI4
CNSTI4 2
EQI4 $557
ADDRLP4 8
INDIRI4
CNSTI4 1
EQI4 $557
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $557
line 530
;530:		if (!visible && (team == TEAM_BLUE || team == TEAM_RED)) return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $559
ADDRLP4 8
INDIRI4
CNSTI4 2
EQI4 $561
ADDRLP4 8
INDIRI4
CNSTI4 1
NEI4 $559
LABELV $561
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $559
line 531
;531:	}
LABELV $555
line 534
;532:
;533:	//Tournament
;534:	if (flags & VIS_GT_TOURNAMENT) {
ADDRLP4 0
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $562
line 535
;535:		if (visible && cgs.gametype != GT_TOURNAMENT)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $564
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 1
EQI4 $564
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $564
line 536
;536:		if (!visible && cgs.gametype == GT_TOURNAMENT)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $567
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 1
NEI4 $567
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $567
line 537
;537:	}
LABELV $562
line 540
;538:
;539:	//free for all
;540:	if (flags & VIS_GT_FFA) {
ADDRLP4 0
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $570
line 541
;541:		if (visible && cgs.gametype != GT_FFA)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $572
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 0
EQI4 $572
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $572
line 542
;542:		if (!visible && cgs.gametype == GT_FFA)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $575
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 0
NEI4 $575
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $575
line 543
;543:	}
LABELV $570
line 546
;544:
;545:	//team deathmatch
;546:	if (flags & VIS_GT_TDM) {
ADDRLP4 0
INDIRI4
CNSTI4 8
BANDI4
CNSTI4 0
EQI4 $578
line 547
;547:		if (visible && cgs.gametype != GT_TEAM)		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $580
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 3
EQI4 $580
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $580
line 548
;548:		if (!visible && cgs.gametype == GT_TEAM)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $583
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 3
NEI4 $583
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $583
line 549
;549:	}
LABELV $578
line 552
;550:
;551:	//capture the flag
;552:	isCFT = (cgs.gametype == GT_CTF);
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 4
NEI4 $588
ADDRLP4 28
CNSTI4 1
ASGNI4
ADDRGP4 $589
JUMPV
LABELV $588
ADDRLP4 28
CNSTI4 0
ASGNI4
LABELV $589
ADDRLP4 16
ADDRLP4 28
INDIRI4
ASGNI4
line 557
;553:#ifdef MISSIONPACK
;554:	isCFT = (cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF)
;555:#endif
;556:
;557:	if (flags & VIS_GT_CTF) {
ADDRLP4 0
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $590
line 558
;558:		if (visible && !isCFT)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $592
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $592
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $592
line 559
;559:		if (!visible && isCFT)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $594
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $594
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $594
line 560
;560:	}
LABELV $590
line 583
;561:
;562:	//Obelisk
;563:#ifdef MISSIONPACK
;564:	if (flags & VIS_GT_OBELISK) {
;565:		if (visible && cgs.gametype != GT_OBELISK)	return qfalse;
;566:		if (!visible && cgs.gametype == GT_OBELISK)	return qfalse;
;567:	}
;568:
;569:	//Harvester
;570:	if (flags & VIS_GT_HARVESTER) {
;571:		if (visible && cgs.gametype != GT_HARVESTER)	return qfalse;
;572:		if (!visible && cgs.gametype == GT_HARVESTER)	return qfalse;
;573:	}
;574:#endif
;575:
;576://GUNNM TODO
;577:/*
;578:	if (flags & VIS_GT_FREEZE) {
;579:		if (visible && cgs.gametype != GT_FREEZE)	return qfalse;
;580:		if (!visible && cgs.gametype == GT_FREEZE)	return qfalse;
;581:	}
;582:*/
;583:	if (flags & VIS_SHOW_TEAMINFO) {
ADDRLP4 0
INDIRI4
CNSTI4 8192
BANDI4
CNSTI4 0
EQI4 $596
line 584
;584:		qboolean teamInfo = (cg_currentSelectedPlayer.integer == numSortedTeamPlayers);
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
NEI4 $600
ADDRLP4 36
CNSTI4 1
ASGNI4
ADDRGP4 $601
JUMPV
LABELV $600
ADDRLP4 36
CNSTI4 0
ASGNI4
LABELV $601
ADDRLP4 32
ADDRLP4 36
INDIRI4
ASGNI4
line 585
;585:		if (visible && !teamInfo)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $602
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $602
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $602
line 586
;586:		if (!visible && teamInfo)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $604
ADDRLP4 32
INDIRI4
CNSTI4 0
EQI4 $604
CNSTI4 0
RETI4
ADDRGP4 $522
JUMPV
LABELV $604
line 587
;587:	}
LABELV $596
line 595
;588:
;589:#ifdef MISSIONPACK
;590:	if (flags & CG_SHOW_IF_PLAYER_HAS_FLAG) {
;591:		if (visible && !(cg.snap->ps.powerups[PW_REDFLAG] || cg.snap->ps.powerups[PW_BLUEFLAG] || cg.snap->ps.powerups[PW_NEUTRALFLAG]))	return qfalse;
;592:		if (!visible && (cg.snap->ps.powerups[PW_REDFLAG] || cg.snap->ps.powerups[PW_BLUEFLAG] || cg.snap->ps.powerups[PW_NEUTRALFLAG]))	return false;
;593:	}
;594:#endif
;595:	return qtrue;
CNSTI4 1
RETI4
LABELV $522
endproc check_vis_GT_cases 40 0
proc check_vis_val_cases 24 0
ADDRFP4 8
ADDRFP4 8
INDIRI4
ASGNI4
line 598
;596:}
;597:
;598:static qboolean check_vis_val_cases(const unsigned int visArray[2], int arrayIdx, const int param) {
line 599
;599:	int flags = visArray[arrayIdx];
ADDRLP4 0
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
line 601
;600:
;601:	qboolean visible = (arrayIdx == 0);
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $608
ADDRLP4 8
CNSTI4 1
ASGNI4
ADDRGP4 $609
JUMPV
LABELV $608
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $609
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 604
;602:
;603:	//health
;604:	if (flags & VAL_HEALTH) {
ADDRLP4 0
INDIRI4
CNSTI4 8
BANDI4
CNSTI4 0
EQI4 $610
line 605
;605:		if (visible  && !(cg.snap->ps.stats[STAT_HEALTH]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $612
ADDRGP4 cg+36
INDIRP4
CNSTI4 228
ADDP4
INDIRI4
CNSTI4 0
NEI4 $612
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $612
line 606
;606:		if (!visible && (cg.snap->ps.stats[STAT_HEALTH]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $615
ADDRGP4 cg+36
INDIRP4
CNSTI4 228
ADDP4
INDIRI4
CNSTI4 0
EQI4 $615
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $615
line 607
;607:	}
LABELV $610
line 610
;608:
;609:	//armor
;610:	if (flags & VAL_ARMOR) {
ADDRLP4 0
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $618
line 611
;611:		if (visible && !(cg.snap->ps.stats[STAT_ARMOR]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $620
ADDRGP4 cg+36
INDIRP4
CNSTI4 240
ADDP4
INDIRI4
CNSTI4 0
NEI4 $620
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $620
line 612
;612:		if (!visible && (cg.snap->ps.stats[STAT_ARMOR]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $623
ADDRGP4 cg+36
INDIRP4
CNSTI4 240
ADDP4
INDIRI4
CNSTI4 0
EQI4 $623
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $623
line 613
;613:	}
LABELV $618
line 616
;614:
;615:	//holdable item
;616:	if (flags & VAL_HOLDABLE_ITEM) {
ADDRLP4 0
INDIRI4
CNSTI4 64
BANDI4
CNSTI4 0
EQI4 $626
line 617
;617:		if (visible && !(cg.snap->ps.stats[STAT_HOLDABLE_ITEM]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $628
ADDRGP4 cg+36
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
CNSTI4 0
NEI4 $628
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $628
line 618
;618:		if (!visible && !(cg.snap->ps.stats[STAT_HOLDABLE_ITEM]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $631
ADDRGP4 cg+36
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
CNSTI4 0
NEI4 $631
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $631
line 619
;619:	}
LABELV $626
line 622
;620:
;621:	//weapon
;622:	if (flags & VAL_WEAPON) { // param: WeaponNb
ADDRLP4 0
INDIRI4
CNSTI4 32
BANDI4
CNSTI4 0
EQI4 $634
line 623
;623:		if (visible && !(cg.snap->ps.ammo[param]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $636
ADDRFP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
CNSTI4 0
NEI4 $636
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $636
line 624
;624:		if (!visible && (cg.snap->ps.ammo[param]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $639
ADDRFP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
CNSTI4 0
EQI4 $639
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $639
line 625
;625:	}
LABELV $634
line 628
;626:
;627:	//speed
;628:	if (flags & VAL_SPEED) {
ADDRLP4 0
INDIRI4
CNSTI4 512
BANDI4
CNSTI4 0
EQI4 $642
line 629
;629:		if (visible && !((int)cg.xyspeed))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $644
ADDRGP4 cg+245736
INDIRF4
CVFI4 4
CNSTI4 0
NEI4 $644
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $644
line 630
;630:		if (!visible && ((int)cg.xyspeed))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $647
ADDRGP4 cg+245736
INDIRF4
CVFI4 4
CNSTI4 0
EQI4 $647
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $647
line 631
;631:	}
LABELV $642
line 634
;632:
;633:	//time limit
;634:	if (flags & VAL_TIME_LIMIT) {
ADDRLP4 0
INDIRI4
CNSTI4 16384
BANDI4
CNSTI4 0
EQI4 $650
line 635
;635:		if (visible && !(cgs.timelimit > 0))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $652
ADDRGP4 cgs+31516
INDIRI4
CNSTI4 0
GTI4 $652
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $652
line 636
;636:		if (!visible && (cgs.timelimit > 0))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $655
ADDRGP4 cgs+31516
INDIRI4
CNSTI4 0
LEI4 $655
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $655
line 637
;637:	}
LABELV $650
line 640
;638:
;639:	//frag limit
;640:	if (flags & VAL_FRAG_LIMIT) {
ADDRLP4 0
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
EQI4 $658
line 641
;641:		if (visible && !(cgs.fraglimit))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $660
ADDRGP4 cgs+31508
INDIRI4
CNSTI4 0
NEI4 $660
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $660
line 642
;642:		if (!visible && (cgs.fraglimit))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $663
ADDRGP4 cgs+31508
INDIRI4
CNSTI4 0
EQI4 $663
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $663
line 643
;643:	}
LABELV $658
line 646
;644:
;645:	//capture limit
;646:	if (flags & VAL_CAPTURE_LIMIT) {
ADDRLP4 0
INDIRI4
CNSTI4 8192
BANDI4
CNSTI4 0
EQI4 $666
line 647
;647:		if (visible && !(cgs.capturelimit))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $668
ADDRGP4 cgs+31512
INDIRI4
CNSTI4 0
NEI4 $668
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $668
line 648
;648:		if (!visible && (cgs.capturelimit))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $671
ADDRGP4 cgs+31512
INDIRI4
CNSTI4 0
EQI4 $671
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $671
line 649
;649:	}
LABELV $666
line 652
;650:
;651:	//capture limit / frag limit depending of game type
;652:	if (flags & VAL_CAPFRAG_LIMIT) {
ADDRLP4 0
INDIRI4
CNSTI4 2048
BANDI4
CNSTI4 0
EQI4 $674
line 653
;653:		int slimit = (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 4
LTI4 $680
ADDRLP4 16
ADDRGP4 cgs+31512
INDIRI4
ASGNI4
ADDRGP4 $681
JUMPV
LABELV $680
ADDRLP4 16
ADDRGP4 cgs+31508
INDIRI4
ASGNI4
LABELV $681
ADDRLP4 12
ADDRLP4 16
INDIRI4
ASGNI4
line 654
;654:		if (visible && !slimit)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $682
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $682
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $682
line 655
;655:		if (!visible && slimit)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $684
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $684
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $684
line 656
;656:	}
LABELV $674
line 659
;657:
;658:	// selected Weapon ammo
;659:	if (flags & VAL_AMMO) {
ADDRLP4 0
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $686
line 660
;660:		centity_t *cent = &cg_entities[cg.snap->ps.clientNum];
ADDRLP4 12
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
CNSTI4 1236
MULI4
ADDRGP4 cg_entities
ADDP4
ASGNP4
line 661
;661:		if (visible && (!cent->currentState.weapon || !cg.snap->ps.ammo[cent->currentState.weapon]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $689
ADDRLP4 12
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 0
EQI4 $692
ADDRLP4 12
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
CNSTI4 0
NEI4 $689
LABELV $692
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $689
line 662
;662:		if (!visible && cent->currentState.weapon && cg.snap->ps.ammo[cent->currentState.weapon])		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $693
ADDRLP4 12
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 0
EQI4 $693
ADDRLP4 12
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
CNSTI4 0
EQI4 $693
CNSTI4 0
RETI4
ADDRGP4 $606
JUMPV
LABELV $693
line 663
;663:	}
LABELV $686
line 674
;664:
;665:	// those visibility flags would make no sense
;666:	/*if (flags & VAL_SCORE ||
;667:		flags & VAL_TIMER ||
;668:		flags & VAL_FPS ||
;669:		flags & VAL_SNAPSHOT ||
;670:		flags & VAL_FOLLOW_NAME ||
;671:		flags & VAL_LOCATION) {
;672:		return qtrue;
;673:	}*/
;674:	return qtrue;
CNSTI4 1
RETI4
LABELV $606
endproc check_vis_val_cases 24 0
proc check_vis_teamPlayer_cases 24 0
ADDRFP4 8
ADDRFP4 8
INDIRI4
ASGNI4
line 677
;675:}
;676:
;677:static qboolean check_vis_teamPlayer_cases(const unsigned int visArray[2], int arrayIdx, const int param) {
line 678
;678:	int flags = visArray[arrayIdx];
ADDRLP4 0
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
line 680
;679:
;680:	qboolean visible = (arrayIdx == 0);
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $698
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRGP4 $699
JUMPV
LABELV $698
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $699
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 688
;681:	int clientNum;
;682:
;683:	//visibility flags of team player related item
;684:	//if (visible && !(flags & VIS_TEAM_PLAYER)/* && (flags & VIS_TEAM_PLAYER)*/)	return qtrue;
;685:	//if (!visible && (flags & VIS_TEAM_PLAYER))	return qtrue;//not usefull
;686:	//if (visible && (flags & VIS_TEAM_PLAYER) && (cgs.gametype < GT_TEAM)) return qfalse;
;687:
;688:	if (visible && (flags & VIS_TEAM_PLAYER)) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $700
ADDRLP4 0
INDIRI4
CNSTI4 16384
BANDI4
CNSTI4 0
EQI4 $700
line 689
;689:		if (cgs.gametype < GT_TEAM) return qfalse;
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 3
GEI4 $702
CNSTI4 0
RETI4
ADDRGP4 $696
JUMPV
LABELV $702
line 691
;690:
;691:		if (!param)
ADDRFP4 8
INDIRI4
CNSTI4 0
NEI4 $705
line 692
;692:			clientNum = cg.snap->ps.clientNum;
ADDRLP4 8
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $706
JUMPV
LABELV $705
line 693
;693:		else if (param < 0)
ADDRFP4 8
INDIRI4
CNSTI4 0
GEI4 $708
line 694
;694:			clientNum = cg_currentSelectedPlayer.integer;
ADDRLP4 8
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ASGNI4
ADDRGP4 $709
JUMPV
LABELV $708
line 695
;695:		else if (param >= 1)
ADDRFP4 8
INDIRI4
CNSTI4 1
LTI4 $711
line 696
;696:			clientNum = param;
ADDRLP4 8
ADDRFP4 8
INDIRI4
ASGNI4
LABELV $711
LABELV $709
LABELV $706
line 698
;697:
;698:		if (sortedTeamPlayers[clientNum] == cg.snap->ps.clientNum)
ADDRLP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
NEI4 $713
line 699
;699:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $696
JUMPV
LABELV $713
line 700
;700:		else {
line 702
;701:			clientInfo_t *ci;
;702:			ci = cgs.clientinfo + sortedTeamPlayers[clientNum];
ADDRLP4 16
ADDRLP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
CNSTI4 1680
MULI4
ADDRGP4 cgs+41012
ADDP4
ASGNP4
line 703
;703:			if (!ci || !ci->infoValid)
ADDRLP4 20
ADDRLP4 16
INDIRP4
ASGNP4
ADDRLP4 20
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $719
ADDRLP4 20
INDIRP4
INDIRI4
CNSTI4 0
NEI4 $717
LABELV $719
line 704
;704:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $696
JUMPV
LABELV $717
line 705
;705:		}
line 706
;706:	}
LABELV $700
line 707
;707:	return qtrue;
CNSTI4 1
RETI4
LABELV $696
endproc check_vis_teamPlayer_cases 24 0
export CG_HUDItemVisible
proc CG_HUDItemVisible 44 12
line 711
;708:}
;709:
;710:// items in the HUD file are visible, unless specified
;711:qboolean CG_HUDItemVisible(const item_t * itm) {
line 712
;712:	if (itm->visible_prop_flags[0] & VIS_NEVER) {
ADDRFP4 0
INDIRP4
CNSTI4 1060
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $721
line 713
;713:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $720
JUMPV
LABELV $721
line 715
;714:	}
;715:	else {
line 719
;716:		// 0: visible cases / 1: hidden cases
;717:
;718:		// general visibility flags
;719:		if (!check_vis_gen_cases(itm->visible_prop_flags, 0))	return qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 1060
ADDP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 0
ADDRGP4 check_vis_gen_cases
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $723
CNSTI4 0
RETI4
ADDRGP4 $720
JUMPV
LABELV $723
line 720
;720:		if (!check_vis_gen_cases(itm->visible_prop_flags, 1))	return qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 1060
ADDP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 4
ADDRGP4 check_vis_gen_cases
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $725
CNSTI4 0
RETI4
ADDRGP4 $720
JUMPV
LABELV $725
line 723
;721:
;722:		// team play visibility flags
;723:		if (!check_vis_GT_cases(itm->visible_GT_flags, 0))	return qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 1076
ADDP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 8
ADDRGP4 check_vis_GT_cases
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $727
CNSTI4 0
RETI4
ADDRGP4 $720
JUMPV
LABELV $727
line 724
;724:		if (!check_vis_GT_cases(itm->visible_GT_flags, 1))	return qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 1076
ADDP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 12
ADDRGP4 check_vis_GT_cases
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $729
CNSTI4 0
RETI4
ADDRGP4 $720
JUMPV
LABELV $729
line 727
;725:
;726:		// value visibility flags
;727:		if (!check_vis_val_cases(itm->visible_val_flags, 0, itm->param))	return qfalse;
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CNSTI4 1068
ADDP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 16
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 check_vis_val_cases
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $731
CNSTI4 0
RETI4
ADDRGP4 $720
JUMPV
LABELV $731
line 728
;728:		if (!check_vis_val_cases(itm->visible_val_flags, 1, itm->param))	return qfalse;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
CNSTI4 1068
ADDP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 24
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 28
ADDRGP4 check_vis_val_cases
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $733
CNSTI4 0
RETI4
ADDRGP4 $720
JUMPV
LABELV $733
line 731
;729:
;730:		// team player item visibility
;731:		if (!check_vis_teamPlayer_cases(itm->visible_GT_flags, 0, itm->team_player))	return qfalse;
ADDRLP4 32
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 32
INDIRP4
CNSTI4 1076
ADDP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 32
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ARGI4
ADDRLP4 36
ADDRGP4 check_vis_teamPlayer_cases
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
NEI4 $735
CNSTI4 0
RETI4
ADDRGP4 $720
JUMPV
LABELV $735
line 734
;732:		//if (!check_vis_teamPlayer_cases(itm->visible_GT_flags, 1, itm->team_player))	return qfalse;
;733:
;734:		if (!cvarTest(itm->cvarTest_flags))
ADDRFP4 0
INDIRP4
CNSTI4 1084
ADDP4
INDIRU4
CVUI4 4
ARGI4
ADDRLP4 40
ADDRGP4 cvarTest
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 0
NEI4 $737
line 735
;735:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $720
JUMPV
LABELV $737
line 736
;736:	}
line 737
;737:	return qtrue;
CNSTI4 1
RETI4
LABELV $720
endproc CG_HUDItemVisible 44 12
export createScoreRatio
proc createScoreRatio 4 0
line 741
;738:}
;739:
;740:// TODO create a ratio score1 / score2 depending of itm->param
;741:float createScoreRatio(int param) {
line 743
;742:	// player's score, or player team
;743:	if (param == 1) {
ADDRFP4 0
INDIRI4
CNSTI4 1
NEI4 $740
line 744
;744:		return (cgs.scores1 > cgs.scores2) ? 1.0f : 0.0f;
ADDRGP4 cgs+34840
INDIRI4
ADDRGP4 cgs+34844
INDIRI4
LEI4 $745
ADDRLP4 0
CNSTF4 1065353216
ASGNF4
ADDRGP4 $746
JUMPV
LABELV $745
ADDRLP4 0
CNSTF4 0
ASGNF4
LABELV $746
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $739
JUMPV
LABELV $740
line 747
;745:	}
;746:	// other's score
;747:	else if (param == 2) {
ADDRFP4 0
INDIRI4
CNSTI4 2
NEI4 $747
line 748
;748:		return (cgs.scores2 > cgs.scores1) ? 1.0f : 0.0f;
ADDRGP4 cgs+34844
INDIRI4
ADDRGP4 cgs+34840
INDIRI4
LEI4 $752
ADDRLP4 0
CNSTF4 1065353216
ASGNF4
ADDRGP4 $753
JUMPV
LABELV $752
ADDRLP4 0
CNSTF4 0
ASGNF4
LABELV $753
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $739
JUMPV
LABELV $747
line 750
;749:	}
;750:	return 1.0f;
CNSTF4 1065353216
RETF4
LABELV $739
endproc createScoreRatio 4 0
export HUD_GradientValue
proc HUD_GradientValue 32 12
line 754
;751:}
;752:
;753://get gradient value for Health | Armor | Ammo | Weapon | Score | Time | HoldableItem | FPS | Speed | Fraglimit | Timelimit
;754:float HUD_GradientValue(item_t *itm) {
line 755
;755:	if (itm->gradientFlags & VAL_HEALTH) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $755
line 758
;756:		int				health;
;757:		int				maxHealth;
;758:		health = HUD_PropValue(itm, VAL_HEALTH, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 8
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 759
;759:		maxHealth = HUD_SoftLimit(VAL_HEALTH, itm->param);
CNSTI4 8
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 16
INDIRI4
ASGNI4
line 760
;760:		if (itm->param == 2) {
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
CNSTI4 2
NEI4 $757
line 762
;761:			// show health below the soft limit
;762:			if (health > maxHealth)
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
LEI4 $759
line 763
;763:				return ((float)(health - maxHealth) / (float)maxHealth);
ADDRLP4 20
ADDRLP4 0
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
ADDRLP4 20
INDIRI4
SUBI4
CVIF4 4
ADDRLP4 20
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $759
line 765
;764:			else
;765:				return 0;
CNSTF4 0
RETF4
ADDRGP4 $754
JUMPV
LABELV $757
line 767
;766:		}
;767:		else {
line 769
;768:			// show health above the soft limit
;769:			if (health > maxHealth)
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
LEI4 $761
line 770
;770:				return 1.0f;
CNSTF4 1065353216
RETF4
ADDRGP4 $754
JUMPV
LABELV $761
line 772
;771:			else
;772:				return ((float)health / (float)maxHealth);
ADDRLP4 4
INDIRI4
CVIF4 4
ADDRLP4 0
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $755
line 775
;773:		}
;774:	}
;775:	else if (itm->gradientFlags & VAL_ARMOR) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $763
line 778
;776:		int				armor;
;777:		int				maxHealth;
;778:		armor = HUD_PropValue(itm, VAL_ARMOR, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 16
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 779
;779:		maxHealth = HUD_SoftLimit(VAL_ARMOR, itm->param);
CNSTI4 16
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 16
INDIRI4
ASGNI4
line 781
;780:
;781:		if (itm->param == 2) {
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
CNSTI4 2
NEI4 $765
line 783
;782:			// show health below the soft limit
;783:			if (armor > maxHealth)
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
LEI4 $767
line 784
;784:				return ((float)(armor - maxHealth) / (float)maxHealth);
ADDRLP4 20
ADDRLP4 0
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
ADDRLP4 20
INDIRI4
SUBI4
CVIF4 4
ADDRLP4 20
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $767
line 786
;785:			else
;786:				return 0;
CNSTF4 0
RETF4
ADDRGP4 $754
JUMPV
LABELV $765
line 788
;787:		}
;788:		else {
line 790
;789:			// show health above the soft limit
;790:			if (armor > maxHealth)
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
LEI4 $769
line 791
;791:				return 1.0f;
CNSTF4 1065353216
RETF4
ADDRGP4 $754
JUMPV
LABELV $769
line 793
;792:			else
;793:				return ((float)armor / (float)maxHealth);
ADDRLP4 4
INDIRI4
CVIF4 4
ADDRLP4 0
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $763
line 796
;794:		}
;795:	}
;796:	else if (itm->gradientFlags & VAL_AMMO) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $771
line 799
;797:		int				weapon;
;798:		int				ammoSoftLimit;
;799:		weapon = HUD_PropValue(itm, VAL_AMMO, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 4
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
line 800
;800:		ammoSoftLimit = HUD_AmmoSoftLimit(weapon);
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_AmmoSoftLimit
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 16
INDIRI4
ASGNI4
line 801
;801:		if (ammoSoftLimit > 0) {
ADDRLP4 4
INDIRI4
CNSTI4 0
LEI4 $772
line 802
;802:			return (float)weapon / (float)ammoSoftLimit;
ADDRLP4 0
INDIRI4
CVIF4 4
ADDRLP4 4
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
line 804
;803:		}
;804:	}
LABELV $771
line 805
;805:	else if (itm->gradientFlags & VAL_WEAPON) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $775
line 808
;806:		int				weapon;
;807:		int				ammoSoftLimit;
;808:		weapon = HUD_PropValue(itm, VAL_WEAPON, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 32
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
line 809
;809:		ammoSoftLimit = HUD_AmmoSoftLimit(weapon);
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_AmmoSoftLimit
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 16
INDIRI4
ASGNI4
line 810
;810:		if (ammoSoftLimit>0) {
ADDRLP4 4
INDIRI4
CNSTI4 0
LEI4 $776
line 811
;811:			return (float)weapon / (float)ammoSoftLimit;
ADDRLP4 0
INDIRI4
CVIF4 4
ADDRLP4 4
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
line 813
;812:		}
;813:	}
LABELV $775
line 814
;814:	else if (itm->gradientFlags & VAL_SCORE || itm->gradientFlags & VAL_CAPFRAG_LIMIT) {
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CNSTU4 0
NEU4 $781
ADDRLP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 2048
BANDU4
CNSTU4 0
EQU4 $779
LABELV $781
line 815
;815:		int slimit = (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 4
LTI4 $786
ADDRLP4 8
ADDRGP4 cgs+31512
INDIRI4
ASGNI4
ADDRGP4 $787
JUMPV
LABELV $786
ADDRLP4 8
ADDRGP4 cgs+31508
INDIRI4
ASGNI4
LABELV $787
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 816
;816:		if (slimit > 0) {
ADDRLP4 4
INDIRI4
CNSTI4 0
LEI4 $788
line 817
;817:			int itmVal = HUD_PropValue(itm, VAL_SCORE, itm->param);
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
ARGP4
CNSTI4 1024
ARGI4
ADDRLP4 16
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 20
INDIRI4
ASGNI4
line 818
;818:			return (float)itmVal / (float)slimit;
ADDRLP4 12
INDIRI4
CVIF4 4
ADDRLP4 4
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $788
line 820
;819:		}
;820:		else {
line 821
;821:			return createScoreRatio(itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 createScoreRatio
CALLF4
ASGNF4
ADDRLP4 12
INDIRF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $779
line 825
;822:		}
;823:	}
;824:
;825:	else if (itm->gradientFlags & VAL_FRAG_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 4096
BANDU4
CNSTU4 0
EQU4 $790
line 826
;826:		if (cgs.fraglimit > 0) {
ADDRGP4 cgs+31508
INDIRI4
CNSTI4 0
LEI4 $792
line 827
;827:			return (float)cg.snap->ps.persistant[PERS_SCORE] / (float)cgs.fraglimit;
ADDRGP4 cg+36
INDIRP4
CNSTI4 292
ADDP4
INDIRI4
CVIF4 4
ADDRGP4 cgs+31508
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $792
line 829
;828:		}
;829:		else {
line 830
;830:			return createScoreRatio(itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 createScoreRatio
CALLF4
ASGNF4
ADDRLP4 4
INDIRF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $790
line 833
;831:		}
;832:	}
;833:	else if (itm->gradientFlags & VAL_CAPTURE_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $797
line 834
;834:		if (cgs.fraglimit > 0) {
ADDRGP4 cgs+31508
INDIRI4
CNSTI4 0
LEI4 $799
line 835
;835:			return (float)cg.snap->ps.persistant[PERS_SCORE] / (float)cgs.capturelimit;
ADDRGP4 cg+36
INDIRP4
CNSTI4 292
ADDP4
INDIRI4
CVIF4 4
ADDRGP4 cgs+31512
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $799
line 837
;836:		}
;837:		else {
line 838
;838:			return createScoreRatio(itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 createScoreRatio
CALLF4
ASGNF4
ADDRLP4 4
INDIRF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $797
line 842
;839:		}
;840:	}
;841:
;842:	else if (itm->gradientFlags & VAL_TIMER || itm->gradientFlags & VAL_TIME_LIMIT) {
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
NEU4 $806
ADDRLP4 4
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $804
LABELV $806
line 843
;843:		if (cgs.timelimit > 0) {
ADDRGP4 cgs+31516
INDIRI4
CNSTI4 0
LEI4 $807
line 846
;844:			int time_sec;
;845:			int timelimit_secs;
;846:			time_sec = HUD_PropValue(itm, VAL_TIMER, itm->param);
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
ARGP4
CNSTI4 256
ARGI4
ADDRLP4 16
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 8
ADDRLP4 20
INDIRI4
ASGNI4
line 847
;847:			timelimit_secs = HUD_PropValue(itm, VAL_TIME_LIMIT, itm->param);
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
ARGP4
CNSTI4 16384
ARGI4
ADDRLP4 24
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 28
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 28
INDIRI4
ASGNI4
line 848
;848:			return (float)time_sec / (float)timelimit_secs;
ADDRLP4 8
INDIRI4
CVIF4 4
ADDRLP4 12
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $807
line 850
;849:		}
;850:		else {
line 851
;851:			return 1;
CNSTF4 1065353216
RETF4
ADDRGP4 $754
JUMPV
LABELV $804
line 854
;852:		}
;853:	}
;854:	else if (itm->gradientFlags & VAL_HOLDABLE_ITEM) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $810
line 855
;855:		return (float)HUD_PropValue(itm, VAL_HOLDABLE_ITEM, itm->param) / (float)HOLDABLE_ITEM_SOFT_LIMIT;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CVIF4 4
CNSTF4 1015580809
MULF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $810
line 857
;856:	}
;857:	else if (itm->gradientFlags & VAL_FPS) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $812
line 858
;858:		return (float)FPS / (float)HUD_SoftLimit(VAL_FPS, itm->param);
CNSTI4 128
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRGP4 FPS
INDIRI4
CVIF4 4
ADDRLP4 8
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $812
line 860
;859:	}
;860:	else if (itm->gradientFlags & VAL_SPEED) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $814
line 861
;861:		return cg.xyspeed / (float)SPEED_SOFT_LIMIT;
ADDRGP4 cg+245736
INDIRF4
CNSTF4 990057071
MULF4
RETF4
ADDRGP4 $754
JUMPV
LABELV $814
LABELV $776
LABELV $772
line 863
;862:	}
;863:	return 1.0f;
CNSTF4 1065353216
RETF4
LABELV $754
endproc HUD_GradientValue 32 12
proc HUD_ColorIdx 16 4
line 866
;864:}
;865:
;866:static int HUD_ColorIdx(item_t *itm, int value) {
line 870
;867:	int	col_id;
;868:	int softLimit;
;869:
;870:	if (!(itm->forecolor.colorflags & C_COLOR_RGBA) ) {
ADDRFP4 0
INDIRP4
CNSTI4 1168
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
NEU4 $818
line 872
;871:
;872:		softLimit = HUD_ItemSoftLimit(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 HUD_ItemSoftLimit
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 874
;873:
;874:		if (value > softLimit - 1) {
ADDRFP4 4
INDIRI4
ADDRLP4 4
INDIRI4
CNSTI4 1
SUBI4
LEI4 $820
line 875
;875:			col_id = 3; // white
ADDRLP4 0
CNSTI4 3
ASGNI4
line 876
;876:		}
ADDRGP4 $821
JUMPV
LABELV $820
line 877
;877:		else if (value > (softLimit / 4)) {
ADDRFP4 4
INDIRI4
ADDRLP4 4
INDIRI4
CNSTI4 4
DIVI4
LEI4 $822
line 878
;878:			col_id = 0; // yellow
ADDRLP4 0
CNSTI4 0
ASGNI4
line 879
;879:		}
ADDRGP4 $823
JUMPV
LABELV $822
line 880
;880:		else if (value > 0) {
ADDRFP4 4
INDIRI4
CNSTI4 0
LEI4 $824
line 881
;881:			if (itm->propFlags & PROP_BLINK_WHEN_LOW) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $826
line 882
;882:				col_id = ((cg.time >> 8) & 1) ? 1 : 0; // red / yellow flashing
ADDRGP4 cg+234764
INDIRI4
CNSTI4 8
RSHI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $830
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRGP4 $831
JUMPV
LABELV $830
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $831
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
line 883
;883:			}
ADDRGP4 $825
JUMPV
LABELV $826
line 885
;884:			else
;885:				col_id = 1; // red
ADDRLP4 0
CNSTI4 1
ASGNI4
line 886
;886:		}
ADDRGP4 $825
JUMPV
LABELV $824
line 887
;887:		else {
line 888
;888:			col_id = 1; // red
ADDRLP4 0
CNSTI4 1
ASGNI4
line 889
;889:		}
LABELV $825
LABELV $823
LABELV $821
line 890
;890:	}
LABELV $818
line 891
;891:	return col_id;
ADDRLP4 0
INDIRI4
RETI4
LABELV $817
endproc HUD_ColorIdx 16 4
export copyColor
proc copyColor 0 12
line 894
;892:}
;893:
;894:void copyColor(vec4_t colSource, vec4_t *colDest) {
line 895
;895:	memcpy(colDest, colSource, sizeof(vec4_t));
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 16
ARGI4
ADDRGP4 memcpy
CALLP4
pop
line 896
;896:}
LABELV $832
endproc copyColor 0 12
export HUD_color
proc HUD_color 20 8
line 898
;897:
;898:void HUD_color(item_t *itm, color_Def_t *colDef, vec4_t *colDest, vec4_t defaultCol) {
line 899
;899:	if (colDef->colorflags & C_COLOR_RGBA) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $834
line 900
;900:		copyColor(colDef->color, colDest);
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 901
;901:	}
ADDRGP4 $835
JUMPV
LABELV $834
line 902
;902:	else {
line 903
;903:		if (colDef->colorflags & C_COLORS_HEALTH || colDef->colorflags & C_COLORS_ARMOR ||
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
NEU4 $840
ADDRLP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
NEU4 $840
ADDRLP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
NEU4 $840
ADDRLP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $836
LABELV $840
line 904
;904:			colDef->colorflags & C_COLORS_AMMO || colDef->colorflags & C_COLORS_TEAMS) {
line 905
;905:			int value = HUD_ItemCaptionValue(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 HUD_ItemCaptionValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 906
;906:			int idx = HUD_ColorIdx(itm, value);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_ColorIdx
CALLI4
ASGNI4
ADDRLP4 8
ADDRLP4 16
INDIRI4
ASGNI4
line 907
;907:			if (colDef->colorflags & C_COLORS_HEALTH) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $841
line 908
;908:				copyColor(health_colors[idx], colDest);
ADDRLP4 8
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 health_colors
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 909
;909:			}
ADDRGP4 $837
JUMPV
LABELV $841
line 910
;910:			else if (colDef->colorflags & C_COLORS_ARMOR) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $843
line 911
;911:				copyColor(armor_colors[idx], colDest);
ADDRLP4 8
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 armor_colors
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 912
;912:			}
ADDRGP4 $837
JUMPV
LABELV $843
line 913
;913:			else if (colDef->colorflags & C_COLORS_AMMO) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $845
line 914
;914:				copyColor(ammo_colors[idx], colDest);
ADDRLP4 8
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 ammo_colors
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 915
;915:			}
ADDRGP4 $837
JUMPV
LABELV $845
line 916
;916:			else if (colDef->colorflags & C_COLORS_TEAMS) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $837
line 917
;917:				copyColor(teams_colors[idx], colDest);
ADDRLP4 8
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 teams_colors
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 918
;918:			}
line 919
;919:		}
ADDRGP4 $837
JUMPV
LABELV $836
line 920
;920:		else if (colDef->colorflags & C_COLOR_TEAM) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 2
BANDU4
CNSTU4 0
EQU4 $849
line 921
;921:			copyColor(teams_colors[playerTeam], colDest);
ADDRGP4 playerTeam
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 teams_colors
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 922
;922:		}
ADDRGP4 $850
JUMPV
LABELV $849
line 923
;923:		else if (colDef->colorflags & C_COLOR_BLUE_TEAM) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $851
line 924
;924:			copyColor(teams_colors[HUD_TEAM_BLUE], colDest);
ADDRGP4 teams_colors+32
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 925
;925:		}
ADDRGP4 $852
JUMPV
LABELV $851
line 926
;926:		else if (colDef->colorflags & C_COLOR_RED_TEAM) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $854
line 927
;927:			copyColor(teams_colors[HUD_TEAM_RED], colDest);
ADDRGP4 teams_colors+16
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 928
;928:		}
ADDRGP4 $855
JUMPV
LABELV $854
line 929
;929:		else if (colDef->colorflags & C_COLOR_NME) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $857
line 931
;930:			// use opposite team color
;931:			if (playerTeam == HUD_TEAM_RED) {
ADDRGP4 playerTeam
INDIRI4
CNSTI4 1
NEI4 $859
line 932
;932:				copyColor(teams_colors[HUD_TEAM_BLUE], colDest);
ADDRGP4 teams_colors+32
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 933
;933:			}
ADDRGP4 $858
JUMPV
LABELV $859
line 934
;934:			else {
line 935
;935:				copyColor(teams_colors[HUD_TEAM_RED], colDest);
ADDRGP4 teams_colors+16
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 936
;936:			}
line 937
;937:		}
ADDRGP4 $858
JUMPV
LABELV $857
line 938
;938:		else {
line 939
;939:			copyColor(defaultCol, colDest);
ADDRFP4 12
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 940
;940:		}
LABELV $858
LABELV $855
LABELV $852
LABELV $850
LABELV $837
line 942
;941:
;942:		if (/*colDef->colorflags & C_COLOR_FORCE_ALPHA*/ colDef->alpha)
ADDRFP4 4
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
CNSTF4 0
EQF4 $863
line 943
;943:			(*colDest)[3] = colDef->alpha;
ADDRFP4 8
INDIRP4
CNSTI4 12
ADDP4
ADDRFP4 4
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
ASGNF4
LABELV $863
line 944
;944:	}
LABELV $835
line 945
;945:}
LABELV $833
endproc HUD_color 20 8
export HUD_DrawGradientBackground
proc HUD_DrawGradientBackground 36 40
line 947
;946:
;947:void HUD_DrawGradientBackground(item_t *itm, rectangle_t *r) {
line 954
;948:	qboolean	orientationInv;
;949:	qhandle_t	shader;
;950:	float		value;
;951:	float		size;
;952:
;953:	//invert the gradient direction
;954:	orientationInv = (itm->propFlags & PROP_GRADIENT_INVERT);
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CVUI4 4
ASGNI4
line 957
;955:
;956:	// allow color gradient when background not provided
;957:	shader = CG_HUDShader(itm, cgs.media.whiteShader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 cgs+150560+16
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 CG_HUDShader
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 16
INDIRI4
ASGNI4
line 959
;958:
;959:	value = HUD_GradientValue(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 HUD_GradientValue
CALLF4
ASGNF4
ADDRLP4 4
ADDRLP4 20
INDIRF4
ASGNF4
line 961
;960:
;961:	if (itm->propFlags & PROP_VERTICALBAR) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $868
line 963
;962:
;963:		if (orientationInv) {
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $870
line 965
;964:			// vertical top -> bottom
;965:			size = value;
ADDRLP4 0
ADDRLP4 4
INDIRF4
ASGNF4
line 966
;966:			CG_DrawGradientPic(itm, r->x, r->y, r->w, (r->h*size), 0, 0, 1, size, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ARGF4
CNSTF4 0
ARGF4
CNSTF4 0
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 967
;967:		}
ADDRGP4 $869
JUMPV
LABELV $870
line 968
;968:		else {
line 969
;969:			int invSize = 1 - value;
ADDRLP4 24
CNSTF4 1065353216
ADDRLP4 4
INDIRF4
SUBF4
CVFI4 4
ASGNI4
line 971
;970:			// vertical bottom -> top
;971:			size = 1 - value;
ADDRLP4 0
CNSTF4 1065353216
ADDRLP4 4
INDIRF4
SUBF4
ASGNF4
line 973
;972:
;973:			if (itm->iconFlags & ICON_INVERT_W) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $872
line 974
;974:				r->x += r->w;
ADDRLP4 28
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRF4
ADDRLP4 28
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDF4
ASGNF4
line 975
;975:				r->w = -r->w;
ADDRLP4 32
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 32
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 32
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
NEGF4
ASGNF4
line 976
;976:			}
LABELV $872
line 977
;977:			CG_DrawGradientPic(itm, r->x, r->y + (r->h*size), r->w, r->h - (r->h*size), 0, size, 1, 1, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 28
INDIRP4
INDIRF4
ARGF4
ADDRLP4 28
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 28
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ADDF4
ARGF4
ADDRLP4 28
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 28
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 28
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
SUBF4
ARGF4
CNSTF4 0
ARGF4
ADDRLP4 0
INDIRF4
ARGF4
CNSTF4 1065353216
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 978
;978:		}
line 979
;979:	}
ADDRGP4 $869
JUMPV
LABELV $868
line 980
;980:	else {
line 981
;981:		if (orientationInv) {
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $874
line 983
;982:			// horizontal right -> left
;983:			size = 1 - value;
ADDRLP4 0
CNSTF4 1065353216
ADDRLP4 4
INDIRF4
SUBF4
ASGNF4
line 984
;984:			CG_DrawGradientPic(itm, r->x + (r->w*size), r->y, r->w - (r->w*size), r->h, size, 0, 1, 1, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
INDIRF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ADDF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
SUBF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
ADDRLP4 0
INDIRF4
ARGF4
CNSTF4 0
ARGF4
CNSTF4 1065353216
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 985
;985:		}
ADDRGP4 $875
JUMPV
LABELV $874
line 986
;986:		else {
line 988
;987:			// horizontal left -> right
;988:			size = value;
ADDRLP4 0
ADDRLP4 4
INDIRF4
ASGNF4
line 989
;989:			if (itm->iconFlags & ICON_INVERT_W) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $876
line 990
;990:				r->x += (r->w*size);
ADDRLP4 24
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
ADDRLP4 24
INDIRP4
INDIRF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ADDF4
ASGNF4
line 991
;991:				r->w = -r->w;
ADDRLP4 28
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 28
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 28
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
NEGF4
ASGNF4
line 992
;992:			}
LABELV $876
line 994
;993:
;994:			CG_DrawGradientPic(itm, r->x, r->y, (r->w*size), r->h, 0, 0, size, 1, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
CNSTF4 0
ARGF4
CNSTF4 0
ARGF4
ADDRLP4 0
INDIRF4
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 995
;995:		}
LABELV $875
line 996
;996:	}
LABELV $869
line 997
;997:}
LABELV $865
endproc HUD_DrawGradientBackground 36 40
export CG_CheckOrderPending
proc CG_CheckOrderPending 28 12
line 1000
;998:
;999:// from cg_newdraw.c
;1000:void CG_CheckOrderPending() {
line 1005
;1001:	// order pending was only CTF in Team Arena
;1002:	/*if (cgs.gametype < GT_CTF) {
;1003:		return;
;1004:	}*/
;1005:	if (cgs.gametype < GT_TEAM) {
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 3
GEI4 $879
line 1006
;1006:		return;
ADDRGP4 $878
JUMPV
LABELV $879
line 1009
;1007:	}
;1008:
;1009:	if (cgs.orderPending) {
ADDRGP4 cgs+150504
INDIRI4
CNSTI4 0
EQI4 $882
line 1011
;1010:		const char *p1, *p2, *b;
;1011:		p1 = p2 = b = NULL;
ADDRLP4 12
CNSTP4 0
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 12
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 12
INDIRP4
ASGNP4
line 1012
;1012:		switch (cgs.currentOrder) {
ADDRLP4 16
ADDRGP4 cgs+150500
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 1
LTI4 $885
ADDRLP4 16
INDIRI4
CNSTI4 7
GTI4 $885
ADDRLP4 16
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $913-4
ADDP4
INDIRP4
JUMPV
data
align 4
LABELV $913
address $888
address $892
address $896
address $900
address $907
address $910
address $904
code
LABELV $888
line 1014
;1013:		case TEAMTASK_OFFENSE:
;1014:			p1 = VOICECHAT_ONOFFENSE;
ADDRLP4 8
ADDRGP4 $889
ASGNP4
line 1015
;1015:			p2 = VOICECHAT_OFFENSE;
ADDRLP4 4
ADDRGP4 $890
ASGNP4
line 1016
;1016:			b = "+button7; wait; -button7";
ADDRLP4 0
ADDRGP4 $891
ASGNP4
line 1017
;1017:			break;
ADDRGP4 $886
JUMPV
LABELV $892
line 1019
;1018:		case TEAMTASK_DEFENSE:
;1019:			p1 = VOICECHAT_ONDEFENSE;
ADDRLP4 8
ADDRGP4 $893
ASGNP4
line 1020
;1020:			p2 = VOICECHAT_DEFEND;
ADDRLP4 4
ADDRGP4 $894
ASGNP4
line 1021
;1021:			b = "+button8; wait; -button8";
ADDRLP4 0
ADDRGP4 $895
ASGNP4
line 1022
;1022:			break;
ADDRGP4 $886
JUMPV
LABELV $896
line 1024
;1023:		case TEAMTASK_PATROL:
;1024:			p1 = VOICECHAT_ONPATROL;
ADDRLP4 8
ADDRGP4 $897
ASGNP4
line 1025
;1025:			p2 = VOICECHAT_PATROL;
ADDRLP4 4
ADDRGP4 $898
ASGNP4
line 1026
;1026:			b = "+button9; wait; -button9";
ADDRLP4 0
ADDRGP4 $899
ASGNP4
line 1027
;1027:			break;
ADDRGP4 $886
JUMPV
LABELV $900
line 1029
;1028:		case TEAMTASK_FOLLOW:
;1029:			p1 = VOICECHAT_ONFOLLOW;
ADDRLP4 8
ADDRGP4 $901
ASGNP4
line 1030
;1030:			p2 = VOICECHAT_FOLLOWME;
ADDRLP4 4
ADDRGP4 $902
ASGNP4
line 1031
;1031:			b = "+button10; wait; -button10";
ADDRLP4 0
ADDRGP4 $903
ASGNP4
line 1032
;1032:			break;
ADDRGP4 $886
JUMPV
LABELV $904
line 1034
;1033:		case TEAMTASK_CAMP:
;1034:			p1 = VOICECHAT_ONCAMPING;
ADDRLP4 8
ADDRGP4 $905
ASGNP4
line 1035
;1035:			p2 = VOICECHAT_CAMP;
ADDRLP4 4
ADDRGP4 $906
ASGNP4
line 1036
;1036:			break;
ADDRGP4 $886
JUMPV
LABELV $907
line 1038
;1037:		case TEAMTASK_RETRIEVE:
;1038:			p1 = VOICECHAT_ONGETFLAG;
ADDRLP4 8
ADDRGP4 $908
ASGNP4
line 1039
;1039:			p2 = VOICECHAT_RETURNFLAG;
ADDRLP4 4
ADDRGP4 $909
ASGNP4
line 1040
;1040:			break;
ADDRGP4 $886
JUMPV
LABELV $910
line 1042
;1041:		case TEAMTASK_ESCORT:
;1042:			p1 = VOICECHAT_ONFOLLOWCARRIER;
ADDRLP4 8
ADDRGP4 $911
ASGNP4
line 1043
;1043:			p2 = VOICECHAT_FOLLOWFLAGCARRIER;
ADDRLP4 4
ADDRGP4 $912
ASGNP4
line 1044
;1044:			break;
LABELV $885
LABELV $886
line 1046
;1045:		}
;1046:		if (cg_currentSelectedPlayer.integer == numSortedTeamPlayers) {
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
NEI4 $915
line 1048
;1047:			// to everyone
;1048:			trap_SendConsoleCommand(va("cmd vsay_team %s\n", p2));
ADDRGP4 $918
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 20
INDIRP4
ARGP4
ADDRGP4 trap_SendConsoleCommand
CALLV
pop
line 1049
;1049:		}
ADDRGP4 $916
JUMPV
LABELV $915
line 1050
;1050:		else {
line 1052
;1051:			// for the player self
;1052:			if (sortedTeamPlayers[cg_currentSelectedPlayer.integer] == cg.snap->ps.clientNum && p1) {
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
NEI4 $919
ADDRLP4 8
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $919
line 1053
;1053:				trap_SendConsoleCommand(va("teamtask %i\n", cgs.currentOrder));
ADDRGP4 $923
ARGP4
ADDRGP4 cgs+150500
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 20
INDIRP4
ARGP4
ADDRGP4 trap_SendConsoleCommand
CALLV
pop
line 1055
;1054:				//trap_SendConsoleCommand(va("cmd say_team %s\n", p2));
;1055:				trap_SendConsoleCommand(va("cmd vsay_team %s\n", p1));
ADDRGP4 $918
ARGP4
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 24
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 24
INDIRP4
ARGP4
ADDRGP4 trap_SendConsoleCommand
CALLV
pop
line 1056
;1056:			}
ADDRGP4 $920
JUMPV
LABELV $919
line 1057
;1057:			else if (p2) {
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $925
line 1059
;1058:				//trap_SendConsoleCommand(va("cmd say_team %s, %s\n", ci->name,p));
;1059:				trap_SendConsoleCommand(va("cmd vtell %d %s\n", sortedTeamPlayers[cg_currentSelectedPlayer.integer], p2));
ADDRGP4 $927
ARGP4
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 20
INDIRP4
ARGP4
ADDRGP4 trap_SendConsoleCommand
CALLV
pop
line 1060
;1060:			}
LABELV $925
LABELV $920
line 1061
;1061:		}
LABELV $916
line 1062
;1062:		if (b) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $929
line 1063
;1063:			trap_SendConsoleCommand(b);
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 trap_SendConsoleCommand
CALLV
pop
line 1064
;1064:		}
LABELV $929
line 1065
;1065:		cgs.orderPending = qfalse;
ADDRGP4 cgs+150504
CNSTI4 0
ASGNI4
line 1066
;1066:	}
LABELV $882
line 1067
;1067:}
LABELV $878
endproc CG_CheckOrderPending 28 12
export CG_OtherTeamHasFlag
proc CG_OtherTeamHasFlag 8 0
line 1071
;1068:
;1069:
;1070:// from cg_newdraw.c
;1071:qboolean CG_OtherTeamHasFlag() {
line 1072
;1072:	if (cgs.gametype == GT_CTF
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 4
NEI4 $933
line 1076
;1073:#ifdef MISSIONPACK
;1074:		|| cgs.gametype == GT_1FCTF
;1075:#endif
;1076:		) {
line 1077
;1077:		int team = cg.snap->ps.persistant[PERS_TEAM];
ADDRLP4 0
ADDRGP4 cg+36
INDIRP4
CNSTI4 304
ADDP4
INDIRI4
ASGNI4
line 1085
;1078:#ifdef MISSIONPACK
;1079:		if (cgs.gametype == GT_1FCTF) {
;1080:			return ((team == TEAM_RED && cgs.flagStatus == FLAG_TAKEN_BLUE) || 
;1081:					(team == TEAM_BLUE && cgs.flagStatus == FLAG_TAKEN_RED));
;1082:		}
;1083:		else {
;1084:#endif
;1085:			return ((team == TEAM_RED && cgs.redflag == FLAG_TAKEN) ||
ADDRLP4 0
INDIRI4
CNSTI4 1
NEI4 $943
ADDRGP4 cgs+34848
INDIRI4
CNSTI4 1
EQI4 $942
LABELV $943
ADDRLP4 0
INDIRI4
CNSTI4 2
NEI4 $940
ADDRGP4 cgs+34852
INDIRI4
CNSTI4 1
NEI4 $940
LABELV $942
ADDRLP4 4
CNSTI4 1
ASGNI4
ADDRGP4 $941
JUMPV
LABELV $940
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $941
ADDRLP4 4
INDIRI4
RETI4
ADDRGP4 $932
JUMPV
LABELV $933
line 1091
;1086:					(team == TEAM_BLUE && cgs.blueflag == FLAG_TAKEN));
;1087:#ifdef MISSIONPACK
;1088:		}
;1089:#endif
;1090:	}
;1091:	return qfalse;
CNSTI4 0
RETI4
LABELV $932
endproc CG_OtherTeamHasFlag 8 0
export CG_YourTeamHasFlag
proc CG_YourTeamHasFlag 8 0
line 1094
;1092:}
;1093:
;1094:qboolean CG_YourTeamHasFlag() {
line 1095
;1095:	if (cgs.gametype == GT_CTF
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 4
NEI4 $945
line 1099
;1096:#ifdef MISSIONPACK
;1097:		|| cgs.gametype == GT_1FCTF
;1098:#endif
;1099:		) {
line 1100
;1100:		int team = cg.snap->ps.persistant[PERS_TEAM];
ADDRLP4 0
ADDRGP4 cg+36
INDIRP4
CNSTI4 304
ADDP4
INDIRI4
ASGNI4
line 1108
;1101:#ifdef MISSIONPACK
;1102:		if (cgs.gametype == GT_1FCTF) {
;1103:			return ((team == TEAM_RED && cgs.flagStatus == FLAG_TAKEN_RED) || 
;1104:					(team == TEAM_BLUE && cgs.flagStatus == FLAG_TAKEN_BLUE))
;1105:		}
;1106:		else {
;1107:#endif
;1108:			return ((team == TEAM_RED && cgs.blueflag == FLAG_TAKEN) || 
ADDRLP4 0
INDIRI4
CNSTI4 1
NEI4 $955
ADDRGP4 cgs+34852
INDIRI4
CNSTI4 1
EQI4 $954
LABELV $955
ADDRLP4 0
INDIRI4
CNSTI4 2
NEI4 $952
ADDRGP4 cgs+34848
INDIRI4
CNSTI4 1
NEI4 $952
LABELV $954
ADDRLP4 4
CNSTI4 1
ASGNI4
ADDRGP4 $953
JUMPV
LABELV $952
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $953
ADDRLP4 4
INDIRI4
RETI4
ADDRGP4 $944
JUMPV
LABELV $945
line 1114
;1109:					(team == TEAM_BLUE && cgs.redflag == FLAG_TAKEN));
;1110:#ifdef MISSIONPACK
;1111:		}
;1112:#endif
;1113:	}
;1114:	return qfalse;
CNSTI4 0
RETI4
LABELV $944
endproc CG_YourTeamHasFlag 8 0
proc CG_SetSelectedPlayerName 8 8
line 1118
;1115:}
;1116:
;1117:// from cg_newdraw.c
;1118:static void CG_SetSelectedPlayerName() {
line 1119
;1119:	if (cg_currentSelectedPlayer.integer >= 0 && cg_currentSelectedPlayer.integer < numSortedTeamPlayers) {
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 0
LTI4 $957
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
GEI4 $957
line 1120
;1120:		clientInfo_t *ci = cgs.clientinfo + sortedTeamPlayers[cg_currentSelectedPlayer.integer];
ADDRLP4 0
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
CNSTI4 1680
MULI4
ADDRGP4 cgs+41012
ADDP4
ASGNP4
line 1121
;1121:		if (ci) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $958
line 1122
;1122:			trap_Cvar_Set("cg_selectedPlayerName", ci->name);
ADDRGP4 $965
ARGP4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRGP4 trap_Cvar_Set
CALLV
pop
line 1123
;1123:			trap_Cvar_Set("cg_selectedPlayer", va("%d", sortedTeamPlayers[cg_currentSelectedPlayer.integer]));
ADDRGP4 $967
ARGP4
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRGP4 $966
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRGP4 trap_Cvar_Set
CALLV
pop
line 1124
;1124:			cgs.currentOrder = ci->teamTask;
ADDRGP4 cgs+150500
ADDRLP4 0
INDIRP4
CNSTI4 100
ADDP4
INDIRI4
ASGNI4
line 1125
;1125:		}
line 1126
;1126:	}
ADDRGP4 $958
JUMPV
LABELV $957
line 1127
;1127:	else {
line 1128
;1128:		trap_Cvar_Set("cg_selectedPlayerName", "Everyone");
ADDRGP4 $965
ARGP4
ADDRGP4 $970
ARGP4
ADDRGP4 trap_Cvar_Set
CALLV
pop
line 1129
;1129:	}
LABELV $958
line 1130
;1130:}
LABELV $956
endproc CG_SetSelectedPlayerName 8 8
export CG_GetSelectedPlayer
proc CG_GetSelectedPlayer 0 0
line 1132
;1131:
;1132:int CG_GetSelectedPlayer(void) {
line 1138
;1133:#ifdef MISSIONPACK
;1134:	if (cg_currentSelectedPlayer.integer < 0 || cg_currentSelectedPlayer.integer >= numSortedTeamPlayers) {
;1135:		cg_currentSelectedPlayer.integer = 0;
;1136:	}
;1137:#endif
;1138:	return cg_currentSelectedPlayer.integer;
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
RETI4
LABELV $971
endproc CG_GetSelectedPlayer 0 0
export CG_SelectNextPlayer
proc CG_SelectNextPlayer 4 0
line 1150
;1139:}
;1140:
;1141:/*
;1142:=================
;1143:CG_SelectPrevPlayer & CG_SelectNextPlayer
;1144:from MISSIONPACK
;1145:bind PGUP "prevTeamMember"
;1146:bind PGDN "nextTeamMember"
;1147:bind o "nextOrder"
;1148:=================
;1149:*/
;1150:void CG_SelectNextPlayer(void) {
line 1151
;1151:	CG_CheckOrderPending();
ADDRGP4 CG_CheckOrderPending
CALLV
pop
line 1153
;1152:
;1153:	if (cg_currentSelectedPlayer.integer >= 0 && cg_currentSelectedPlayer.integer < numSortedTeamPlayers) {
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 0
LTI4 $974
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
GEI4 $974
line 1154
;1154:		cg_currentSelectedPlayer.integer++;
ADDRLP4 0
ADDRGP4 cg_currentSelectedPlayer+12
ASGNP4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1155
;1155:	}
ADDRGP4 $975
JUMPV
LABELV $974
line 1156
;1156:	else {
line 1157
;1157:		cg_currentSelectedPlayer.integer = 0;
ADDRGP4 cg_currentSelectedPlayer+12
CNSTI4 0
ASGNI4
line 1158
;1158:	}
LABELV $975
line 1159
;1159:	CG_SetSelectedPlayerName();
ADDRGP4 CG_SetSelectedPlayerName
CALLV
pop
line 1160
;1160:}
LABELV $973
endproc CG_SelectNextPlayer 4 0
export CG_SelectPrevPlayer
proc CG_SelectPrevPlayer 4 0
line 1162
;1161:
;1162:void CG_SelectPrevPlayer(void) {
line 1163
;1163:	CG_CheckOrderPending();
ADDRGP4 CG_CheckOrderPending
CALLV
pop
line 1165
;1164:
;1165:	if (cg_currentSelectedPlayer.integer > 0 && cg_currentSelectedPlayer.integer <= numSortedTeamPlayers) {
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 0
LEI4 $981
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
GTI4 $981
line 1166
;1166:		cg_currentSelectedPlayer.integer--;
ADDRLP4 0
ADDRGP4 cg_currentSelectedPlayer+12
ASGNP4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1167
;1167:	}
ADDRGP4 $982
JUMPV
LABELV $981
line 1168
;1168:	else {
line 1169
;1169:		cg_currentSelectedPlayer.integer = numSortedTeamPlayers;
ADDRGP4 cg_currentSelectedPlayer+12
ADDRGP4 numSortedTeamPlayers
INDIRI4
ASGNI4
line 1170
;1170:	}
LABELV $982
line 1171
;1171:	CG_SetSelectedPlayerName();
ADDRGP4 CG_SetSelectedPlayerName
CALLV
pop
line 1172
;1172:}
LABELV $980
endproc CG_SelectPrevPlayer 4 0
export CG_StatusHandle
proc CG_StatusHandle 8 0
line 1175
;1173:
;1174:// from cg_newdraw.c
;1175:qhandle_t CG_StatusHandle(int task) {
line 1176
;1176:	qhandle_t h = cgs.media.assaultShader;
ADDRLP4 0
ADDRGP4 cgs+150560+1016
INDIRI4
ASGNI4
line 1177
;1177:	switch (task) {
ADDRLP4 4
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 1
LTI4 $990
ADDRLP4 4
INDIRI4
CNSTI4 7
GTI4 $990
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $1015-4
ADDP4
INDIRP4
JUMPV
data
align 4
LABELV $1015
address $992
address $995
address $998
address $1001
address $1007
address $1010
address $1004
code
LABELV $992
line 1179
;1178:	case TEAMTASK_OFFENSE:
;1179:		h = cgs.media.assaultShader;
ADDRLP4 0
ADDRGP4 cgs+150560+1016
INDIRI4
ASGNI4
line 1180
;1180:		break;
ADDRGP4 $991
JUMPV
LABELV $995
line 1182
;1181:	case TEAMTASK_DEFENSE:
;1182:		h = cgs.media.defendShader;
ADDRLP4 0
ADDRGP4 cgs+150560+1028
INDIRI4
ASGNI4
line 1183
;1183:		break;
ADDRGP4 $991
JUMPV
LABELV $998
line 1185
;1184:	case TEAMTASK_PATROL:
;1185:		h = cgs.media.patrolShader;
ADDRLP4 0
ADDRGP4 cgs+150560+1012
INDIRI4
ASGNI4
line 1186
;1186:		break;
ADDRGP4 $991
JUMPV
LABELV $1001
line 1188
;1187:	case TEAMTASK_FOLLOW:
;1188:		h = cgs.media.followShader;
ADDRLP4 0
ADDRGP4 cgs+150560+1024
INDIRI4
ASGNI4
line 1189
;1189:		break;
ADDRGP4 $991
JUMPV
LABELV $1004
line 1191
;1190:	case TEAMTASK_CAMP:
;1191:		h = cgs.media.campShader;
ADDRLP4 0
ADDRGP4 cgs+150560+1020
INDIRI4
ASGNI4
line 1192
;1192:		break;
ADDRGP4 $991
JUMPV
LABELV $1007
line 1194
;1193:	case TEAMTASK_RETRIEVE:
;1194:		h = cgs.media.retrieveShader;
ADDRLP4 0
ADDRGP4 cgs+150560+1036
INDIRI4
ASGNI4
line 1195
;1195:		break;
ADDRGP4 $991
JUMPV
LABELV $1010
line 1197
;1196:	case TEAMTASK_ESCORT:
;1197:		h = cgs.media.escortShader;
ADDRLP4 0
ADDRGP4 cgs+150560+1040
INDIRI4
ASGNI4
line 1198
;1198:		break;
ADDRGP4 $991
JUMPV
LABELV $990
line 1200
;1199:	default:
;1200:		h = cgs.media.assaultShader;
ADDRLP4 0
ADDRGP4 cgs+150560+1016
INDIRI4
ASGNI4
line 1201
;1201:		break;
LABELV $991
line 1203
;1202:	}
;1203:	return h;
ADDRLP4 0
INDIRI4
RETI4
LABELV $987
endproc CG_StatusHandle 8 0
export CG_DrawSelectedPlayerStatus
proc CG_DrawSelectedPlayerStatus 12 20
line 1207
;1204:}
;1205:
;1206:
;1207:void CG_DrawSelectedPlayerStatus(rectDef_t *rect, int player) {
line 1208
;1208:	clientInfo_t *ci = cgs.clientinfo + sortedTeamPlayers[player];
ADDRLP4 0
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
CNSTI4 1680
MULI4
ADDRGP4 cgs+41012
ADDP4
ASGNP4
line 1209
;1209:	if (ci) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1019
line 1211
;1210:		qhandle_t h;
;1211:		if (cgs.orderPending && (cg_currentSelectedPlayer.integer == numSortedTeamPlayers || cg_currentSelectedPlayer.integer == player)) {
ADDRGP4 cgs+150504
INDIRI4
CNSTI4 0
EQI4 $1021
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
EQI4 $1026
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRFP4 4
INDIRI4
NEI4 $1021
LABELV $1026
line 1213
;1212:			// blink the icon
;1213:			if (cg.time > cgs.orderTime - 2500 && (cg.time >> 9) & 1) {
ADDRGP4 cg+234764
INDIRI4
ADDRGP4 cgs+150508
INDIRI4
CNSTI4 2500
SUBI4
LEI4 $1027
ADDRGP4 cg+234764
INDIRI4
CNSTI4 9
RSHI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $1027
line 1214
;1214:				return;
ADDRGP4 $1017
JUMPV
LABELV $1027
line 1216
;1215:			}
;1216:			h = CG_StatusHandle(cgs.currentOrder);
ADDRGP4 cgs+150500
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 CG_StatusHandle
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1217
;1217:		}
ADDRGP4 $1022
JUMPV
LABELV $1021
line 1218
;1218:		else {
line 1219
;1219:			h = CG_StatusHandle(ci->teamTask);
ADDRLP4 0
INDIRP4
CNSTI4 100
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 CG_StatusHandle
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1220
;1220:		}
LABELV $1022
line 1221
;1221:		CG_DrawPic(rect->x, rect->y, rect->w, rect->h, h);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRF4
ARGF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 8
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
ADDRLP4 4
INDIRI4
ARGI4
ADDRGP4 CG_DrawPic
CALLV
pop
line 1222
;1222:	}
LABELV $1019
line 1223
;1223:}
LABELV $1017
endproc CG_DrawSelectedPlayerStatus 12 20
proc CG_DrawPlayerStatus 16 20
line 1226
;1224:
;1225:// from cg_newdraw.c
;1226:static void CG_DrawPlayerStatus(rectDef_t *rect) {
line 1227
;1227:	clientInfo_t *ci = &cgs.clientinfo[cg.snap->ps.clientNum];
ADDRLP4 0
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
CNSTI4 1680
MULI4
ADDRGP4 cgs+41012
ADDP4
ASGNP4
line 1228
;1228:	if (ci) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1036
line 1229
;1229:		qhandle_t h = CG_StatusHandle(ci->teamTask);
ADDRLP4 0
INDIRP4
CNSTI4 100
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 CG_StatusHandle
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1230
;1230:		CG_DrawPic(rect->x, rect->y, rect->w, rect->h, h);
ADDRLP4 12
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
INDIRF4
ARGF4
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 12
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 12
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
ADDRLP4 4
INDIRI4
ARGI4
ADDRGP4 CG_DrawPic
CALLV
pop
line 1231
;1231:	}
LABELV $1036
line 1232
;1232:}
LABELV $1033
endproc CG_DrawPlayerStatus 16 20
proc HUDParamToTeamPlayerIdx 0 0
line 1234
;1233:
;1234:static int HUDParamToTeamPlayerIdx(item_t * itm) {
line 1235
;1235:	if (itm->propFlags & PROP_TEAM_PLAYER) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $1039
line 1236
;1236:		if (!itm->team_player)
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
NEI4 $1041
line 1237
;1237:			return cg.snap->ps.clientNum;
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
RETI4
ADDRGP4 $1038
JUMPV
LABELV $1041
line 1238
;1238:		else if (itm->team_player < 0) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
GEI4 $1044
line 1239
;1239:			return cg_currentSelectedPlayer.integer;
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
RETI4
ADDRGP4 $1038
JUMPV
LABELV $1044
line 1241
;1240:		}
;1241:		else if (itm->team_player >= 1) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 1
LTI4 $1047
line 1242
;1242:			return itm->team_player;
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
RETI4
ADDRGP4 $1038
JUMPV
LABELV $1047
line 1244
;1243:		}
;1244:	}
LABELV $1039
line 1245
;1245:	return cg.snap->ps.clientNum;
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
RETI4
LABELV $1038
endproc HUDParamToTeamPlayerIdx 0 0
export HUD_DrawBackground
proc HUD_DrawBackground 40 40
line 1248
;1246:}
;1247:
;1248:void HUD_DrawBackground(item_t * itm, rectangle_t *r) {
line 1249
;1249:	qhandle_t	shader = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1251
;1250:
;1251:	int param = (itm->propFlags & PROP_TEAM_PLAYER) ? itm->team_player : itm->param;
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $1052
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $1053
JUMPV
LABELV $1052
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ASGNI4
LABELV $1053
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1253
;1252:
;1253:	if (itm->iconFlags & ICON_GAME_TYPE) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $1054
line 1254
;1254:		shader = cgs.media.gameTypeShader[cgs.gametype];
ADDRLP4 0
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cgs+150560+312
ADDP4
INDIRI4
ASGNI4
line 1255
;1255:	}
ADDRGP4 $1055
JUMPV
LABELV $1054
line 1256
;1256:	else if (itm->iconFlags & ICON_HOLDABLE_ITEM) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 2
BANDU4
CNSTU4 0
EQU4 $1059
line 1257
;1257:		int value = cg.snap->ps.stats[STAT_HOLDABLE_ITEM];
ADDRLP4 12
ADDRGP4 cg+36
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
ASGNI4
line 1258
;1258:		if (value) {
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1060
line 1259
;1259:			CG_RegisterItemVisuals(value);
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_RegisterItemVisuals
CALLV
pop
line 1260
;1260:			shader = cg_items[value].icon;
ADDRLP4 0
ADDRLP4 12
INDIRI4
CNSTI4 28
MULI4
ADDRGP4 cg_items+20
ADDP4
INDIRI4
ASGNI4
line 1261
;1261:		}
line 1262
;1262:	}
ADDRGP4 $1060
JUMPV
LABELV $1059
line 1263
;1263:	else if (itm->iconFlags & ICON_BLUE_FLAG) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $1065
line 1264
;1264:		shader = cgs.media.blueFlagShader[cgs.blueflag];
ADDRLP4 0
ADDRGP4 cgs+34852
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cgs+150560+60
ADDP4
INDIRI4
ASGNI4
line 1265
;1265:	}
ADDRGP4 $1066
JUMPV
LABELV $1065
line 1266
;1266:	else if (itm->iconFlags & ICON_RED_FLAG) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $1070
line 1267
;1267:		shader = cgs.media.redFlagShader[cgs.redflag];
ADDRLP4 0
ADDRGP4 cgs+34848
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cgs+150560+48
ADDP4
INDIRI4
ASGNI4
line 1268
;1268:	}
ADDRGP4 $1071
JUMPV
LABELV $1070
line 1269
;1269:	else if (itm->iconFlags & ICON_ARMOR) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $1075
line 1271
;1270:		int clientNum;
;1271:		if (!param)
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1077
line 1272
;1272:			clientNum = cg.snap->ps.clientNum;
ADDRLP4 12
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $1078
JUMPV
LABELV $1077
line 1273
;1273:		else if (param < 0) {
ADDRLP4 4
INDIRI4
CNSTI4 0
GEI4 $1080
line 1274
;1274:			clientNum = cg_currentSelectedPlayer.integer;
ADDRLP4 12
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ASGNI4
line 1275
;1275:		}
ADDRGP4 $1081
JUMPV
LABELV $1080
line 1276
;1276:		else if (param >= 1)
ADDRLP4 4
INDIRI4
CNSTI4 1
LTI4 $1083
line 1277
;1277:			clientNum = param;
ADDRLP4 12
ADDRLP4 4
INDIRI4
ASGNI4
LABELV $1083
LABELV $1081
LABELV $1078
line 1278
;1278:		CG_Draw_Icon_Armor(itm, *r, clientNum);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRFP4 4
INDIRP4
INDIRB
ASGNB 16
ADDRLP4 16
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_Draw_Icon_Armor
CALLV
pop
line 1279
;1279:	}
ADDRGP4 $1076
JUMPV
LABELV $1075
line 1280
;1280:	else if (itm->iconFlags & ICON_AMMO) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CNSTU4 0
EQU4 $1085
line 1281
;1281:		int clientNum = HUDParamToTeamPlayerIdx(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 HUDParamToTeamPlayerIdx
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 16
INDIRI4
ASGNI4
line 1282
;1282:		CG_Draw_Icon_Ammo(itm, *r, clientNum);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRFP4 4
INDIRP4
INDIRB
ASGNB 16
ADDRLP4 20
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_Draw_Icon_Ammo
CALLV
pop
line 1283
;1283:	}
ADDRGP4 $1086
JUMPV
LABELV $1085
line 1284
;1284:	else if (itm->iconFlags & ICON_POWERUP) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 4096
BANDU4
CNSTU4 0
EQU4 $1087
line 1285
;1285:		int clientNum = HUDParamToTeamPlayerIdx(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 HUDParamToTeamPlayerIdx
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 16
INDIRI4
ASGNI4
line 1286
;1286:		CG_DrawTeamPlayerPowerup(r, itm->team_player, 0 );
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ARGI4
CNSTI4 0
ARGI4
ADDRGP4 CG_DrawTeamPlayerPowerup
CALLV
pop
line 1287
;1287:	}
ADDRGP4 $1088
JUMPV
LABELV $1087
line 1288
;1288:	else if (itm->iconFlags & ICON_HEAD || itm->iconFlags & ICON_HEAD_ANIM ) {
ADDRLP4 12
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
NEU4 $1091
ADDRLP4 12
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $1089
LABELV $1091
line 1289
;1289:		int clientNum = HUDParamToTeamPlayerIdx(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 HUDParamToTeamPlayerIdx
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 20
INDIRI4
ASGNI4
line 1290
;1290:		CG_DrawStatusBarHead(itm, *r, clientNum);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 4
INDIRP4
INDIRB
ASGNB 16
ADDRLP4 24
ARGP4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 CG_DrawStatusBarHead
CALLV
pop
line 1291
;1291:		return;
ADDRGP4 $1050
JUMPV
LABELV $1089
line 1293
;1292:	}
;1293:	else if (itm->iconFlags & ICON_ATTACKER) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $1092
line 1294
;1294:		CG_DrawAttacker_icon(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 CG_DrawAttacker_icon
CALLV
pop
line 1295
;1295:	}
ADDRGP4 $1093
JUMPV
LABELV $1092
line 1296
;1296:	else if (itm->iconFlags & ICON_ORDER) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 2048
BANDU4
CNSTU4 0
EQU4 $1094
line 1297
;1297:		if (!param) {
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1096
line 1298
;1298:			CG_DrawPlayerStatus(r);
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 CG_DrawPlayerStatus
CALLV
pop
line 1299
;1299:		}
ADDRGP4 $1050
JUMPV
LABELV $1096
line 1300
;1300:		else if (param < 0) {
ADDRLP4 4
INDIRI4
CNSTI4 0
GEI4 $1098
line 1301
;1301:			CG_DrawSelectedPlayerStatus(r, CG_GetSelectedPlayer());
ADDRLP4 16
ADDRGP4 CG_GetSelectedPlayer
CALLI4
ASGNI4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 CG_DrawSelectedPlayerStatus
CALLV
pop
line 1302
;1302:		}
ADDRGP4 $1050
JUMPV
LABELV $1098
line 1303
;1303:		else if (param >= 1) {
ADDRLP4 4
INDIRI4
CNSTI4 1
LTI4 $1050
line 1304
;1304:			CG_DrawSelectedPlayerStatus(r, param);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRGP4 CG_DrawSelectedPlayerStatus
CALLV
pop
line 1305
;1305:		}
line 1306
;1306:		return;
ADDRGP4 $1050
JUMPV
LABELV $1094
line 1308
;1307:	}
;1308:	else if (itm->shader) {
ADDRFP4 0
INDIRP4
CNSTI4 1192
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1102
line 1309
;1309:		shader = CG_HUDShader(itm, cgs.media.whiteShader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 cgs+150560+16
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 CG_HUDShader
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 16
INDIRI4
ASGNI4
line 1310
;1310:	}
LABELV $1102
LABELV $1093
LABELV $1088
LABELV $1086
LABELV $1076
LABELV $1071
LABELV $1066
LABELV $1060
LABELV $1055
line 1312
;1311:
;1312:	if (shader) {
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1106
line 1313
;1313:		if (itm->propFlags & PROP_VERTICALBAR) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $1108
line 1314
;1314:			if (itm->iconFlags & ICON_INVERT_W) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1110
line 1315
;1315:				r->x += r->w;
ADDRLP4 16
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDF4
ASGNF4
line 1316
;1316:				r->w = -r->w;
ADDRLP4 20
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
NEGF4
ASGNF4
line 1317
;1317:			}
LABELV $1110
line 1318
;1318:			CG_DrawGradientPic(itm, r->x, r->y - r->h, r->w, r->h, 0, 0, 1, 1, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 16
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
SUBF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
CNSTF4 0
ARGF4
CNSTF4 0
ARGF4
CNSTF4 1065353216
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 0
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 1319
;1319:		}
ADDRGP4 $1109
JUMPV
LABELV $1108
line 1320
;1320:		else {
line 1321
;1321:			if (itm->iconFlags & ICON_INVERT_W) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1112
line 1322
;1322:				r->x += r->w;
ADDRLP4 16
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDF4
ASGNF4
line 1323
;1323:				r->w = -r->w;
ADDRLP4 20
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
NEGF4
ASGNF4
line 1324
;1324:			}
LABELV $1112
line 1325
;1325:			CG_DrawGradientPic(itm, r->x, r->y, r->w, r->h, 0, 0, 1, 1, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
CNSTF4 0
ARGF4
CNSTF4 0
ARGF4
CNSTF4 1065353216
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 0
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 1326
;1326:		}
LABELV $1109
line 1327
;1327:	}
LABELV $1106
line 1328
;1328:}
LABELV $1050
endproc HUD_DrawBackground 40 40
export HUD_getText
proc HUD_getText 20 16
line 1330
;1329:
;1330:const char * HUD_getText(item_t *itm, int value) {
line 1333
;1331:	char		*s;
;1332:
;1333:	if (itm->text.flags & VAL_TEXT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $1115
line 1334
;1334:		s = itm->text.caption;
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1196
ADDP4
INDIRP4
ASGNP4
line 1335
;1335:	}
ADDRGP4 $1116
JUMPV
LABELV $1115
line 1336
;1336:	else if (itm->text.flags & VAL_SPEED) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $1117
line 1337
;1337:		if (itm->param == 1)
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
CNSTI4 1
NEI4 $1119
line 1338
;1338:			s = va("%1.0i", value);
ADDRGP4 $1121
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
ADDRGP4 $1118
JUMPV
LABELV $1119
line 1340
;1339:		else
;1340:			s = va("%1.0iups", value);
ADDRGP4 $1122
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
ASGNP4
line 1341
;1341:	}
ADDRGP4 $1118
JUMPV
LABELV $1117
line 1342
;1342:	else if (itm->text.flags & VAL_NAME) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 2
BANDU4
CNSTU4 0
EQU4 $1123
line 1343
;1343:		const char* plyrName = getTeamPlayerName(itm->team_player);
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 getTeamPlayerName
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 8
INDIRP4
ASGNP4
line 1344
;1344:		s = va("%s", plyrName);
ADDRGP4 $1125
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1345
;1345:	}
ADDRGP4 $1124
JUMPV
LABELV $1123
line 1346
;1346:	else if (itm->text.flags & VAL_HEALTH) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $1126
line 1347
;1347:		int playerHealth = getPlayerHealth(itm->team_player);
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 getPlayerHealth
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1348
;1348:		s = va("%i", playerHealth);
ADDRGP4 $1128
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1349
;1349:	}
ADDRGP4 $1127
JUMPV
LABELV $1126
line 1350
;1350:	else if (itm->text.flags & VAL_TIMER) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $1129
line 1354
;1351:		int			mins, seconds;
;1352:		int			msec;
;1353:
;1354:		msec = cg.time - cgs.levelStartTime;
ADDRLP4 8
ADDRGP4 cg+234764
INDIRI4
ADDRGP4 cgs+34836
INDIRI4
SUBI4
ASGNI4
line 1355
;1355:		seconds = msec / 1000;
ADDRLP4 4
ADDRLP4 8
INDIRI4
CNSTI4 1000
DIVI4
ASGNI4
line 1356
;1356:		mins = seconds / 60;
ADDRLP4 12
ADDRLP4 4
INDIRI4
CNSTI4 60
DIVI4
ASGNI4
line 1357
;1357:		seconds -= mins * 60;
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 12
INDIRI4
CNSTI4 60
MULI4
SUBI4
ASGNI4
line 1359
;1358:
;1359:		msec = cg.time - cgs.levelStartTime;
ADDRLP4 8
ADDRGP4 cg+234764
INDIRI4
ADDRGP4 cgs+34836
INDIRI4
SUBI4
ASGNI4
line 1362
;1360:
;1361:		// param 2: countdown
;1362:		if (itm->param == 2 && cgs.timelimit) {
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
CNSTI4 2
NEI4 $1135
ADDRGP4 cgs+31516
INDIRI4
CNSTI4 0
EQI4 $1135
line 1363
;1363:			msec = (cgs.timelimit * 60 * 1000) - msec;
ADDRLP4 8
ADDRGP4 cgs+31516
INDIRI4
CNSTI4 60
MULI4
CNSTI4 1000
MULI4
ADDRLP4 8
INDIRI4
SUBI4
ASGNI4
line 1364
;1364:		}
LABELV $1135
line 1366
;1365:
;1366:		seconds = msec / 1000;
ADDRLP4 4
ADDRLP4 8
INDIRI4
CNSTI4 1000
DIVI4
ASGNI4
line 1367
;1367:		mins = seconds / 60;
ADDRLP4 12
ADDRLP4 4
INDIRI4
CNSTI4 60
DIVI4
ASGNI4
line 1368
;1368:		seconds -= mins * 60;
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 12
INDIRI4
CNSTI4 60
MULI4
SUBI4
ASGNI4
line 1370
;1369:
;1370:		if (itm->param == 1) {
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
CNSTI4 1
NEI4 $1139
line 1371
;1371:			if (mins) {
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1141
line 1372
;1372:				msec = msec - (mins * 60 * 1000) - (seconds * 1000);
ADDRLP4 8
ADDRLP4 8
INDIRI4
ADDRLP4 12
INDIRI4
CNSTI4 60
MULI4
CNSTI4 1000
MULI4
SUBI4
ADDRLP4 4
INDIRI4
CNSTI4 1000
MULI4
SUBI4
ASGNI4
line 1373
;1373:				s = va("%i:%i:%02i", mins, seconds, msec);
ADDRGP4 $1143
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1374
;1374:			}
ADDRGP4 $1130
JUMPV
LABELV $1141
line 1375
;1375:			else {
line 1376
;1376:				msec -= (seconds * 1000);
ADDRLP4 8
ADDRLP4 8
INDIRI4
ADDRLP4 4
INDIRI4
CNSTI4 1000
MULI4
SUBI4
ASGNI4
line 1377
;1377:				s = va("%i:%02i", seconds, msec);
ADDRGP4 $1144
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1378
;1378:			}
line 1379
;1379:		}
ADDRGP4 $1130
JUMPV
LABELV $1139
line 1380
;1380:		else {
line 1381
;1381:			s = va("%i:%02i", mins, seconds);
ADDRGP4 $1144
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1382
;1382:		}
line 1383
;1383:	}
ADDRGP4 $1130
JUMPV
LABELV $1129
line 1384
;1384:	else if (itm->text.flags & VAL_FPS) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $1145
line 1385
;1385:		s = va("%ifps", FPS);
ADDRGP4 $1147
ARGP4
ADDRGP4 FPS
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1386
;1386:	}
ADDRGP4 $1146
JUMPV
LABELV $1145
line 1387
;1387:	else if (itm->text.flags & VAL_FOLLOW_NAME) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 32768
BANDU4
CNSTU4 0
EQU4 $1148
line 1388
;1388:		s = cgs.clientinfo[cg.snap->ps.clientNum].name;
ADDRLP4 0
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
CNSTI4 1680
MULI4
ADDRGP4 cgs+41012+4
ADDP4
ASGNP4
line 1389
;1389:	}
ADDRGP4 $1149
JUMPV
LABELV $1148
line 1390
;1390:	else if (itm->text.flags & VAL_SNAPSHOT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 65536
BANDU4
CNSTU4 0
EQU4 $1153
line 1391
;1391:		s = va("time:%i snap:%i cmd:%i", cg.snap->serverTime, cg.latestSnapshotNum, cgs.serverCommandSequence);
ADDRGP4 $1155
ARGP4
ADDRGP4 cg+36
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRGP4 cg+28
INDIRI4
ARGI4
ADDRGP4 cgs+31484
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1392
;1392:	}
ADDRGP4 $1154
JUMPV
LABELV $1153
line 1393
;1393:	else if (itm->text.flags & VAL_LOCATION) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 131072
BANDU4
CNSTU4 0
EQU4 $1159
line 1394
;1394:		const char* str = getPlayerLocation(itm->team_player);
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 getPlayerLocation
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 8
INDIRP4
ASGNP4
line 1395
;1395:		s = va("%s", str);
ADDRGP4 $1125
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1396
;1396:	}
ADDRGP4 $1160
JUMPV
LABELV $1159
line 1397
;1397:	else if (itm->text.flags & VAL_CAPFRAG_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 2048
BANDU4
CNSTU4 0
EQU4 $1161
line 1398
;1398:		int lim = (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 4
LTI4 $1167
ADDRLP4 8
ADDRGP4 cgs+31512
INDIRI4
ASGNI4
ADDRGP4 $1168
JUMPV
LABELV $1167
ADDRLP4 8
ADDRGP4 cgs+31508
INDIRI4
ASGNI4
LABELV $1168
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1399
;1399:		s = va("%2i", lim);
ADDRGP4 $1169
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1400
;1400:	}
ADDRGP4 $1162
JUMPV
LABELV $1161
line 1401
;1401:	else if (itm->text.flags & VAL_FRAG_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4096
BANDU4
CNSTU4 0
EQU4 $1170
line 1402
;1402:		s = va("%2i", cgs.fraglimit);
ADDRGP4 $1169
ARGP4
ADDRGP4 cgs+31508
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1403
;1403:	}
ADDRGP4 $1171
JUMPV
LABELV $1170
line 1404
;1404:	else if (itm->text.flags & VAL_CAPTURE_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $1173
line 1405
;1405:		s = va("%2i", cgs.capturelimit);
ADDRGP4 $1169
ARGP4
ADDRGP4 cgs+31512
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1406
;1406:	}
ADDRGP4 $1174
JUMPV
LABELV $1173
line 1407
;1407:	else if (itm->text.flags & VAL_AMMO) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $1176
line 1408
;1408:		int val = HUD_PropValue(itm, VAL_AMMO, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 4
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 1409
;1409:		s = va("%2i", val);
ADDRGP4 $1169
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1410
;1410:	}
ADDRGP4 $1177
JUMPV
LABELV $1176
line 1411
;1411:	else if (itm->text.flags & VAL_ARMOR) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1178
line 1412
;1412:		int val = GetTeamPlayerstat(itm, STAT_ARMOR);
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 3
ARGI4
ADDRLP4 8
ADDRGP4 GetTeamPlayerstat
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1413
;1413:		s = va("%2i", val);
ADDRGP4 $1169
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1414
;1414:	}
ADDRGP4 $1179
JUMPV
LABELV $1178
line 1415
;1415:	else if (itm->text.flags & VAL_WEAPON) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $1180
line 1416
;1416:		int val = HUD_PropValue(itm, VAL_WEAPON, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 32
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 1417
;1417:		s = va("%2i", val);
ADDRGP4 $1169
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1418
;1418:	}
ADDRGP4 $1181
JUMPV
LABELV $1180
line 1419
;1419:	else if (itm->text.flags & VAL_HOLDABLE_ITEM) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $1182
line 1420
;1420:		int val = HUD_PropValue(itm, VAL_HOLDABLE_ITEM, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 1421
;1421:		s = va("%2i", val);
ADDRGP4 $1169
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1422
;1422:	}
ADDRGP4 $1183
JUMPV
LABELV $1182
line 1423
;1423:	else if (itm->text.flags & VAL_SCORE) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CNSTU4 0
EQU4 $1184
line 1424
;1424:		int val = HUD_PropValue(itm, VAL_SCORE, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 1024
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 1425
;1425:		s = va("%2i", val);
ADDRGP4 $1169
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1426
;1426:	}
ADDRGP4 $1185
JUMPV
LABELV $1184
line 1427
;1427:	else if (itm->text.flags & VAL_TIME_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $1186
line 1428
;1428:		s = va("%2i", ((cgs.timelimit) * 60));
ADDRGP4 $1169
ARGP4
ADDRGP4 cgs+31516
INDIRI4
CNSTI4 60
MULI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1429
;1429:	}
ADDRGP4 $1187
JUMPV
LABELV $1186
line 1430
;1430:	else {
line 1431
;1431:		s = va("%i", value);
ADDRGP4 $1128
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1432
;1432:	}
LABELV $1187
LABELV $1185
LABELV $1183
LABELV $1181
LABELV $1179
LABELV $1177
LABELV $1174
LABELV $1171
LABELV $1162
LABELV $1160
LABELV $1154
LABELV $1149
LABELV $1146
LABELV $1130
LABELV $1127
LABELV $1124
LABELV $1118
LABELV $1116
line 1433
;1433:	return s;
ADDRLP4 0
INDIRP4
RETP4
LABELV $1114
endproc HUD_getText 20 16
export HUD_Draw_Text
proc HUD_Draw_Text 64 32
line 1436
;1434:}
;1435:
;1436:void HUD_Draw_Text(item_t *itm, rectangle_t *r) {
line 1442
;1437:	int			value;
;1438:	const char	*s;
;1439:	vec4_t		forecolor;
;1440:	qboolean	showZeroValue;
;1441:
;1442:	if (!itm->text.flags)
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 0
NEU4 $1190
line 1443
;1443:		return;
ADDRGP4 $1189
JUMPV
LABELV $1190
line 1445
;1444:
;1445:	value = HUD_ItemCaptionValue(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ADDRGP4 HUD_ItemCaptionValue
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 28
INDIRI4
ASGNI4
line 1447
;1446:
;1447:	showZeroValue = (value == 0 && (itm->visible_prop_flags[1] & VIS_ZERO_VALUE));
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1193
ADDRFP4 0
INDIRP4
CNSTI4 1064
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $1193
ADDRLP4 32
CNSTI4 1
ASGNI4
ADDRGP4 $1194
JUMPV
LABELV $1193
ADDRLP4 32
CNSTI4 0
ASGNI4
LABELV $1194
ADDRLP4 4
ADDRLP4 32
INDIRI4
ASGNI4
line 1450
;1448:
;1449:	// allow 0 xhen VIS_SHOW_ZERO_VALUE in item's flags
;1450:	if (value >= 0 && !showZeroValue) {
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $1195
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1195
line 1451
;1451:		HUD_color(itm, &itm->forecolor, &forecolor, colorWhite);
ADDRLP4 36
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 36
INDIRP4
ARGP4
ADDRLP4 36
INDIRP4
CNSTI4 1152
ADDP4
ARGP4
ADDRLP4 12
ARGP4
ADDRGP4 colorWhite
ARGP4
ADDRGP4 HUD_color
CALLV
pop
line 1453
;1452:
;1453:		s = HUD_getText(itm, value);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 40
ADDRGP4 HUD_getText
CALLP4
ASGNP4
ADDRLP4 8
ADDRLP4 40
INDIRP4
ASGNP4
line 1457
;1454:
;1455:#ifdef USE_NEW_FONT_RENDERER
;1456:
;1457:		CG_SelectFont(itm->text.styleflags);
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
INDIRU4
CVUI4 4
ARGI4
ADDRGP4 CG_SelectFont
CALLV
pop
line 1459
;1458:
;1459:		CG_DrawString(r->x, r->y, s, forecolor, itm->fontsize.w, itm->fontsize.h, 0, itm->text.styleflags);
ADDRLP4 44
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 44
INDIRP4
INDIRF4
ARGF4
ADDRLP4 44
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 12
ARGP4
ADDRLP4 48
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 48
INDIRP4
CNSTI4 1120
ADDP4
INDIRF4
ARGF4
ADDRLP4 48
INDIRP4
CNSTI4 1124
ADDP4
INDIRF4
ARGF4
CNSTI4 0
ARGI4
ADDRLP4 48
INDIRP4
CNSTI4 1200
ADDP4
INDIRU4
CVUI4 4
ARGI4
ADDRGP4 CG_DrawString
CALLV
pop
line 1461
;1460:
;1461:		CG_SelectFont(0);
CNSTI4 0
ARGI4
ADDRGP4 CG_SelectFont
CALLV
pop
line 1463
;1462:
;1463:		r->w = itm->fontsize.w * CG_DrawStrlen(s);
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 52
ADDRGP4 CG_DrawStrlen
CALLI4
ASGNI4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 1120
ADDP4
INDIRF4
ADDRLP4 52
INDIRI4
CVIF4 4
MULF4
ASGNF4
line 1464
;1464:		if (itm->text.styleflags & DS_RIGHT)
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1197
line 1465
;1465:			r->x -= r->w;
ADDRLP4 56
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 56
INDIRP4
ADDRLP4 56
INDIRP4
INDIRF4
ADDRLP4 56
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
SUBF4
ASGNF4
LABELV $1197
line 1466
;1466:		if (itm->text.styleflags & DS_CENTER)
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $1199
line 1467
;1467:			r->x -= 0.5f * r->w;
ADDRLP4 60
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 60
INDIRP4
ADDRLP4 60
INDIRP4
INDIRF4
ADDRLP4 60
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
CNSTF4 1056964608
MULF4
SUBF4
ASGNF4
LABELV $1199
line 1468
;1468:		r->h = itm->fontsize.h;
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 1124
ADDP4
INDIRF4
ASGNF4
line 1474
;1469:
;1470:#else
;1471:		trap_R_SetColor(forecolor);
;1472:		CG_DrawField(r->x, r->y, 3, value, itm->fontsize.w, itm->fontsize.h);
;1473:#endif
;1474:	}
LABELV $1195
line 1475
;1475:}
LABELV $1189
endproc HUD_Draw_Text 64 32
export CG_HUDShader
proc CG_HUDShader 0 0
line 1483
;1476:
;1477:
;1478:/*
;1479:===============
;1480:HudShader
;1481:===============
;1482:*/
;1483:qhandle_t CG_HUDShader(item_t *itm, qhandle_t defaultShader) {
line 1484
;1484:	if (!itm->shader)
ADDRFP4 0
INDIRP4
CNSTI4 1192
ADDP4
INDIRI4
CNSTI4 0
NEI4 $1202
line 1485
;1485:		return defaultShader;
ADDRFP4 4
INDIRI4
RETI4
ADDRGP4 $1201
JUMPV
LABELV $1202
line 1487
;1486:	else
;1487:		return itm->shader;
ADDRFP4 0
INDIRP4
CNSTI4 1192
ADDP4
INDIRI4
RETI4
LABELV $1201
endproc CG_HUDShader 0 0
proc rectangleIsNull 8 0
line 1490
;1488:}
;1489:
;1490:static qboolean rectangleIsNull(rectangle_t r) {
line 1491
;1491:	return (!r.x && !r.y && !r.w && !r.h);
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
INDIRF4
CNSTF4 0
NEF4 $1206
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1206
ADDRLP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1206
ADDRLP4 4
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1206
ADDRLP4 0
CNSTI4 1
ASGNI4
ADDRGP4 $1207
JUMPV
LABELV $1206
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $1207
ADDRLP4 0
INDIRI4
RETI4
LABELV $1204
endproc rectangleIsNull 8 0
export getParentRect
proc getParentRect 1252 8
line 1494
;1492:}
;1493:
;1494:void getParentRect(const item_t *itm, rectangle_t *res) {
line 1497
;1495:	item_t parentItm;
;1496:
;1497:	if (!itm->parent) {
ADDRFP4 0
INDIRP4
CNSTI4 1028
ADDP4
INDIRI4
CNSTI4 0
NEI4 $1209
line 1498
;1498:		return;
ADDRGP4 $1208
JUMPV
LABELV $1209
line 1502
;1499:	}
;1500:
;1501:	// the minus sign indicate that item is in dyn_itemArray
;1502:	if (itm->parent < 0) {
ADDRFP4 0
INDIRP4
CNSTI4 1028
ADDP4
INDIRI4
CNSTI4 0
GEI4 $1211
line 1503
;1503:		parentItm = dyn_itemArray[-itm->parent];
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1028
ADDP4
INDIRI4
NEGI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray
ADDP4
INDIRB
ASGNB 1212
line 1504
;1504:	}
ADDRGP4 $1212
JUMPV
LABELV $1211
line 1505
;1505:	else {
line 1506
;1506:		parentItm = itemArray[itm->parent];
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1028
ADDP4
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray
ADDP4
INDIRB
ASGNB 1212
line 1507
;1507:	}
LABELV $1212
line 1509
;1508:	// use parent finalRect (real drawn rectangle for dynamic sized items)
;1509:	if (!rectangleIsNull(parentItm.finalRect)) {
ADDRLP4 1212
ADDRLP4 0+1104
INDIRB
ASGNB 16
ADDRLP4 1212
ARGP4
ADDRLP4 1228
ADDRGP4 rectangleIsNull
CALLI4
ASGNI4
ADDRLP4 1228
INDIRI4
CNSTI4 0
NEI4 $1213
line 1510
;1510:		*res = parentItm.finalRect;
ADDRFP4 4
INDIRP4
ADDRLP4 0+1104
INDIRB
ASGNB 16
line 1511
;1511:		return;
ADDRGP4 $1208
JUMPV
LABELV $1213
line 1513
;1512:	}
;1513:	else {
line 1515
;1514:		// if item not (or not yet) in this frame, use its original rect property
;1515:		if (!rectangleIsNull(parentItm.rect)) {
ADDRLP4 1232
ADDRLP4 0+1088
INDIRB
ASGNB 16
ADDRLP4 1232
ARGP4
ADDRLP4 1248
ADDRGP4 rectangleIsNull
CALLI4
ASGNI4
ADDRLP4 1248
INDIRI4
CNSTI4 0
NEI4 $1217
line 1516
;1516:			*res = parentItm.rect;
ADDRFP4 4
INDIRP4
ADDRLP4 0+1088
INDIRB
ASGNB 16
line 1517
;1517:		}
ADDRGP4 $1218
JUMPV
LABELV $1217
line 1518
;1518:		else if (parentItm.parent) {
ADDRLP4 0+1028
INDIRI4
CNSTI4 0
EQI4 $1221
line 1519
;1519:			getParentRect(&parentItm, res);
ADDRLP4 0
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 getParentRect
CALLV
pop
line 1520
;1520:		}
LABELV $1221
LABELV $1218
line 1521
;1521:	}
line 1522
;1522:}
LABELV $1208
endproc getParentRect 1252 8
export HUD_Update_Anchors
proc HUD_Update_Anchors 44 8
line 1529
;1523:
;1524:/*
;1525:================
;1526:CG_Update_Anchors
;1527:================
;1528:*/
;1529:void HUD_Update_Anchors(const item_t *itm, rectangle_t *r) {
line 1532
;1530:	rectangle_t parentR;
;1531:
;1532:	parentR.x = parentR.y = parentR.w = parentR.h = 0;
ADDRLP4 16
CNSTF4 0
ASGNF4
ADDRLP4 0+12
ADDRLP4 16
INDIRF4
ASGNF4
ADDRLP4 0+8
ADDRLP4 16
INDIRF4
ASGNF4
ADDRLP4 0+4
ADDRLP4 16
INDIRF4
ASGNF4
ADDRLP4 0
ADDRLP4 16
INDIRF4
ASGNF4
line 1534
;1533:
;1534:	getParentRect(itm, &parentR);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
ARGP4
ADDRGP4 getParentRect
CALLV
pop
line 1536
;1535:	
;1536:	if (rectangleIsNull(parentR)) {
ADDRLP4 20
ADDRLP4 0
INDIRB
ASGNB 16
ADDRLP4 20
ARGP4
ADDRLP4 36
ADDRGP4 rectangleIsNull
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
EQI4 $1228
line 1537
;1537:		return;
ADDRGP4 $1224
JUMPV
LABELV $1228
line 1543
;1538:	}
;1539:
;1540:	// Left/Right and Top/Bottom should be inverted, but this was counter-intuitive.
;1541:	// (an item left to its parent, is actually anchored by its right side)
;1542:
;1543:	if (itm->propFlags & PROP_ANCHOR_RIGHT) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $1230
line 1544
;1544:		r->x += parentR.x + parentR.w;
ADDRLP4 40
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0
INDIRF4
ADDRLP4 0+8
INDIRF4
ADDF4
ADDF4
ASGNF4
line 1545
;1545:	}
ADDRGP4 $1231
JUMPV
LABELV $1230
line 1546
;1546:	else if (itm->propFlags & PROP_ANCHOR_LEFT) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1233
line 1547
;1547:		r->x += parentR.x - r->w;
ADDRLP4 40
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0
INDIRF4
ADDRLP4 40
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
SUBF4
ADDF4
ASGNF4
line 1548
;1548:	}
ADDRGP4 $1234
JUMPV
LABELV $1233
line 1549
;1549:	else if (itm->propFlags & PROP_ANCHOR_CENTER) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $1235
line 1550
;1550:		r->x += parentR.x;
ADDRLP4 40
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0
INDIRF4
ADDF4
ASGNF4
line 1551
;1551:	}
LABELV $1235
LABELV $1234
LABELV $1231
line 1553
;1552:
;1553:	if (itm->propFlags & PROP_ANCHOR_BOTTOM) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $1237
line 1554
;1554:		r->y += parentR.y + parentR.h;
ADDRLP4 40
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0+4
INDIRF4
ADDRLP4 0+12
INDIRF4
ADDF4
ADDF4
ASGNF4
line 1555
;1555:	}
ADDRGP4 $1238
JUMPV
LABELV $1237
line 1556
;1556:	else if (itm->propFlags & PROP_ANCHOR_TOP) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $1241
line 1557
;1557:		r->y += parentR.y - itm->rect.h;
ADDRLP4 40
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0+4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1100
ADDP4
INDIRF4
SUBF4
ADDF4
ASGNF4
line 1558
;1558:	}
ADDRGP4 $1242
JUMPV
LABELV $1241
line 1559
;1559:	else if (itm->propFlags & PROP_ANCHOR_MIDDLE) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $1244
line 1560
;1560:		r->y += parentR.y;
ADDRLP4 40
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0+4
INDIRF4
ADDF4
ASGNF4
line 1561
;1561:	}
LABELV $1244
LABELV $1242
LABELV $1238
line 1564
;1562:
;1563:	// GUNNM TODO: use screen rectangle as a parent when no parent are provided
;1564:}
LABELV $1224
endproc HUD_Update_Anchors 44 8
export HUD_Update_Margin
proc HUD_Update_Margin 16 0
line 1572
;1565:
;1566:/*
;1567:===============
;1568:CG_Update_Margin
;1569:===============
;1570:*/
;1571:void HUD_Update_Margin(item_t *itm, rectangle_t *r)
;1572:{
line 1574
;1573:	// return if no margins defined
;1574:	if (itm->margin.left == 0 && itm->margin.right == 0 &&
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
CNSTI4 1176
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1248
ADDRLP4 0
INDIRP4
CNSTI4 1180
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1248
ADDRLP4 0
INDIRP4
CNSTI4 1184
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1248
ADDRLP4 0
INDIRP4
CNSTI4 1188
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1248
line 1575
;1575:		itm->margin.top == 0 && itm->margin.bottom == 0) {
line 1576
;1576:		return;
ADDRGP4 $1247
JUMPV
LABELV $1248
line 1579
;1577:	}
;1578:
;1579:	if (itm->propFlags & PROP_ANCHOR_LEFT ) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1250
line 1580
;1580:		r->x -= itm->margin.left;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1176
ADDP4
INDIRF4
SUBF4
ASGNF4
line 1581
;1581:	}
ADDRGP4 $1251
JUMPV
LABELV $1250
line 1582
;1582:	else if (itm->propFlags & PROP_ANCHOR_CENTER || (itm->propFlags & PROP_ANCHOR_RIGHT)) {
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
NEU4 $1254
ADDRLP4 4
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $1252
LABELV $1254
line 1583
;1583:		r->x += itm->margin.right;
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1180
ADDP4
INDIRF4
ADDF4
ASGNF4
line 1584
;1584:	}
LABELV $1252
LABELV $1251
line 1586
;1585:
;1586:	if (itm->propFlags & PROP_ANCHOR_BOTTOM || (itm->propFlags & PROP_ANCHOR_MIDDLE)) {
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
NEU4 $1257
ADDRLP4 8
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $1255
LABELV $1257
line 1587
;1587:		r->y += itm->margin.bottom;
ADDRLP4 12
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1188
ADDP4
INDIRF4
ADDF4
ASGNF4
line 1588
;1588:	}
ADDRGP4 $1256
JUMPV
LABELV $1255
line 1589
;1589:	else if (itm->propFlags & PROP_ANCHOR_TOP) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $1258
line 1590
;1590:		r->y -= itm->margin.top;
ADDRLP4 12
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1184
ADDP4
INDIRF4
SUBF4
ASGNF4
line 1591
;1591:	}
LABELV $1258
LABELV $1256
line 1592
;1592:}
LABELV $1247
endproc HUD_Update_Margin 16 0
export HUD_Update_Valign
proc HUD_Update_Valign 16 0
line 1601
;1593:
;1594:
;1595:/*
;1596:===============
;1597:CG_Update_Valign
;1598:===============
;1599:*/
;1600:void HUD_Update_Valign(item_t *itm, rectangle_t *r)
;1601:{
line 1603
;1602:	int h;
;1603:	if (itm->rect.h) {
ADDRFP4 0
INDIRP4
CNSTI4 1100
ADDP4
INDIRF4
CNSTF4 0
EQF4 $1261
line 1604
;1604:		h = itm->rect.h;
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1100
ADDP4
INDIRF4
CVFI4 4
ASGNI4
line 1605
;1605:	}
ADDRGP4 $1262
JUMPV
LABELV $1261
line 1606
;1606:	else if (itm->fontsize.h) {
ADDRFP4 0
INDIRP4
CNSTI4 1124
ADDP4
INDIRF4
CNSTF4 0
EQF4 $1260
line 1607
;1607:		h = itm->fontsize.h;
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1124
ADDP4
INDIRF4
CVFI4 4
ASGNI4
line 1608
;1608:	}
line 1609
;1609:	else {
line 1610
;1610:		return;
LABELV $1264
LABELV $1262
line 1613
;1611:	}
;1612:
;1613:	if (itm->propFlags & PROP_VALIGN_TOP)
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $1265
line 1614
;1614:		r->y -= h;
ADDRLP4 4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
SUBF4
ASGNF4
ADDRGP4 $1266
JUMPV
LABELV $1265
line 1615
;1615:	else if (itm->propFlags & PROP_VALIGN_BOTTOM)
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $1267
line 1616
;1616:		r->y += h;
ADDRLP4 8
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDF4
ASGNF4
ADDRGP4 $1268
JUMPV
LABELV $1267
line 1617
;1617:	else if (itm->propFlags & PROP_VALIGN_MIDDLE)
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 2
BANDU4
CNSTU4 0
EQU4 $1269
line 1618
;1618:		r->y -= itm->rect.y +200+ h * 0.5f;
ADDRLP4 12
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1092
ADDP4
INDIRF4
CNSTF4 1128792064
ADDF4
ADDRLP4 0
INDIRI4
CVIF4 4
CNSTF4 1056964608
MULF4
ADDF4
SUBF4
ASGNF4
LABELV $1269
LABELV $1268
LABELV $1266
line 1619
;1619:}
LABELV $1260
endproc HUD_Update_Valign 16 0
export HUD_Update_finalRect
proc HUD_Update_finalRect 0 0
line 1622
;1620:
;1621://GUNNM TODO if caption, use str lenght and charW according to align, valign, and charH
;1622:void HUD_Update_finalRect(item_t *itm, int x, int y, int w, int h) {
line 1623
;1623:	itm->finalRect.x = x;
ADDRFP4 0
INDIRP4
CNSTI4 1104
ADDP4
ADDRFP4 4
INDIRI4
CVIF4 4
ASGNF4
line 1624
;1624:	itm->finalRect.y = y;
ADDRFP4 0
INDIRP4
CNSTI4 1108
ADDP4
ADDRFP4 8
INDIRI4
CVIF4 4
ASGNF4
line 1625
;1625:	itm->finalRect.w = w;
ADDRFP4 0
INDIRP4
CNSTI4 1112
ADDP4
ADDRFP4 12
INDIRI4
CVIF4 4
ASGNF4
line 1626
;1626:	itm->finalRect.h = h;
ADDRFP4 0
INDIRP4
CNSTI4 1116
ADDP4
ADDRFP4 16
INDIRI4
CVIF4 4
ASGNF4
line 1630
;1627:
;1628:	//display all the finalRect, debug use only:
;1629:	//CG_DrawPic(itm->finalRect.x, itm->finalRect.y, itm->finalRect.w, itm->finalRect.h, cgs.media.selectShader);
;1630:}
LABELV $1271
endproc HUD_Update_finalRect 0 0
proc HUD_Alloc 8 4
line 1636
;1631:/*
;1632:===============
;1633:UI_Alloc
;1634:===============
;1635:*/
;1636:static void *HUD_Alloc(int size) {
line 1638
;1637:	char *p;
;1638:	if (allocPoint + size > MEM_POOL_SIZE) {
ADDRGP4 allocPoint
INDIRI4
ADDRFP4 0
INDIRI4
ADDI4
CNSTI4 131072
LEI4 $1273
line 1639
;1639:		outOfMemory = qtrue;
ADDRGP4 outOfMemory
CNSTI4 1
ASGNI4
line 1640
;1640:		Com_Printf("HUD_Alloc: Failure. Out of memory!");
ADDRGP4 $1275
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 1641
;1641:		return NULL;
CNSTP4 0
RETP4
ADDRGP4 $1272
JUMPV
LABELV $1273
line 1643
;1642:	}
;1643:	p = &memoryPool[allocPoint];
ADDRLP4 0
ADDRGP4 allocPoint
INDIRI4
ADDRGP4 memoryPool
ADDP4
ASGNP4
line 1644
;1644:	allocPoint += (size + 15) & ~15;
ADDRLP4 4
ADDRGP4 allocPoint
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI4
ADDRFP4 0
INDIRI4
CNSTI4 15
ADDI4
CNSTI4 -16
BANDI4
ADDI4
ASGNI4
line 1645
;1645:	return p;
ADDRLP4 0
INDIRP4
RETP4
LABELV $1272
endproc HUD_Alloc 8 4
proc UI_InitMemory 0 0
line 1654
;1646:}
;1647:
;1648:
;1649:/*
;1650:===============
;1651:UI_InitMemory
;1652:===============
;1653:*/
;1654:static void UI_InitMemory(void) {
line 1655
;1655:	allocPoint = 0;
ADDRGP4 allocPoint
CNSTI4 0
ASGNI4
line 1656
;1656:	outOfMemory = qfalse;
ADDRGP4 outOfMemory
CNSTI4 0
ASGNI4
line 1657
;1657:}
LABELV $1276
endproc UI_InitMemory 0 0
proc hashForString 16 4
line 1665
;1658:
;1659:
;1660:/*
;1661:================
;1662:return a hash value for the string
;1663:================
;1664:*/
;1665:static unsigned hashForString(const char *str) {
line 1670
;1666:	int			i;
;1667:	unsigned	hash;
;1668:	char		letter;
;1669:
;1670:	hash = 0;
ADDRLP4 8
CNSTU4 0
ASGNU4
line 1671
;1671:	i = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1279
JUMPV
LABELV $1278
line 1672
;1672:	while (str[i] != '\0') {
line 1673
;1673:		letter = tolower(str[i]);
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 12
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
CVII1 4
ASGNI1
line 1674
;1674:		hash += (unsigned)(letter)*(i + 119);
ADDRLP4 8
ADDRLP4 8
INDIRU4
ADDRLP4 4
INDIRI1
CVII4 1
CVIU4 4
ADDRLP4 0
INDIRI4
CNSTI4 119
ADDI4
CVIU4 4
MULU4
ADDU4
ASGNU4
line 1675
;1675:		i++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1676
;1676:	}
LABELV $1279
line 1672
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $1278
line 1677
;1677:	hash &= (HASH_TABLE_SIZE - 1);
ADDRLP4 8
ADDRLP4 8
INDIRU4
CNSTU4 2047
BANDU4
ASGNU4
line 1678
;1678:	return hash;
ADDRLP4 8
INDIRU4
RETU4
LABELV $1277
endproc hashForString 16 4
data
align 4
LABELV strPoolIndex
byte 4 0
align 4
LABELV strHandleCount
byte 4 0
bss
align 1
LABELV $1282
skip 4096
code
proc PC_SourceError 136 16
line 1699
;1679:}
;1680:
;1681:typedef struct stringDef_s {
;1682:	struct stringDef_s *next;
;1683:	const char *str;
;1684:} stringDef_t;
;1685:
;1686:static int strPoolIndex = 0;
;1687:static char strPool[STRING_POOL_SIZE];
;1688:
;1689:static int strHandleCount = 0;
;1690:static stringDef_t *strHandle[HASH_TABLE_SIZE];
;1691:
;1692:
;1693:/*
;1694:=================
;1695:PC_SourceError
;1696:help HUD creation by giving error information
;1697:=================
;1698:*/
;1699:static void PC_SourceError(int handle, char *format, ...) {
line 1705
;1700:	int line;
;1701:	char filename[128];
;1702:	va_list argptr;
;1703:	static char string[4096];
;1704:
;1705:	va_start(argptr, format);
ADDRLP4 132
ADDRFP4 4+4
ASGNP4
line 1706
;1706:	ED_vsprintf(string, format, argptr);
ADDRGP4 $1282
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 132
INDIRP4
ARGP4
ADDRGP4 ED_vsprintf
CALLI4
pop
line 1707
;1707:	va_end(argptr);
ADDRLP4 132
CNSTP4 0
ASGNP4
line 1709
;1708:
;1709:	filename[0] = '\0';
ADDRLP4 4
CNSTI1 0
ASGNI1
line 1710
;1710:	line = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1711
;1711:	trap_PC_SourceFileAndLine(handle, filename, &line);
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 0
ARGP4
ADDRGP4 trap_PC_SourceFileAndLine
CALLI4
pop
line 1713
;1712:
;1713:	Com_Printf(S_COLOR_RED "ERROR: %s, line %d: %s\n", filename, line, string);
ADDRGP4 $1284
ARGP4
ADDRLP4 4
ARGP4
ADDRLP4 0
INDIRI4
ARGI4
ADDRGP4 $1282
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 1714
;1714:}
LABELV $1281
endproc PC_SourceError 136 16
proc keepTokenStr_OnError 0 0
line 1732
;1715:
;1716:
;1717:/*
;1718:=================
;1719:keepTokenOnError
;1720:
;1721:keep last token when parse error occured,
;1722:because token can't been unread
;1723:it will be the next one to be proceed
;1724:=================
;1725:*/
;1726:qboolean needCacheToken;
;1727:qboolean itemEnd;
;1728:qboolean propertyEnd;
;1729:char* cacheTokenStr;
;1730:
;1731:static void keepTokenStr_OnError(pc_token_t token)
;1732:{
line 1733
;1733:	cacheTokenStr = token.string;
ADDRGP4 cacheTokenStr
ADDRFP4 0
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
line 1734
;1734:	needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 1735
;1735:}
LABELV $1285
endproc keepTokenStr_OnError 0 0
proc resetTokenCache 0 0
line 1737
;1736:
;1737:static void resetTokenCache() {
line 1738
;1738:	needCacheToken = qfalse;
ADDRGP4 needCacheToken
CNSTI4 0
ASGNI4
line 1740
;1739:	//*cacheTokenStr = '\0';
;1740:	cacheTokenStr = '\0';
ADDRGP4 cacheTokenStr
CNSTP4 0
ASGNP4
line 1741
;1741:}
LABELV $1286
endproc resetTokenCache 0 0
proc PC_Int_Parse 1052 12
line 1749
;1742:
;1743:
;1744:/*
;1745:=================
;1746:PC_Int_Parse
;1747:=================
;1748:*/
;1749:static qboolean PC_Int_Parse(int handle, int *i) {
line 1751
;1750:	pc_token_t token;
;1751:	int negative = qfalse;
ADDRLP4 1040
CNSTI4 0
ASGNI4
line 1753
;1752:
;1753:	if (!i)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1288
line 1754
;1754:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1287
JUMPV
LABELV $1288
line 1756
;1755:
;1756:	if (!trap_PC_ReadToken(handle, &token))
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1044
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1044
INDIRI4
CNSTI4 0
NEI4 $1290
line 1757
;1757:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1287
JUMPV
LABELV $1290
line 1759
;1758:
;1759:	if (token.string[0] == '-') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $1292
line 1760
;1760:		if (!trap_PC_ReadToken(handle, &token))
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1295
line 1761
;1761:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1287
JUMPV
LABELV $1295
line 1762
;1762:		negative = qtrue;
ADDRLP4 1040
CNSTI4 1
ASGNI4
line 1763
;1763:	}
ADDRGP4 $1293
JUMPV
LABELV $1292
line 1764
;1764:	else if (token.string[0] == '}' || token.string[0] == ';') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
EQI4 $1301
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
NEI4 $1297
LABELV $1301
line 1765
;1765:		itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 1766
;1766:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1287
JUMPV
LABELV $1297
LABELV $1293
line 1769
;1767:	}
;1768:
;1769:	if (token.type != TT_NUMBER) {
ADDRLP4 0
INDIRI4
CNSTI4 3
EQI4 $1302
line 1770
;1770:		if (token.type == TT_NAME) {
ADDRLP4 0
INDIRI4
CNSTI4 4
NEI4 $1304
line 1771
;1771:			propertyEnd = qtrue;
ADDRGP4 propertyEnd
CNSTI4 1
ASGNI4
line 1772
;1772:		}
ADDRGP4 $1305
JUMPV
LABELV $1304
line 1773
;1773:		else if (token.type == TT_STRING) {
ADDRLP4 0
INDIRI4
CNSTI4 1
NEI4 $1306
line 1774
;1774:			needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 1775
;1775:			cacheTokenStr = (char *)token.string;
ADDRGP4 cacheTokenStr
ADDRLP4 0+16
ASGNP4
line 1776
;1776:		}
ADDRGP4 $1307
JUMPV
LABELV $1306
line 1777
;1777:		else {
line 1778
;1778:			PC_SourceError(handle, "expected integer but found %s \n", token.string);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $1309
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 1779
;1779:		}
LABELV $1307
LABELV $1305
line 1781
;1780:
;1781:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1287
JUMPV
LABELV $1302
line 1784
;1782:	}
;1783:
;1784:	*i = token.intvalue;
ADDRFP4 4
INDIRP4
ADDRLP4 0+8
INDIRI4
ASGNI4
line 1785
;1785:	if (negative)
ADDRLP4 1040
INDIRI4
CNSTI4 0
EQI4 $1312
line 1786
;1786:		*i = -*i;
ADDRLP4 1048
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 1048
INDIRP4
ADDRLP4 1048
INDIRP4
INDIRI4
NEGI4
ASGNI4
LABELV $1312
line 1787
;1787:	return qtrue;
CNSTI4 1
RETI4
LABELV $1287
endproc PC_Int_Parse 1052 12
export KeywordHash_Key
proc KeywordHash_Key 20 0
line 1795
;1788:}
;1789:
;1790:/*
;1791:===============
;1792:Keyword Hash
;1793:===============
;1794:*/
;1795:int KeywordHash_Key(char *keyword) {
line 1798
;1796:	int hash, i;
;1797:
;1798:	hash = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1799
;1799:	for (i = 0; keyword[i] != '\0'; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1318
JUMPV
LABELV $1315
line 1800
;1800:		if (keyword[i] >= 'A' && keyword[i] <= 'Z')
ADDRLP4 8
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 65
LTI4 $1319
ADDRLP4 8
INDIRI4
CNSTI4 90
GTI4 $1319
line 1801
;1801:			hash += (keyword[i] + ('a' - 'A')) * (119 + i);
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 32
ADDI4
ADDRLP4 0
INDIRI4
CNSTI4 119
ADDI4
MULI4
ADDI4
ASGNI4
ADDRGP4 $1320
JUMPV
LABELV $1319
line 1803
;1802:		else
;1803:			hash += keyword[i] * (119 + i);
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRLP4 0
INDIRI4
CNSTI4 119
ADDI4
MULI4
ADDI4
ASGNI4
LABELV $1320
line 1804
;1804:	}
LABELV $1316
line 1799
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1318
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $1315
line 1805
;1805:	hash = (hash ^ (hash >> 10) ^ (hash >> 20)) & (KEYWORDHASH_SIZE - 1);
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 4
INDIRI4
CNSTI4 10
RSHI4
BXORI4
ADDRLP4 4
INDIRI4
CNSTI4 20
RSHI4
BXORI4
CNSTI4 511
BANDI4
ASGNI4
line 1806
;1806:	return hash;
ADDRLP4 4
INDIRI4
RETI4
LABELV $1314
endproc KeywordHash_Key 20 0
export cvarTest_KeywordHash_Add
proc cvarTest_KeywordHash_Add 8 4
line 1822
;1807:}
;1808:
;1809:/*
;1810:===============
;1811:cvarTest list hash
;1812:===============
;1813:*/
;1814:typedef struct cvarTest_keywordHash_s
;1815:{
;1816:	char *keyword;
;1817:	vmCvar_t *cvar;
;1818:	int flag;
;1819:	struct cvarTest_keywordHash_s *next;
;1820:} cvarTest_keywordHash_t;
;1821:
;1822:void cvarTest_KeywordHash_Add(cvarTest_keywordHash_t *table[], cvarTest_keywordHash_t *key) {
line 1825
;1823:	int hash;
;1824:
;1825:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 1826
;1826:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 1827
;1827:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 1828
;1828:}
LABELV $1321
endproc cvarTest_KeywordHash_Add 8 4
export cvarTest_KeywordHash_Find
proc cvarTest_KeywordHash_Find 16 8
line 1831
;1829:
;1830:cvarTest_keywordHash_t *cvarTest_KeywordHash_Find(cvarTest_keywordHash_t *table[], char *keyword)
;1831:{
line 1835
;1832:	cvarTest_keywordHash_t *key;
;1833:	int hash;
;1834:
;1835:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1836
;1836:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1326
JUMPV
LABELV $1323
line 1837
;1837:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1327
line 1838
;1838:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1322
JUMPV
LABELV $1327
line 1839
;1839:	}
LABELV $1324
line 1836
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 12
ADDP4
INDIRP4
ASGNP4
LABELV $1326
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1323
line 1840
;1840:	return NULL;
CNSTP4 0
RETP4
LABELV $1322
endproc cvarTest_KeywordHash_Find 16 8
data
export cvarTest_Keywords
align 4
LABELV cvarTest_Keywords
address $1329
address cg_drawWeaponSelect
byte 4 2
byte 4 0
address $1330
address cg_drawAttacker
byte 4 4
byte 4 0
address $1331
address cg_drawTeamOverlay
byte 4 8
byte 4 0
address $1332
address cg_drawCrosshairNames
byte 4 16
byte 4 0
address $1333
address cg_drawIcons
byte 4 32
byte 4 0
address $1334
address cg_draw3dIcons
byte 4 64
byte 4 0
address $1335
address cg_drawFPS
byte 4 128
byte 4 0
address $1336
address cg_drawSpeed
byte 4 256
byte 4 0
address $1337
address cg_drawTimer
byte 4 512
byte 4 0
address $1338
address cg_lagometer
byte 4 1024
byte 4 0
address $1339
address cg_drawPing
byte 4 2048
byte 4 0
address $1340
address cg_drawSnapshot
byte 4 4096
byte 4 0
address $1341
address cg_drawStatus
byte 4 1
byte 4 0
address $1342
address cg_drawRewards
byte 4 8192
byte 4 0
address $1343
address cg_drawAmmoWarning
byte 4 16384
byte 4 0
address $1344
address cg_drawCrosshair
byte 4 32768
byte 4 0
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export cvarTest_SetupKeywordHash
code
proc cvarTest_SetupKeywordHash 4 12
line 1866
;1841:}
;1842:
;1843:cvarTest_keywordHash_t cvarTest_Keywords[] = {
;1844:	{"cg_drawWeaponSelect",		&cg_drawWeaponSelect,	CV_cg_drawWeaponSelect,		NULL},
;1845:	{"cg_drawAttacker",			&cg_drawAttacker,		CV_cg_drawAttacker,			NULL},
;1846:	{"cg_drawTeamOverlay",		&cg_drawTeamOverlay,	CV_cg_drawTeamOverlay,		NULL},
;1847:	{"cg_drawCrosshairNames",	&cg_drawCrosshairNames,	CV_cg_drawCrosshairNames,	NULL},
;1848:	{"cg_drawIcons",			&cg_drawIcons,			CV_cg_drawIcons,			NULL},
;1849:	{"cg_draw3dIcons",			&cg_draw3dIcons,		CV_cg_draw3dIcons,			NULL},
;1850:	{"cg_drawFPS",				&cg_drawFPS,			CV_cg_drawFPS,				NULL},
;1851:	{"cg_drawSpeed",			&cg_drawSpeed,			CV_cg_drawSpeed,			NULL},
;1852:	{"cg_drawTimer",			&cg_drawTimer,			CV_cg_drawTimer,			NULL},
;1853:	{"cg_lagometer",			&cg_lagometer,			CV_cg_lagometer,			NULL},
;1854:	{"cg_drawPing",				&cg_drawPing,			CV_cg_drawPing,				NULL},
;1855:	{"cg_drawSnapshot",			&cg_drawSnapshot,		CV_cg_drawSnapshot,			NULL},
;1856:	{"cg_drawStatus",			&cg_drawStatus,			CV_cg_drawStatus,			NULL},
;1857:	{"cg_drawRewards",			&cg_drawRewards,		CV_cg_drawRewards,			NULL},
;1858:	{"cg_drawAmmoWarning",		&cg_drawAmmoWarning,	CV_cg_drawAmmoWarning,		NULL},
;1859:	{"cg_drawCrosshair",		&cg_drawCrosshair,		CV_cg_drawCrosshair,		NULL},
;1860:	{NULL, 0, 0, NULL}
;1861:};
;1862:
;1863:cvarTest_keywordHash_t *cvarTest_KeywordHash[KEYWORDHASH_SIZE];
;1864:
;1865://fill command_KeywordHash list
;1866:void cvarTest_SetupKeywordHash(void) {
line 1869
;1867:	int i;
;1868:
;1869:	memset(cvarTest_KeywordHash, 0, sizeof(cvarTest_KeywordHash));
ADDRGP4 cvarTest_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 1870
;1870:	for (i = 0; cvarTest_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1349
JUMPV
LABELV $1346
line 1871
;1871:		cvarTest_KeywordHash_Add(cvarTest_KeywordHash, &cvarTest_Keywords[i]);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 cvarTest_Keywords
ADDP4
ARGP4
ADDRGP4 cvarTest_KeywordHash_Add
CALLV
pop
line 1872
;1872:	}
LABELV $1347
line 1870
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1349
ADDRLP4 0
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 cvarTest_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1346
line 1873
;1873:}
LABELV $1345
endproc cvarTest_SetupKeywordHash 4 12
proc PC_Float_Parse 2112 8
line 1881
;1874:
;1875:
;1876:/*
;1877:=================
;1878:PC_Float_Parse
;1879:=================
;1880:*/
;1881:static qboolean PC_Float_Parse(int handle, float *f) {
line 1883
;1882:	pc_token_t token;
;1883:	int negative = qfalse;
ADDRLP4 1040
CNSTI4 0
ASGNI4
line 1885
;1884:
;1885:	if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1044
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1044
INDIRI4
CNSTI4 0
NEI4 $1351
line 1886
;1886:		keepTokenStr_OnError( token );
ADDRLP4 1048
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1048
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1887
;1887:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1350
JUMPV
LABELV $1351
line 1892
;1888:	}
;1889:
;1890:	// fixme: those are lazy fix.
;1891:	// take care of colors T and E when parsing color. 
;1892:	if (token.string[0] == 'T' || token.string[0] == 'E') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 84
EQI4 $1357
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 69
NEI4 $1353
LABELV $1357
line 1893
;1893:		keepTokenStr_OnError(token);
ADDRLP4 1048
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1048
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1894
;1894:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1350
JUMPV
LABELV $1353
line 1896
;1895:	}
;1896:	if ( cacheTokenStr ) {
ADDRGP4 cacheTokenStr
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1358
line 1898
;1897:		// take care of colors arrays when parsing color.
;1898:		if (strcmp("HealthColors", cacheTokenStr) == 0 || strcmp("ArmorColors", cacheTokenStr) == 0 ||
ADDRGP4 $1362
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1048
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
EQI4 $1372
ADDRGP4 $1363
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1052
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 0
EQI4 $1372
ADDRGP4 $1364
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1056
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1056
INDIRI4
CNSTI4 0
EQI4 $1372
ADDRGP4 $1365
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1060
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1060
INDIRI4
CNSTI4 0
EQI4 $1372
ADDRGP4 $1366
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1064
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1064
INDIRI4
CNSTI4 0
EQI4 $1372
ADDRGP4 $1367
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1068
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1068
INDIRI4
CNSTI4 0
NEI4 $1360
LABELV $1372
line 1901
;1899:			strcmp("AmmoColors", cacheTokenStr) == 0 || strcmp("TeamsColors", cacheTokenStr) == 0 ||
;1900:			strcmp("BlueTeamColor", cacheTokenStr) == 0 || strcmp("RedTeamColor", cacheTokenStr) == 0)
;1901:		{
line 1902
;1902:			keepTokenStr_OnError(token);
ADDRLP4 1072
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1072
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1903
;1903:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1350
JUMPV
LABELV $1360
line 1905
;1904:		}
;1905:	}
LABELV $1358
line 1907
;1906:
;1907:	if (token.string[0] == ';') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
NEI4 $1373
line 1908
;1908:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1350
JUMPV
LABELV $1373
line 1910
;1909:	}
;1910:	else if (token.string[0] == '}') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1376
line 1911
;1911:		itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 1912
;1912:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1350
JUMPV
LABELV $1376
line 1915
;1913:	}
;1914:	// std separators
;1915:	else if (token.string[0] == ',') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 44
NEI4 $1379
line 1916
;1916:		if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1382
line 1917
;1917:			keepTokenStr_OnError(token);
ADDRLP4 1052
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1052
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1918
;1918:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1350
JUMPV
LABELV $1382
line 1920
;1919:		}
;1920:	}
LABELV $1379
line 1922
;1921:
;1922:	if (token.string[0] == '-') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $1384
line 1923
;1923:		if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1387
line 1924
;1924:			keepTokenStr_OnError(token);
ADDRLP4 1052
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1052
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1925
;1925:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1350
JUMPV
LABELV $1387
line 1927
;1926:		}
;1927:		negative = qtrue;
ADDRLP4 1040
CNSTI4 1
ASGNI4
line 1928
;1928:	}
LABELV $1384
line 1930
;1929:
;1930:	if ( token.type != TT_NUMBER ) {
ADDRLP4 0
INDIRI4
CNSTI4 3
EQI4 $1389
line 1931
;1931:		keepTokenStr_OnError(token);
ADDRLP4 1048
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1048
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1932
;1932:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1350
JUMPV
LABELV $1389
line 1935
;1933:	}
;1934:
;1935:	if (negative)
ADDRLP4 1040
INDIRI4
CNSTI4 0
EQI4 $1391
line 1936
;1936:		*f = -token.floatvalue;
ADDRFP4 4
INDIRP4
ADDRLP4 0+12
INDIRF4
NEGF4
ASGNF4
ADDRGP4 $1392
JUMPV
LABELV $1391
line 1938
;1937:	else
;1938:		*f = token.floatvalue;
ADDRFP4 4
INDIRP4
ADDRLP4 0+12
INDIRF4
ASGNF4
LABELV $1392
line 1939
;1939:	return qtrue;
CNSTI4 1
RETI4
LABELV $1350
endproc PC_Float_Parse 2112 8
proc PC_Color_Parse 12 8
line 1948
;1940:}
;1941:
;1942:
;1943:/*
;1944:=================
;1945:PC_Color_Parse
;1946:=================
;1947:*/
;1948:static qboolean PC_Color_Parse(int handle, vec4_t *c) {
line 1951
;1949:	int i;
;1950:	float f;
;1951:	for (i = 0; i < 4; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $1396
line 1952
;1952:		if (!PC_Float_Parse(handle, &f)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 8
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1400
line 1953
;1953:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1395
JUMPV
LABELV $1400
line 1955
;1954:		}
;1955:		(*c)[i] = f;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 4
INDIRP4
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1956
;1956:	}
LABELV $1397
line 1951
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 4
LTI4 $1396
line 1957
;1957:	return qtrue;
CNSTI4 1
RETI4
LABELV $1395
endproc PC_Color_Parse 12 8
proc Color_Str_Parse 40 8
line 1967
;1958:}
;1959:
;1960:
;1961:/*
;1962:=================
;1963:parse color if RGBA, or add flag: C_COLOR_TEAMS | C_COLOR_TEAM
;1964:C_COLOR_NME | C_COLOR_HEALTH | C_COLOR_ARMOR | C_COLOR_AMMO
;1965:=================
;1966:*/
;1967:static qboolean Color_Str_Parse(int handle, color_Def_t *col) {
line 1971
;1968:	int i;
;1969:	float f;
;1970:
;1971:	for (i = 0; i < 4; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $1403
line 1972
;1972:		if (!PC_Float_Parse(handle, &f)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 8
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1407
line 1973
;1973:			if (strcmp("TeamsColors", cacheTokenStr) == 0) {
ADDRGP4 $1365
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1409
line 1974
;1974:				col->colorflags |= C_COLORS_TEAMS;
ADDRLP4 16
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 256
BORU4
ASGNU4
line 1975
;1975:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1976
;1976:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1402
JUMPV
LABELV $1409
line 1978
;1977:			}
;1978:			else if (cacheTokenStr[0] == 'T') {
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
CNSTI4 84
NEI4 $1411
line 1979
;1979:				col->colorflags |= C_COLOR_TEAM;
ADDRLP4 16
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 2
BORU4
ASGNU4
line 1980
;1980:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1981
;1981:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1402
JUMPV
LABELV $1411
line 1983
;1982:			}
;1983:			else if (cacheTokenStr[0] == 'E') {
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
CNSTI4 69
NEI4 $1413
line 1984
;1984:				col->colorflags |= C_COLOR_NME;
ADDRLP4 16
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 4
BORU4
ASGNU4
line 1985
;1985:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1986
;1986:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1402
JUMPV
LABELV $1413
line 1988
;1987:			}
;1988:			else if (strcmp("BlueTeamColor", cacheTokenStr) == 0) {
ADDRGP4 $1366
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $1415
line 1989
;1989:				col->colorflags |= C_COLOR_BLUE_TEAM;
ADDRLP4 20
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
CNSTU4 64
BORU4
ASGNU4
line 1990
;1990:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1991
;1991:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1402
JUMPV
LABELV $1415
line 1993
;1992:			}
;1993:			else if (strcmp("RedTeamColor", cacheTokenStr) == 0) {
ADDRGP4 $1367
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $1417
line 1994
;1994:				col->colorflags |= C_COLOR_RED_TEAM;
ADDRLP4 24
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 24
INDIRP4
ADDRLP4 24
INDIRP4
INDIRU4
CNSTU4 128
BORU4
ASGNU4
line 1995
;1995:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1996
;1996:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1402
JUMPV
LABELV $1417
line 1998
;1997:			}
;1998:			else if (strcmp("HealthColors", cacheTokenStr) == 0) {
ADDRGP4 $1362
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 24
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $1419
line 1999
;1999:				col->colorflags |= C_COLORS_HEALTH;
ADDRLP4 28
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRU4
CNSTU4 8
BORU4
ASGNU4
line 2000
;2000:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 2001
;2001:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1402
JUMPV
LABELV $1419
line 2003
;2002:			}
;2003:			else if (strcmp("ArmorColors", cacheTokenStr) == 0) {
ADDRGP4 $1363
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 28
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $1421
line 2004
;2004:				col->colorflags |= C_COLORS_ARMOR;
ADDRLP4 32
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
ADDRLP4 32
INDIRP4
INDIRU4
CNSTU4 16
BORU4
ASGNU4
line 2005
;2005:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 2006
;2006:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1402
JUMPV
LABELV $1421
line 2008
;2007:			}
;2008:			else if (strcmp("AmmoColors", cacheTokenStr) == 0) {
ADDRGP4 $1364
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 32
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $1423
line 2009
;2009:				col->colorflags |= C_COLORS_AMMO;
ADDRLP4 36
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 36
INDIRP4
INDIRU4
CNSTU4 32
BORU4
ASGNU4
line 2010
;2010:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 2011
;2011:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1402
JUMPV
LABELV $1423
line 2013
;2012:			}
;2013:			else {
line 2014
;2014:				Com_Printf("Color parse error: %s\n", cacheTokenStr);
ADDRGP4 $1425
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 2015
;2015:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1402
JUMPV
LABELV $1407
line 2020
;2016:			}
;2017:		}
;2018:
;2019:		// float parse success
;2020:		col->colorflags |= C_COLOR_RGBA;
ADDRLP4 12
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
line 2021
;2021:		col->color[i] = f;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 4
INDIRP4
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 2022
;2022:	}
LABELV $1404
line 1971
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 4
LTI4 $1403
line 2023
;2023:	return qtrue;
CNSTI4 1
RETI4
LABELV $1402
endproc Color_Str_Parse 40 8
proc PC_Rect_Parse 20 8
line 2032
;2024:}
;2025:
;2026:
;2027:/*
;2028:=================
;2029:PC_Rect_Parse
;2030:=================
;2031:*/
;2032:static qboolean PC_Rect_Parse(int handle, rectDef_t *r) {
line 2033
;2033:	int intNb = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 2034
;2034:	if (PC_Float_Parse(handle, &r->x)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1427
line 2035
;2035:		intNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2036
;2036:		if (PC_Float_Parse(handle, &r->y)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1429
line 2037
;2037:			intNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2038
;2038:			if (PC_Float_Parse(handle, &r->w)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ARGP4
ADDRLP4 12
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1431
line 2039
;2039:				intNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2040
;2040:				if (PC_Float_Parse(handle, &r->h)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ARGP4
ADDRLP4 16
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $1433
line 2041
;2041:					intNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2042
;2042:					return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1426
JUMPV
LABELV $1433
line 2044
;2043:				}
;2044:			}
LABELV $1431
line 2045
;2045:		}
LABELV $1429
line 2046
;2046:	}
LABELV $1427
line 2047
;2047:	return (intNb > 0);
ADDRLP4 0
INDIRI4
CNSTI4 0
LEI4 $1436
ADDRLP4 8
CNSTI4 1
ASGNI4
ADDRGP4 $1437
JUMPV
LABELV $1436
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $1437
ADDRLP4 8
INDIRI4
RETI4
LABELV $1426
endproc PC_Rect_Parse 20 8
proc PC_Margin_Parse 20 8
line 2055
;2048:}
;2049:
;2050:/*
;2051:=================
;2052:PC_Margin_Parse
;2053:=================
;2054:*/
;2055:static qboolean PC_Margin_Parse(int handle, margin_t *m) {
line 2056
;2056:	int paramNb = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 2057
;2057:	if (PC_Float_Parse(handle, &m->left)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1439
line 2058
;2058:		paramNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2059
;2059:		if (PC_Float_Parse(handle, &m->right)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1441
line 2060
;2060:			paramNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2061
;2061:			if (PC_Float_Parse(handle, &m->top)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ARGP4
ADDRLP4 12
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1443
line 2062
;2062:				paramNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2063
;2063:				if (PC_Float_Parse(handle, &m->bottom)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ARGP4
ADDRLP4 16
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $1445
line 2064
;2064:					paramNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2065
;2065:					return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1438
JUMPV
LABELV $1445
line 2067
;2066:				}
;2067:			}
LABELV $1443
line 2068
;2068:		}
LABELV $1441
line 2069
;2069:	}
LABELV $1439
line 2070
;2070:	return (paramNb > 0);
ADDRLP4 0
INDIRI4
CNSTI4 0
LEI4 $1448
ADDRLP4 8
CNSTI4 1
ASGNI4
ADDRGP4 $1449
JUMPV
LABELV $1448
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $1449
ADDRLP4 8
INDIRI4
RETI4
LABELV $1438
endproc PC_Margin_Parse 20 8
proc PC_String_Parse 1048 8
line 2079
;2071:}
;2072:
;2073:
;2074:/*
;2075:=================
;2076:PC_String_Parse
;2077:=================
;2078:*/
;2079:static qboolean PC_String_Parse(int handle, const char **out) {
line 2082
;2080:	pc_token_t token;
;2081:
;2082:	if (!trap_PC_ReadToken(handle, &token))
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1040
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1040
INDIRI4
CNSTI4 0
NEI4 $1451
line 2083
;2083:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1450
JUMPV
LABELV $1451
line 2085
;2084:
;2085:	*(out) = String_Alloc(token.string);
ADDRLP4 0+16
ARGP4
ADDRLP4 1044
ADDRGP4 String_Alloc
CALLP4
ASGNP4
ADDRFP4 4
INDIRP4
ADDRLP4 1044
INDIRP4
ASGNP4
line 2086
;2086:	return qtrue;
CNSTI4 1
RETI4
LABELV $1450
endproc PC_String_Parse 1048 8
proc PC_bool_Parse 20 8
line 2095
;2087:}
;2088:
;2089:
;2090:/*
;2091:=================
;2092:PC_bool_Parse
;2093:=================
;2094:*/
;2095:static qboolean PC_bool_Parse(int handle, qboolean defaultValue, qboolean *b) {
line 2097
;2096:	const char *temp;
;2097:	if (PC_String_Parse(handle, &temp)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1455
line 2098
;2098:		if (temp[0] == '}')	{
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1457
line 2099
;2099:			*b = defaultValue;
ADDRFP4 8
INDIRP4
ADDRFP4 4
INDIRI4
ASGNI4
line 2100
;2100:			itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 2101
;2101:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1454
JUMPV
LABELV $1457
line 2104
;2102:		}
;2103:		// e.g. when just the keyword 'visible' alone, it mean visible = qtrue
;2104:		else if (temp[0] == '\0' || temp[0] == ';') {
ADDRLP4 8
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1461
ADDRLP4 8
INDIRI4
CNSTI4 59
NEI4 $1459
LABELV $1461
line 2105
;2105:			*b = defaultValue;
ADDRFP4 8
INDIRP4
ADDRFP4 4
INDIRI4
ASGNI4
line 2106
;2106:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1454
JUMPV
LABELV $1459
line 2108
;2107:		}
;2108:		else if ( strcmp("false", temp) == 0 || temp[0] == '0') {
ADDRGP4 $1464
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1465
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $1462
LABELV $1465
line 2109
;2109:			*b = qfalse;
ADDRFP4 8
INDIRP4
CNSTI4 0
ASGNI4
line 2110
;2110:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1454
JUMPV
LABELV $1462
line 2112
;2111:		}
;2112:		else if ( strcmp("true", temp) == 0 || temp[0] == '1') {
ADDRGP4 $1468
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $1469
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 49
NEI4 $1466
LABELV $1469
line 2113
;2113:			*b = qtrue;
ADDRFP4 8
INDIRP4
CNSTI4 1
ASGNI4
line 2114
;2114:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1454
JUMPV
LABELV $1466
line 2116
;2115:		}
;2116:		else {
line 2117
;2117:			if ( defaultValue )
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $1470
line 2118
;2118:				*b = qtrue;
ADDRFP4 8
INDIRP4
CNSTI4 1
ASGNI4
LABELV $1470
line 2120
;2119:
;2120:			needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2121
;2121:			cacheTokenStr = (char *)temp ;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2122
;2122:		}
line 2123
;2123:	}
LABELV $1455
line 2125
;2124:
;2125:	*b = defaultValue;
ADDRFP4 8
INDIRP4
ADDRFP4 4
INDIRI4
ASGNI4
line 2126
;2126:	return qfalse;
CNSTI4 0
RETI4
LABELV $1454
endproc PC_bool_Parse 20 8
proc prop_name 8 8
line 2135
;2127:}
;2128:
;2129:
;2130:/*
;2131:===============
;2132:properties Keyword Parse functions
;2133:===============
;2134:*/
;2135:static qboolean prop_name(item_t *itm, int handle) {
line 2138
;2136:	const char *s;
;2137:
;2138:	if (!PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1473
line 2139
;2139:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1472
JUMPV
LABELV $1473
line 2141
;2140:	}
;2141:	else {
line 2142
;2142:		strcpy(itm->item_name, s);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 2143
;2143:		return qtrue;
CNSTI4 1
RETI4
LABELV $1472
endproc prop_name 8 8
proc prop_margin 4 8
line 2148
;2144:	}
;2145:}
;2146:
;2147:// margin <float, float, float, float>
;2148:static qboolean prop_margin(item_t *itm, int handle) {
line 2149
;2149:	if (!PC_Margin_Parse(handle, &itm->margin)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1176
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Margin_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1476
line 2150
;2150:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1475
JUMPV
LABELV $1476
line 2152
;2151:	}
;2152:	return qtrue;
CNSTI4 1
RETI4
LABELV $1475
endproc prop_margin 4 8
proc prop_rect 12 8
line 2156
;2153:}
;2154:
;2155:// rect <rectangle>
;2156:static qboolean prop_rect(item_t *itm, int handle) {
line 2157
;2157:	if (!PC_Rect_Parse(handle, &itm->rect)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1088
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Rect_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1479
line 2158
;2158:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1478
JUMPV
LABELV $1479
line 2161
;2159:	}
;2160:
;2161:	if (itm->rect.w < 0)
ADDRFP4 0
INDIRP4
CNSTI4 1096
ADDP4
INDIRF4
CNSTF4 0
GEF4 $1481
line 2162
;2162:		itm->iconFlags |= ICON_INVERT_W;
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRU4
CNSTU4 16
BORU4
ASGNU4
LABELV $1481
line 2163
;2163:	if (itm->rect.h < 0)
ADDRFP4 0
INDIRP4
CNSTI4 1100
ADDP4
INDIRF4
CNSTF4 0
GEF4 $1483
line 2164
;2164:		itm->iconFlags |= ICON_INVERT_H;
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 32
BORU4
ASGNU4
LABELV $1483
line 2166
;2165:
;2166:	return qtrue;
CNSTI4 1
RETI4
LABELV $1478
endproc prop_rect 12 8
proc prop_pulseScale 4 8
line 2170
;2167:}
;2168:
;2169:// pulseScale <float>
;2170:static qboolean prop_pulseScale(item_t *itm, int handle) {
line 2171
;2171:	if (!PC_Float_Parse(handle, &itm->pulseScale)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1040
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1486
line 2172
;2172:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1485
JUMPV
LABELV $1486
line 2174
;2173:	}
;2174:	return qtrue;
CNSTI4 1
RETI4
LABELV $1485
endproc prop_pulseScale 4 8
proc prop_proportional 8 12
line 2179
;2175:}
;2176:
;2177:// CG_DrawString() flag
;2178:// proportional <boolean>
;2179:static qboolean prop_proportional(item_t *itm, int handle) {
line 2181
;2180:	qboolean proportionalTmp;
;2181:	PC_bool_Parse(handle, qtrue, &proportionalTmp);
ADDRFP4 4
INDIRI4
ARGI4
CNSTI4 1
ARGI4
ADDRLP4 0
ARGP4
ADDRGP4 PC_bool_Parse
CALLI4
pop
line 2182
;2182:	if (proportionalTmp) {
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1489
line 2183
;2183:		itm->text.styleflags |= DS_PROPORTIONAL;
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRU4
CNSTU4 4
BORU4
ASGNU4
line 2184
;2184:	}
LABELV $1489
line 2185
;2185:	return qtrue;
CNSTI4 1
RETI4
LABELV $1488
endproc prop_proportional 8 12
proc prop_shadow 8 12
line 2190
;2186:}
;2187:
;2188:// CG_DrawString() flag
;2189:// shadow <boolean>
;2190:static qboolean prop_shadow(item_t *itm, int handle) {
line 2192
;2191:	qboolean shadowTmp;
;2192:	PC_bool_Parse(handle, qtrue, &shadowTmp);
ADDRFP4 4
INDIRI4
ARGI4
CNSTI4 1
ARGI4
ADDRLP4 0
ARGP4
ADDRGP4 PC_bool_Parse
CALLI4
pop
line 2193
;2193:	if (shadowTmp) {
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1492
line 2194
;2194:		itm->text.styleflags |= DS_SHADOW;
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
line 2195
;2195:	}
LABELV $1492
line 2196
;2196:	return qtrue;
CNSTI4 1
RETI4
LABELV $1491
endproc prop_shadow 8 12
proc prop_textalign 16 8
line 2201
;2197:}
;2198:
;2199:// CG_DrawString() flag
;2200:// textAlign <textAlign_t>
;2201:static qboolean prop_textalign(item_t *itm, int handle) {
line 2204
;2202:	const char *s;
;2203:
;2204:	if (PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1495
line 2205
;2205:		if (s[0] == 'R')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 82
NEI4 $1497
line 2206
;2206:			itm->text.styleflags |= DS_RIGHT;
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 16
BORU4
ASGNU4
ADDRGP4 $1498
JUMPV
LABELV $1497
line 2207
;2207:		else if (s[0] == 'C')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 67
NEI4 $1499
line 2208
;2208:			itm->text.styleflags |= DS_CENTER;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 8
BORU4
ASGNU4
ADDRGP4 $1500
JUMPV
LABELV $1499
line 2209
;2209:		else if (s[0] == 'L')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 76
NEI4 $1501
line 2211
;2210:			//return item->text.styleflags |= DS_LEFT; // CG_DrawString() default value is left align
;2211:			return qtrue;	
CNSTI4 1
RETI4
ADDRGP4 $1494
JUMPV
LABELV $1501
LABELV $1500
LABELV $1498
line 2212
;2212:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1494
JUMPV
LABELV $1495
line 2214
;2213:	}
;2214:	return qfalse;
CNSTI4 0
RETI4
LABELV $1494
endproc prop_textalign 16 8
proc prop_background 60 8
line 2218
;2215:}
;2216:
;2217:// image <const char*>
;2218:static qboolean prop_background(item_t *itm, int handle) {
line 2220
;2219:	const char *s;
;2220:	if (!PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1504
line 2221
;2221:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1504
line 2223
;2222:	}
;2223:	if (strcmp("ICON_GAME_TYPE", s) == 0) {
ADDRGP4 $1508
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1506
line 2224
;2224:		itm->iconFlags |= ICON_GAME_TYPE;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
line 2225
;2225:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1506
line 2227
;2226:	}
;2227:	else if (strcmp("ICON_HOLDABLE_ITEM", s) == 0) {
ADDRGP4 $1511
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1509
line 2228
;2228:		itm->iconFlags |= ICON_HOLDABLE_ITEM;
ADDRLP4 16
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 2
BORU4
ASGNU4
line 2229
;2229:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1509
line 2231
;2230:	}
;2231:	else if (strcmp("ICON_BLUE_FLAG", s) == 0) {
ADDRGP4 $1514
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $1512
line 2232
;2232:		itm->iconFlags |= ICON_BLUE_FLAG;
ADDRLP4 20
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
CNSTU4 4
BORU4
ASGNU4
line 2233
;2233:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1512
line 2235
;2234:	}
;2235:	else if (strcmp("ICON_RED_FLAG", s) == 0) {
ADDRGP4 $1517
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $1515
line 2236
;2236:		itm->iconFlags |= ICON_RED_FLAG;
ADDRLP4 24
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 24
INDIRP4
ADDRLP4 24
INDIRP4
INDIRU4
CNSTU4 8
BORU4
ASGNU4
line 2237
;2237:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1515
line 2239
;2238:	}
;2239:	else if (strcmp("ICON_HEAD", s) == 0) {
ADDRGP4 $1520
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 24
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $1518
line 2240
;2240:		itm->iconFlags |= ICON_HEAD;
ADDRLP4 28
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRU4
CNSTU4 64
BORU4
ASGNU4
line 2241
;2241:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1518
line 2243
;2242:	}
;2243:	else if (strcmp("ICON_HEAD_ANIM", s) == 0) {
ADDRGP4 $1523
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 28
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $1521
line 2244
;2244:		itm->iconFlags |= ICON_HEAD_ANIM;
ADDRLP4 32
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
ADDRLP4 32
INDIRP4
INDIRU4
CNSTU4 128
BORU4
ASGNU4
line 2245
;2245:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1521
line 2247
;2246:	}
;2247:	else if (strcmp("ICON_ARMOR", s) == 0) {
ADDRGP4 $1526
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 32
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $1524
line 2248
;2248:		itm->iconFlags |= ICON_ARMOR;
ADDRLP4 36
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 36
INDIRP4
INDIRU4
CNSTU4 512
BORU4
ASGNU4
line 2249
;2249:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1524
line 2251
;2250:	}
;2251:	else if (strcmp("ICON_AMMO", s) == 0) {
ADDRGP4 $1529
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 36
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
NEI4 $1527
line 2252
;2252:		itm->iconFlags |= ICON_AMMO;
ADDRLP4 40
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRU4
CNSTU4 1024
BORU4
ASGNU4
line 2253
;2253:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1527
line 2255
;2254:	}
;2255:	else if (strcmp("ICON_ORDER", s) == 0) {
ADDRGP4 $1532
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 40
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 0
NEI4 $1530
line 2256
;2256:		itm->iconFlags |= ICON_ORDER;
ADDRLP4 44
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 44
INDIRP4
ADDRLP4 44
INDIRP4
INDIRU4
CNSTU4 2048
BORU4
ASGNU4
line 2257
;2257:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1530
line 2259
;2258:	}
;2259:	else if (strcmp("ICON_POWERUP", s) == 0) {
ADDRGP4 $1535
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 44
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
NEI4 $1533
line 2260
;2260:		itm->iconFlags |= ICON_POWERUP;
ADDRLP4 48
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 48
INDIRP4
ADDRLP4 48
INDIRP4
INDIRU4
CNSTU4 4096
BORU4
ASGNU4
line 2261
;2261:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1533
line 2263
;2262:	}
;2263:	else if (strcmp("ICON_ATTACKER", s) == 0) {
ADDRGP4 $1538
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 48
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 0
NEI4 $1536
line 2264
;2264:		itm->iconFlags |= ICON_ATTACKER;
ADDRLP4 52
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 52
INDIRP4
ADDRLP4 52
INDIRP4
INDIRU4
CNSTU4 8192
BORU4
ASGNU4
line 2265
;2265:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1536
line 2269
;2266:	}
;2267:	// This one is the team arena animated background
;2268:	// it uses a special shader
;2269:	else if (strcmp("menuscreen2", s) == 0) {
ADDRGP4 $1541
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 52
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 52
INDIRI4
CNSTI4 0
NEI4 $1539
line 2270
;2270:		itm->shader = cgs.media.menuscreen2;
ADDRFP4 0
INDIRP4
CNSTI4 1192
ADDP4
ADDRGP4 cgs+150560+1008
INDIRI4
ASGNI4
line 2271
;2271:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1503
JUMPV
LABELV $1539
line 2274
;2272:	}
;2273:
;2274:	itm->shader = trap_R_RegisterShaderNoMip(s);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 56
ADDRGP4 trap_R_RegisterShaderNoMip
CALLI4
ASGNI4
ADDRFP4 0
INDIRP4
CNSTI4 1192
ADDP4
ADDRLP4 56
INDIRI4
ASGNI4
line 2275
;2275:	return qtrue;
CNSTI4 1
RETI4
LABELV $1503
endproc prop_background 60 8
proc prop_verticalbar 16 12
line 2280
;2276:}
;2277:
;2278:
;2279:// verticalbar <qboolean>
;2280:static qboolean prop_verticalbar(item_t *itm, int handle) {
line 2282
;2281:	qboolean vertic;
;2282:	qboolean def = qtrue;
ADDRLP4 0
CNSTI4 1
ASGNI4
line 2283
;2283:	if (!PC_bool_Parse(handle, def, &vertic)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 8
ADDRGP4 PC_bool_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1545
line 2285
;2284:		// if keyword 'verticalbar' alone
;2285:		itm->propFlags |= PROP_VERTICALBAR;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 8
BORU4
ASGNU4
line 2286
;2286:		return def;
ADDRLP4 0
INDIRI4
RETI4
ADDRGP4 $1544
JUMPV
LABELV $1545
line 2288
;2287:	}
;2288:	else if (vertic) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1547
line 2289
;2289:		itm->propFlags |= PROP_VERTICALBAR;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 8
BORU4
ASGNU4
line 2290
;2290:	}
LABELV $1547
line 2291
;2291:	return qtrue;
CNSTI4 1
RETI4
LABELV $1544
endproc prop_verticalbar 16 12
proc prop_Size 12 8
line 2295
;2292:}
;2293:
;2294:// fontsize <charSizeDef_t>
;2295:static qboolean prop_Size(item_t *itm, int handle) {
line 2297
;2296:	qboolean onlyWidth;
;2297:	if (PC_Float_Parse(handle, &itm->fontsize.w)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1120
ADDP4
ARGP4
ADDRLP4 4
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1550
line 2298
;2298:		onlyWidth = qtrue;
ADDRLP4 0
CNSTI4 1
ASGNI4
line 2299
;2299:		if (PC_Float_Parse(handle, &itm->fontsize.h)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1124
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1552
line 2300
;2300:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1549
JUMPV
LABELV $1552
line 2302
;2301:		}
;2302:	}
LABELV $1550
line 2304
;2303:	// if only Width is provided, height = width
;2304:	if (onlyWidth && !itm->fontsize.h)
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1554
ADDRFP4 0
INDIRP4
CNSTI4 1124
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1554
line 2305
;2305:		itm->fontsize.h = itm->fontsize.w;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
CNSTI4 1124
ADDP4
ADDRLP4 8
INDIRP4
CNSTI4 1120
ADDP4
INDIRF4
ASGNF4
LABELV $1554
line 2306
;2306:	return onlyWidth;
ADDRLP4 0
INDIRI4
RETI4
LABELV $1549
endproc prop_Size 12 8
proc prop_font 16 8
line 2310
;2307:}
;2308:
;2309:// font <fontType_t>
;2310:static qboolean prop_font(item_t *itm, int handle) {
line 2313
;2311:	const char *temp;
;2312:
;2313:	if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1557
line 2314
;2314:		if (strcmp("numbers", temp) == 0)
ADDRGP4 $1561
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1559
line 2315
;2315:			itm->text.styleflags |= DS_FONT_NUMBER;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 64
BORU4
ASGNU4
LABELV $1559
line 2318
;2316:		//else if (strcmp("other", temp) == 0) // for futur dev
;2317:		//	itm->text.styleflags |= DS_FONT_OTHER;
;2318:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1556
JUMPV
LABELV $1557
line 2320
;2319:	}
;2320:	return qfalse;
CNSTI4 0
RETI4
LABELV $1556
endproc prop_font 16 8
proc prop_param 4 8
line 2324
;2321:}
;2322:
;2323:// param <int>
;2324:static qboolean prop_param(item_t *itm, int handle) {
line 2325
;2325:	if (!PC_Int_Parse(handle, &itm->param)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Int_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1563
line 2326
;2326:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1562
JUMPV
LABELV $1563
line 2328
;2327:	}
;2328:	return qtrue;
CNSTI4 1
RETI4
LABELV $1562
endproc prop_param 4 8
proc CheckAlpha 4 8
line 2338
;2329:}
;2330:
;2331:/*
;2332:=================
;2333:CheckAlpha
;2334:Use a specific alpha when provide after flag:
;2335:C_COLOR_TEAMS | C_COLOR_TEAM | etc..
;2336:=================
;2337:*/
;2338:static qboolean CheckAlpha(int handle, color_Def_t *col, float *alpha) {
line 2339
;2339:	if (needCacheToken)// do we need this test?
ADDRGP4 needCacheToken
INDIRI4
CNSTI4 0
EQI4 $1566
line 2340
;2340:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1565
JUMPV
LABELV $1566
line 2342
;2341:
;2342:	if (col->colorflags & C_COLOR_RGBA)
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $1568
line 2343
;2343:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1565
JUMPV
LABELV $1568
line 2345
;2344:
;2345:	if (!PC_Float_Parse(handle, alpha)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1570
line 2346
;2346:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1565
JUMPV
LABELV $1570
line 2349
;2347:	}
;2348:
;2349:	return qtrue;
CNSTI4 1
RETI4
LABELV $1565
endproc CheckAlpha 4 8
proc prop_forecolor 12 12
line 2354
;2350:}
;2351:
;2352:// TODO factorize next 2 functions
;2353:// forecolor <vec4_t>
;2354:static qboolean prop_forecolor(item_t *itm, int handle) {
line 2355
;2355:	if (!Color_Str_Parse(handle, &itm->forecolor)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1152
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 Color_Str_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1573
line 2356
;2356:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1572
JUMPV
LABELV $1573
line 2359
;2357:	}
;2358:
;2359:	if (CheckAlpha(handle, &itm->forecolor, &itm->forecolor.alpha)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
CNSTI4 1152
ADDP4
ARGP4
ADDRLP4 4
INDIRP4
CNSTI4 1172
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 CheckAlpha
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1575
line 2361
;2360:		//itm->forecolor.colorflags |= C_COLOR_FORCE_ALPHA;
;2361:	}
LABELV $1575
line 2362
;2362:	return qtrue;
CNSTI4 1
RETI4
LABELV $1572
endproc prop_forecolor 12 12
proc prop_backcolor 12 12
line 2366
;2363:}
;2364:
;2365:// backcolor <vec4_t>
;2366:static qboolean prop_backcolor(item_t *itm, int handle) {
line 2367
;2367:	if (!Color_Str_Parse(handle, &itm->backcolor)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1128
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 Color_Str_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1578
line 2368
;2368:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1577
JUMPV
LABELV $1578
line 2371
;2369:	}
;2370:	
;2371:	if (CheckAlpha(handle, &itm->backcolor, &itm->backcolor.alpha)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
CNSTI4 1128
ADDP4
ARGP4
ADDRLP4 4
INDIRP4
CNSTI4 1148
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 CheckAlpha
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1580
line 2373
;2372:		//itm->backcolor.colorflags |= C_COLOR_FORCE_ALPHA;
;2373:	}
LABELV $1580
line 2374
;2374:	return qtrue;
CNSTI4 1
RETI4
LABELV $1577
endproc prop_backcolor 12 12
proc addAnchorFlags 40 0
ADDRFP4 4
ADDRFP4 4
INDIRI4
CVII1 4
ASGNI1
line 2378
;2375:}
;2376:
;2377:
;2378:static qboolean addAnchorFlags(item_t *itm, const char firstChar) {
line 2379
;2379:	switch (firstChar) {
ADDRLP4 0
ADDRFP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 76
EQI4 $1586
ADDRLP4 0
INDIRI4
CNSTI4 77
EQI4 $1590
ADDRLP4 0
INDIRI4
CNSTI4 77
GTI4 $1593
LABELV $1592
ADDRLP4 0
INDIRI4
CNSTI4 66
EQI4 $1591
ADDRLP4 0
INDIRI4
CNSTI4 67
EQI4 $1587
ADDRGP4 $1583
JUMPV
LABELV $1593
ADDRLP4 0
INDIRI4
CNSTI4 82
EQI4 $1588
ADDRLP4 0
INDIRI4
CNSTI4 84
EQI4 $1589
ADDRGP4 $1583
JUMPV
LABELV $1586
line 2381
;2380:	case 'L':
;2381:		itm->propFlags |= PROP_ANCHOR_LEFT;
ADDRLP4 16
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 16
BORU4
ASGNU4
line 2382
;2382:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1582
JUMPV
LABELV $1587
line 2384
;2383:	case 'C':
;2384:		itm->propFlags |= PROP_ANCHOR_CENTER;
ADDRLP4 20
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
CNSTU4 32
BORU4
ASGNU4
line 2385
;2385:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1582
JUMPV
LABELV $1588
line 2387
;2386:	case 'R':
;2387:		itm->propFlags |= PROP_ANCHOR_RIGHT;
ADDRLP4 24
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 24
INDIRP4
ADDRLP4 24
INDIRP4
INDIRU4
CNSTU4 64
BORU4
ASGNU4
line 2388
;2388:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1582
JUMPV
LABELV $1589
line 2390
;2389:	case 'T':
;2390:		itm->propFlags |= PROP_ANCHOR_TOP;
ADDRLP4 28
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRU4
CNSTU4 128
BORU4
ASGNU4
line 2391
;2391:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1582
JUMPV
LABELV $1590
line 2393
;2392:	case 'M':
;2393:		itm->propFlags |= PROP_ANCHOR_MIDDLE;
ADDRLP4 32
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
ADDRLP4 32
INDIRP4
INDIRU4
CNSTU4 256
BORU4
ASGNU4
line 2394
;2394:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1582
JUMPV
LABELV $1591
line 2396
;2395:	case 'B':
;2396:		itm->propFlags |= PROP_ANCHOR_BOTTOM;
ADDRLP4 36
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 36
INDIRP4
INDIRU4
CNSTU4 512
BORU4
ASGNU4
line 2397
;2397:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1582
JUMPV
LABELV $1583
line 2399
;2398:	default:
;2399:		return qfalse;
CNSTI4 0
RETI4
LABELV $1582
endproc addAnchorFlags 40 0
proc prop_anchors 16 8
line 2404
;2400:	}
;2401:}
;2402:
;2403:// anchors <L|C|R> and <T|M|B> or <Left|Center|Right> and <Top|Middle|Bottom>
;2404:static qboolean prop_anchors(item_t *itm, int handle) {
line 2407
;2405:	const char *temp;
;2406:	// one or two flags possible. eg: "anchor Top Right"
;2407:	if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1595
line 2408
;2408:		addAnchorFlags(itm, temp[0]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRGP4 addAnchorFlags
CALLI4
pop
line 2410
;2409:		// check if two anchors were defined
;2410:		if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 8
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1597
line 2411
;2411:			if (temp[0] == '}') {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1599
line 2412
;2412:				itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 2413
;2413:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1594
JUMPV
LABELV $1599
line 2416
;2414:			}
;2415:
;2416:			if (!addAnchorFlags(itm, temp[0])) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 12
ADDRGP4 addAnchorFlags
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1598
line 2417
;2417:				needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2418
;2418:				cacheTokenStr = (char *)temp;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2420
;2419:				// one anchor flag is enough
;2420:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1594
JUMPV
line 2422
;2421:			}
;2422:		}
LABELV $1597
line 2423
;2423:		else {
line 2424
;2424:			needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2425
;2425:			cacheTokenStr = (char *)temp;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2426
;2426:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1594
JUMPV
LABELV $1598
line 2429
;2427:		}
;2428:
;2429:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1594
JUMPV
LABELV $1595
line 2431
;2430:	}
;2431:	return qfalse;
CNSTI4 0
RETI4
LABELV $1594
endproc prop_anchors 16 8
proc prop_fill 16 12
line 2435
;2432:}
;2433:
;2434:// fill <qboolean>
;2435:static qboolean prop_fill(item_t *itm, int handle) {
line 2437
;2436:	qboolean res;
;2437:	qboolean defaultValue = qtrue;
ADDRLP4 0
CNSTI4 1
ASGNI4
line 2438
;2438:	if (!PC_bool_Parse(handle, defaultValue, &res)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 8
ADDRGP4 PC_bool_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1604
line 2439
;2439:		if (defaultValue)
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1606
line 2440
;2440:			itm->propFlags |= PROP_FILL;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 4096
BORU4
ASGNU4
LABELV $1606
line 2441
;2441:		return defaultValue;
ADDRLP4 0
INDIRI4
RETI4
ADDRGP4 $1603
JUMPV
LABELV $1604
line 2443
;2442:	}
;2443:	if (res) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1608
line 2444
;2444:		itm->propFlags |= PROP_FILL;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 4096
BORU4
ASGNU4
line 2445
;2445:	}
LABELV $1608
line 2447
;2446:
;2447:	return qtrue;
CNSTI4 1
RETI4
LABELV $1603
endproc prop_fill 16 12
proc bool_ParseStr 12 8
line 2450
;2448:}
;2449:
;2450:static qboolean bool_ParseStr(const char *str, qboolean defaultValue, qboolean *b) {
line 2451
;2451:	if (str[0] == '}') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1611
line 2452
;2452:		*b = defaultValue;
ADDRFP4 8
INDIRP4
ADDRFP4 4
INDIRI4
ASGNI4
line 2453
;2453:		itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 2454
;2454:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1610
JUMPV
LABELV $1611
line 2457
;2455:	}
;2456:	// e.g. when just the keyword 'visible' alone, it mean visible = qtrue
;2457:	else if (str[0] == '\0' || str[0] == ';') {
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1615
ADDRLP4 0
INDIRI4
CNSTI4 59
NEI4 $1613
LABELV $1615
line 2458
;2458:		*b = defaultValue;
ADDRFP4 8
INDIRP4
ADDRFP4 4
INDIRI4
ASGNI4
line 2459
;2459:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1610
JUMPV
LABELV $1613
line 2461
;2460:	}
;2461:	else if (strcmp("false", str) == 0 || str[0] == '0') {
ADDRGP4 $1464
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1618
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $1616
LABELV $1618
line 2462
;2462:		*b = qfalse;
ADDRFP4 8
INDIRP4
CNSTI4 0
ASGNI4
line 2463
;2463:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1610
JUMPV
LABELV $1616
line 2465
;2464:	}
;2465:	else if (strcmp("true", str) == 0 || str[0] == '1') {
ADDRGP4 $1468
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1621
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 49
NEI4 $1619
LABELV $1621
line 2466
;2466:		*b = qtrue;
ADDRFP4 8
INDIRP4
CNSTI4 1
ASGNI4
line 2467
;2467:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1610
JUMPV
LABELV $1619
line 2469
;2468:	}
;2469:	else {
line 2470
;2470:		if (defaultValue)
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $1622
line 2471
;2471:			*b = qtrue;
ADDRFP4 8
INDIRP4
CNSTI4 1
ASGNI4
LABELV $1622
line 2472
;2472:	}
line 2474
;2473:
;2474:	return qfalse;
CNSTI4 0
RETI4
LABELV $1610
endproc bool_ParseStr 12 8
proc prop_icon3D 16 12
line 2478
;2475:}
;2476:
;2477:// icon3D <qboolean>
;2478:static qboolean prop_icon3D(item_t *itm, int handle) {
line 2480
;2479:	qboolean res;
;2480:	qboolean defaultValue = qtrue;
ADDRLP4 0
CNSTI4 1
ASGNI4
line 2481
;2481:	if (!PC_bool_Parse(handle, defaultValue, &res)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 8
ADDRGP4 PC_bool_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1625
line 2482
;2482:		if (defaultValue)
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1627
line 2483
;2483:			itm->iconFlags |= ICON_3D;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 256
BORU4
ASGNU4
LABELV $1627
line 2484
;2484:		return defaultValue;
ADDRLP4 0
INDIRI4
RETI4
ADDRGP4 $1624
JUMPV
LABELV $1625
line 2486
;2485:	}
;2486:	if (res) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1629
line 2487
;2487:		itm->iconFlags |= ICON_3D;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 256
BORU4
ASGNU4
line 2488
;2488:	}
LABELV $1629
line 2489
;2489:	return qtrue;
CNSTI4 1
RETI4
LABELV $1624
endproc prop_icon3D 16 12
proc prop_BlinkWhenLow 4 0
line 2491
;2490:}
;2491:static qboolean prop_BlinkWhenLow(item_t *itm, int handle) {
line 2498
;2492:	/*qboolean res;
;2493:	qboolean defaultValue = qtrue;
;2494:	if (!PC_bool_Parse(handle, defaultValue, &res)) {
;2495:		return defaultValue;
;2496:	}
;2497:	if (res) {*/
;2498:		itm->propFlags |= PROP_BLINK_WHEN_LOW;
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRU4
CNSTU4 8192
BORU4
ASGNU4
line 2500
;2499:	//}
;2500:	return qtrue;
CNSTI4 1
RETI4
LABELV $1631
endproc prop_BlinkWhenLow 4 0
proc prop_time 4 8
line 2504
;2501:}
;2502:
;2503:// time <int>
;2504:static qboolean prop_time(item_t *itm, int handle) {
line 2505
;2505:	if (!PC_Int_Parse(handle, &itm->time)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1032
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Int_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1633
line 2506
;2506:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1632
JUMPV
LABELV $1633
line 2508
;2507:	}
;2508:	return qtrue;
CNSTI4 1
RETI4
LABELV $1632
endproc prop_time 4 8
proc prop_TeamPlayer 8 8
line 2511
;2509:}
;2510:
;2511:static qboolean prop_TeamPlayer(item_t *itm, int handle) {
line 2512
;2512:	if (!PC_Int_Parse(handle, &itm->team_player)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Int_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1636
line 2513
;2513:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1635
JUMPV
LABELV $1636
line 2515
;2514:	}
;2515:	itm->propFlags |= PROP_TEAM_PLAYER;
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRU4
CNSTU4 16384
BORU4
ASGNU4
line 2516
;2516:	return qtrue;
CNSTI4 1
RETI4
LABELV $1635
endproc prop_TeamPlayer 8 8
data
export vis_Keywords
align 4
LABELV vis_Keywords
address $1638
byte 4 2
byte 4 0
address $1639
byte 4 1
byte 4 0
address $1640
byte 4 4
byte 4 0
address $1641
byte 4 16
byte 4 0
address $1642
byte 4 8
byte 4 0
address $1643
byte 4 32
byte 4 0
address $1644
byte 4 64
byte 4 0
address $1645
byte 4 128
byte 4 0
address $1646
byte 4 256
byte 4 0
address $1647
byte 4 512
byte 4 0
address $1648
byte 4 1024
byte 4 0
address $1649
byte 4 2048
byte 4 0
address $1650
byte 4 4096
byte 4 0
address $1651
byte 4 8192
byte 4 0
address $1652
byte 4 16384
byte 4 0
address $1653
byte 4 32768
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export flag_KeywordHash_Add
code
proc flag_KeywordHash_Add 8 4
line 2553
;2517:}
;2518:/*
;2519:===============
;2520:value list hash
;2521:===============
;2522:*/
;2523:typedef struct flag_keywordHash_s
;2524:{
;2525:	char *keyword;
;2526:	int flag;
;2527:	struct flag_keywordHash_s *next;
;2528:} flag_keywordHash_t;
;2529:
;2530:flag_keywordHash_t vis_Keywords[] = {
;2531:	//HUD keyword				Visibility flags		NULL
;2532:	{"VIS_IN_SCORE",			VIS_IN_SCORE,			NULL},
;2533:	{"VIS_NEVER",				VIS_NEVER,				NULL},
;2534:	{"VIS_IN_MENU",				VIS_IN_MENU,			NULL},
;2535:	{"VIS_LOCAL_SERVER",		VIS_LOCAL_SERVER,		NULL},
;2536:	{"VIS_PMF_FOLLOW",			VIS_PMF_FOLLOW,			NULL},
;2537:	{"VIS_LOW_AMMO_WARNING",	VIS_LOW_AMMO_WARNING,	NULL},
;2538:	{"VIS_OUT_OF_AMMO",			VIS_OUT_OF_AMMO,		NULL},
;2539:	{"VIS_WARMUP",				VIS_WARMUP,				NULL},
;2540:	{"VIS_ZERO_VALUE",			VIS_ZERO_VALUE,			NULL},
;2541:	{"VIS_DISCONNECTED",		VIS_DISCONNECTED,		NULL},
;2542:	{"VIS_BLINK",				VIS_BLINK,				NULL},
;2543:	{"VIS_BLUE_FLAG_TAKEN",		VIS_BLUE_FLAG_TAKEN,	NULL},
;2544:	{"VIS_RED_FLAG_TAKEN",		VIS_RED_FLAG_TAKEN,		NULL},
;2545:	{"VIS_POWERUP_1",			VIS_POWERUP_1,			NULL},
;2546:	{"VIS_PICKUP_ITEM",			VIS_PICKUP_ITEM,		NULL},//fixme: does not worked, item always visible
;2547:	{"VIS_FIRING",				VIS_FIRING,				NULL},
;2548:	{NULL, 0, NULL}
;2549:};
;2550:
;2551:flag_keywordHash_t *flag_KeywordHash[KEYWORDHASH_SIZE];
;2552:
;2553:void flag_KeywordHash_Add(flag_keywordHash_t *table[], flag_keywordHash_t *key) {
line 2556
;2554:	int hash;
;2555:
;2556:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 2557
;2557:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2558
;2558:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 2559
;2559:}
LABELV $1654
endproc flag_KeywordHash_Add 8 4
export flag_KeywordHash_Find
proc flag_KeywordHash_Find 16 8
line 2562
;2560:
;2561:flag_keywordHash_t *flag_KeywordHash_Find(flag_keywordHash_t *table[], char *keyword)
;2562:{
line 2566
;2563:	flag_keywordHash_t *key;
;2564:	int hash;
;2565:
;2566:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2567
;2567:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1659
JUMPV
LABELV $1656
line 2568
;2568:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1660
line 2569
;2569:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1655
JUMPV
LABELV $1660
line 2570
;2570:	}
LABELV $1657
line 2567
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1659
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1656
line 2571
;2571:	return NULL;
CNSTP4 0
RETP4
LABELV $1655
endproc flag_KeywordHash_Find 16 8
export flag_SetupKeywordHash
proc flag_SetupKeywordHash 4 12
line 2574
;2572:}
;2573:
;2574:void flag_SetupKeywordHash(void) {
line 2577
;2575:	int i;
;2576:
;2577:	memset(flag_KeywordHash, 0, sizeof(flag_KeywordHash));
ADDRGP4 flag_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 2578
;2578:	for (i = 0; vis_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1666
JUMPV
LABELV $1663
line 2579
;2579:		flag_KeywordHash_Add(flag_KeywordHash, &vis_Keywords[i]);
ADDRGP4 flag_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 vis_Keywords
ADDP4
ARGP4
ADDRGP4 flag_KeywordHash_Add
CALLV
pop
line 2580
;2580:	}
LABELV $1664
line 2578
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1666
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 vis_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1663
line 2581
;2581:}
LABELV $1662
endproc flag_SetupKeywordHash 4 12
export value_KeywordHash_Add
proc value_KeywordHash_Add 8 4
line 2588
;2582:
;2583:/*
;2584:===============
;2585:value visible flags list hash
;2586:===============
;2587:*/
;2588:void value_KeywordHash_Add(flag_keywordHash_t *table[], flag_keywordHash_t *key) {
line 2591
;2589:	int hash;
;2590:
;2591:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 2592
;2592:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2593
;2593:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 2594
;2594:}
LABELV $1667
endproc value_KeywordHash_Add 8 4
export value_KeywordHash_Find
proc value_KeywordHash_Find 16 8
line 2597
;2595:
;2596:flag_keywordHash_t *value_KeywordHash_Find(flag_keywordHash_t *table[], char *keyword)
;2597:{
line 2601
;2598:	flag_keywordHash_t *key;
;2599:	int hash;
;2600:
;2601:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2602
;2602:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1672
JUMPV
LABELV $1669
line 2603
;2603:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1673
line 2604
;2604:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1668
JUMPV
LABELV $1673
line 2605
;2605:	}
LABELV $1670
line 2602
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1672
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1669
line 2606
;2606:	return NULL;
CNSTP4 0
RETP4
LABELV $1668
endproc value_KeywordHash_Find 16 8
data
export value_Keywords
align 4
LABELV value_Keywords
address $1675
byte 4 8
byte 4 0
address $1676
byte 4 16
byte 4 0
address $1677
byte 4 4
byte 4 0
address $1678
byte 4 32
byte 4 0
address $1679
byte 4 1024
byte 4 0
address $1680
byte 4 256
byte 4 0
address $1681
byte 4 64
byte 4 0
address $1682
byte 4 128
byte 4 0
address $1683
byte 4 512
byte 4 0
address $1684
byte 4 32768
byte 4 0
address $1685
byte 4 65536
byte 4 0
address $1686
byte 4 2048
byte 4 0
address $1687
byte 4 4096
byte 4 0
address $1688
byte 4 8192
byte 4 0
address $1689
byte 4 16384
byte 4 0
address $1690
byte 4 131072
byte 4 0
address $1691
byte 4 2
byte 4 0
address $1692
byte 4 262144
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export value_SetupKeywordHash
code
proc value_SetupKeywordHash 4 12
line 2636
;2607:}
;2608:
;2609:flag_keywordHash_t value_Keywords[] = {
;2610:	// caption and gradient flags:
;2611:	{ "VAL_HEALTH",			VAL_HEALTH,			NULL },
;2612:	{ "VAL_ARMOR",			VAL_ARMOR,			NULL },
;2613:	{ "VAL_AMMO",			VAL_AMMO,			NULL },
;2614:	{ "VAL_WEAPON",			VAL_WEAPON,			NULL },
;2615:	{ "VAL_SCORE",			VAL_SCORE,			NULL },
;2616:	{ "VAL_TIMER",			VAL_TIMER,			NULL },
;2617:	{ "VAL_HOLDABLE_ITEM",	VAL_HOLDABLE_ITEM,	NULL },
;2618:	{ "VAL_FPS",			VAL_FPS,			NULL },
;2619:	{ "VAL_SPEED",			VAL_SPEED,			NULL },
;2620:	{ "VAL_FOLLOW_NAME",	VAL_FOLLOW_NAME,	NULL },
;2621:	{ "VAL_SNAPSHOT",		VAL_SNAPSHOT,		NULL },
;2622:	{ "VAL_CAPFRAG_LIMIT",	VAL_CAPFRAG_LIMIT,	NULL },
;2623:	{ "VAL_FRAG_LIMIT",		VAL_FRAG_LIMIT,		NULL },
;2624:	{ "VAL_CAPTURE_LIMIT",	VAL_CAPTURE_LIMIT,	NULL },
;2625:	{ "VAL_TIME_LIMIT",		VAL_TIME_LIMIT,		NULL },
;2626:	{ "VAL_LOCATION",		VAL_LOCATION,		NULL },
;2627:	{ "VAL_NAME",			VAL_NAME,			NULL },
;2628:	{ "VAL_PLAYERS_NB_TEAM",VAL_PLAYERS_NB_TEAM,NULL },
;2629:
;2630:	{ NULL, 0, NULL }
;2631:};
;2632:
;2633:flag_keywordHash_t *value_KeywordHash[KEYWORDHASH_SIZE];
;2634:
;2635://fill value_KeywordHash list
;2636:void value_SetupKeywordHash(void) {
line 2639
;2637:	int i;
;2638:
;2639:	memset(value_KeywordHash, 0, sizeof(value_KeywordHash));
ADDRGP4 value_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 2640
;2640:	for (i = 0; value_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1697
JUMPV
LABELV $1694
line 2641
;2641:		value_KeywordHash_Add(value_KeywordHash, &value_Keywords[i]);
ADDRGP4 value_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 value_Keywords
ADDP4
ARGP4
ADDRGP4 value_KeywordHash_Add
CALLV
pop
line 2642
;2642:	}
LABELV $1695
line 2640
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1697
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 value_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1694
line 2643
;2643:}
LABELV $1693
endproc value_SetupKeywordHash 4 12
export GT_Vis_KeywordHash_Add
proc GT_Vis_KeywordHash_Add 8 4
line 2650
;2644:
;2645:/*
;2646:===============
;2647:GT_visible flags list hash
;2648:===============
;2649:*/
;2650:void GT_Vis_KeywordHash_Add(flag_keywordHash_t *table[], flag_keywordHash_t *key) {
line 2653
;2651:	int hash;
;2652:
;2653:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 2654
;2654:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2655
;2655:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 2656
;2656:}
LABELV $1698
endproc GT_Vis_KeywordHash_Add 8 4
export GT_Vis_KeywordHash_Find
proc GT_Vis_KeywordHash_Find 16 8
line 2659
;2657:
;2658:flag_keywordHash_t *GT_Vis_KeywordHash_Find(flag_keywordHash_t *table[], char *keyword)
;2659:{
line 2663
;2660:	flag_keywordHash_t *key;
;2661:	int hash;
;2662:
;2663:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2664
;2664:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1703
JUMPV
LABELV $1700
line 2665
;2665:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1704
line 2666
;2666:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1699
JUMPV
LABELV $1704
line 2667
;2667:	}
LABELV $1701
line 2664
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1703
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1700
line 2668
;2668:	return NULL;
CNSTP4 0
RETP4
LABELV $1699
endproc GT_Vis_KeywordHash_Find 16 8
data
export GT_Vis_Keywords
align 4
LABELV GT_Vis_Keywords
address $1706
byte 4 1
byte 4 0
address $1707
byte 4 2
byte 4 0
address $1708
byte 4 4
byte 4 0
address $1709
byte 4 8
byte 4 0
address $1710
byte 4 16
byte 4 0
address $1711
byte 4 32
byte 4 0
address $1712
byte 4 512
byte 4 0
address $1713
byte 4 1024
byte 4 0
address $1714
byte 4 4096
byte 4 0
address $1715
byte 4 2048
byte 4 0
address $1716
byte 4 4096
byte 4 0
address $1717
byte 4 8192
byte 4 0
address $1718
byte 4 16384
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export GT_Vis_SetupKeywordHash
code
proc GT_Vis_SetupKeywordHash 4 12
line 2696
;2669:}
;2670:
;2671:flag_keywordHash_t GT_Vis_Keywords[] = {
;2672:	{"VIS_TEAM_PLAY",			VIS_TEAM_PLAY,			NULL},
;2673:	{"VIS_GT_TOURNAMENT",		VIS_GT_TOURNAMENT,		NULL},
;2674:	{"VIS_GT_FFA",				VIS_GT_FFA,				NULL},
;2675:	{"VIS_GT_TDM",				VIS_GT_TDM,				NULL},
;2676:	{"VIS_GT_CTF",				VIS_GT_CTF,				NULL},
;2677:#ifdef MISSIONPACK
;2678:	{"VIS_GT_1FCTF",			VIS_ONLY_GT_1FCTF,		NULL},
;2679:	{"VIS_GT_OBELISK",			VIS_ONLY_GT_OBELISK,	NULL},
;2680:	"VIS_GT_HARVESTER",			VIS_ONLY_GT_HARVESTER,	NULL },
;2681:#endif
;2682:	{ "VIS_GT_FREEZE",			VIS_GT_FREEZE,			NULL },
;2683:	{ "VIS_TEAM_BLUE",			VIS_TEAM_BLUE,			NULL },
;2684:	{ "VIS_TEAM_RED",			VIS_TEAM_RED,			NULL },
;2685:	{ "VIS_TEAM_SPEC",			VIS_TEAM_SPECTATOR,		NULL },
;2686:	{ "VIS_TEAM_BLUE_OR_RED",	VIS_TEAM_BLUE_OR_RED,	NULL },
;2687:	{ "VIS_TEAM_SPECTATOR",		VIS_TEAM_SPECTATOR,		NULL },
;2688:	{ "VIS_SHOW_TEAMINFO",		VIS_SHOW_TEAMINFO,		NULL },
;2689:	{ "VIS_TEAM_PLAYER",		VIS_TEAM_PLAYER,		NULL },
;2690:{ NULL, 0, NULL }
;2691:};
;2692:
;2693:flag_keywordHash_t *GT_Vis_KeywordHash[KEYWORDHASH_SIZE];
;2694:
;2695://fill GT_Vis_KeywordHash list
;2696:void GT_Vis_SetupKeywordHash(void) {
line 2699
;2697:	int i;
;2698:
;2699:	memset(GT_Vis_KeywordHash, 0, sizeof(GT_Vis_KeywordHash));
ADDRGP4 GT_Vis_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 2700
;2700:	for (i = 0; GT_Vis_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1723
JUMPV
LABELV $1720
line 2701
;2701:		GT_Vis_KeywordHash_Add(GT_Vis_KeywordHash, &GT_Vis_Keywords[i]);
ADDRGP4 GT_Vis_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 GT_Vis_Keywords
ADDP4
ARGP4
ADDRGP4 GT_Vis_KeywordHash_Add
CALLV
pop
line 2702
;2702:	}
LABELV $1721
line 2700
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1723
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 GT_Vis_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1720
line 2703
;2703:}
LABELV $1719
endproc GT_Vis_SetupKeywordHash 4 12
proc addVisibilityFlags 1088 8
line 2711
;2704:
;2705:
;2706:/*
;2707:===============
;2708:addVisibilityFlags
;2709:===============
;2710:*/
;2711:static qboolean addVisibilityFlags(item_t *itm, int handle, const char *temp) {
line 2713
;2712:	// if keyword 'visible' alone, visible = qtrue
;2713:	if (temp[0] == '\0' || temp[0] == ';') {
ADDRLP4 0
ADDRFP4 8
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1727
ADDRLP4 0
INDIRI4
CNSTI4 59
NEI4 $1725
LABELV $1727
line 2714
;2714:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1724
JUMPV
LABELV $1725
line 2716
;2715:	}
;2716:	else if (temp[0] == '0' || strcmp("false", temp) == 0) {
ADDRLP4 4
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
EQI4 $1730
ADDRGP4 $1464
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1728
LABELV $1730
line 2717
;2717:		itm->visible_prop_flags[0] |= VIS_NEVER;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1060
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
line 2718
;2718:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1724
JUMPV
LABELV $1728
line 2720
;2719:	}
;2720:	else if (temp[0] == '1' || strcmp("true", temp) == 0) {
ADDRLP4 12
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
CNSTI4 49
EQI4 $1733
ADDRGP4 $1468
ARGP4
ADDRLP4 12
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $1731
LABELV $1733
line 2721
;2721:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1724
JUMPV
LABELV $1731
line 2723
;2722:	}
;2723:	else {
line 2726
;2724:		pc_token_t token;
;2725:		flag_keywordHash_t *key;
;2726:		int invertFlag = qfalse;
ADDRLP4 20
CNSTI4 0
ASGNI4
line 2729
;2727:
;2728:		// If '!' change visibility to invisibility
;2729:		if (temp[0] == '!') {
ADDRFP4 8
INDIRP4
INDIRI1
CVII4 1
CNSTI4 33
NEI4 $1734
line 2730
;2730:			if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 28
ARGP4
ADDRLP4 1068
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1068
INDIRI4
CNSTI4 0
NEI4 $1736
line 2731
;2731:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1724
JUMPV
LABELV $1736
line 2733
;2732:			}
;2733:			temp = token.string;
ADDRFP4 8
ADDRLP4 28+16
ASGNP4
line 2734
;2734:			invertFlag = qtrue;
ADDRLP4 20
CNSTI4 1
ASGNI4
line 2735
;2735:		}
LABELV $1734
line 2738
;2736:
;2737:		// add flag for keywords: VIS_NEVER | VIS_IN_MENU | etc.
;2738:		key = flag_KeywordHash_Find(flag_KeywordHash, (char *)temp);
ADDRGP4 flag_KeywordHash
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 1068
ADDRGP4 flag_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 24
ADDRLP4 1068
INDIRP4
ASGNP4
line 2739
;2739:		if (key) {
ADDRLP4 24
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1739
line 2740
;2740:			if (invertFlag)
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $1741
line 2741
;2741:				itm->visible_prop_flags[1] |= key->flag;
ADDRLP4 1072
ADDRFP4 0
INDIRP4
CNSTI4 1064
ADDP4
ASGNP4
ADDRLP4 1072
INDIRP4
ADDRLP4 1072
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
ADDRGP4 $1742
JUMPV
LABELV $1741
line 2743
;2742:			else
;2743:				itm->visible_prop_flags[0] |= key->flag;
ADDRLP4 1076
ADDRFP4 0
INDIRP4
CNSTI4 1060
ADDP4
ASGNP4
ADDRLP4 1076
INDIRP4
ADDRLP4 1076
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
LABELV $1742
line 2744
;2744:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1724
JUMPV
LABELV $1739
line 2748
;2745:		}
;2746:
;2747:		// add flag for keywords: VIS_GT_FFA | VIS_GT_CTF | etc.
;2748:		key = GT_Vis_KeywordHash_Find(GT_Vis_KeywordHash, (char *)temp);
ADDRGP4 GT_Vis_KeywordHash
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 1072
ADDRGP4 GT_Vis_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 24
ADDRLP4 1072
INDIRP4
ASGNP4
line 2749
;2749:		if (key) {
ADDRLP4 24
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1743
line 2750
;2750:			if (invertFlag)
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $1745
line 2751
;2751:				itm->visible_GT_flags[1] |= key->flag;
ADDRLP4 1076
ADDRFP4 0
INDIRP4
CNSTI4 1080
ADDP4
ASGNP4
ADDRLP4 1076
INDIRP4
ADDRLP4 1076
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
ADDRGP4 $1746
JUMPV
LABELV $1745
line 2753
;2752:			else
;2753:				itm->visible_GT_flags[0] |= key->flag;
ADDRLP4 1080
ADDRFP4 0
INDIRP4
CNSTI4 1076
ADDP4
ASGNP4
ADDRLP4 1080
INDIRP4
ADDRLP4 1080
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
LABELV $1746
line 2754
;2754:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1724
JUMPV
LABELV $1743
line 2758
;2755:		}
;2756:
;2757:		// add flag for keywords: VAL_HEALTH | VAL_ARMOR | etc.
;2758:		key = value_KeywordHash_Find(value_KeywordHash, (char *)temp);
ADDRGP4 value_KeywordHash
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 1076
ADDRGP4 value_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 24
ADDRLP4 1076
INDIRP4
ASGNP4
line 2759
;2759:		if (key) {		
ADDRLP4 24
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1747
line 2760
;2760:			if (invertFlag)
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $1749
line 2761
;2761:				itm->visible_val_flags[1] |= key->flag;
ADDRLP4 1080
ADDRFP4 0
INDIRP4
CNSTI4 1072
ADDP4
ASGNP4
ADDRLP4 1080
INDIRP4
ADDRLP4 1080
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
ADDRGP4 $1750
JUMPV
LABELV $1749
line 2763
;2762:			else
;2763:				itm->visible_val_flags[0] |= key->flag;
ADDRLP4 1084
ADDRFP4 0
INDIRP4
CNSTI4 1068
ADDP4
ASGNP4
ADDRLP4 1084
INDIRP4
ADDRLP4 1084
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
LABELV $1750
line 2764
;2764:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1724
JUMPV
LABELV $1747
line 2768
;2765:		}
;2766:
;2767:		//Com_Printf("visibility key not found: %s\n", temp);
;2768:		return qfalse;
CNSTI4 0
RETI4
LABELV $1724
endproc addVisibilityFlags 1088 8
proc prop_visible 20 12
line 2772
;2769:	}
;2770:}
;2771:
;2772:static qboolean prop_visible(item_t *itm, int handle) {
line 2773
;2773:	qboolean defaultValue = qtrue;
ADDRLP4 8
CNSTI4 1
ASGNI4
line 2775
;2774:	const char *temp;
;2775:	qboolean end = qfalse;
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $1753
JUMPV
LABELV $1752
line 2779
;2776:
;2777:	// several visibility flag possible, so we loop until parse error
;2778:	// then keep token on error (we can't unread a token)
;2779:	while (!end) {
line 2780
;2780:		if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 12
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1755
line 2781
;2781:			if (temp[0] == '}') {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1757
line 2782
;2782:				itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 2783
;2783:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1751
JUMPV
LABELV $1757
line 2786
;2784:			}
;2785:
;2786:			if (addVisibilityFlags(itm, handle, temp)) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 addVisibilityFlags
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $1759
line 2787
;2787:				continue;
ADDRGP4 $1753
JUMPV
LABELV $1759
line 2789
;2788:			}
;2789:			else {
line 2790
;2790:				needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2791
;2791:				cacheTokenStr = (char *)temp;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2792
;2792:				end = qtrue;
ADDRLP4 4
CNSTI4 1
ASGNI4
line 2793
;2793:			}
line 2794
;2794:		}
ADDRGP4 $1756
JUMPV
LABELV $1755
line 2795
;2795:		else {
line 2796
;2796:			needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2797
;2797:			cacheTokenStr = (char *)temp;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2798
;2798:			end = qtrue;
ADDRLP4 4
CNSTI4 1
ASGNI4
line 2800
;2799:			// 'visible' alone is enough
;2800:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1751
JUMPV
LABELV $1756
line 2802
;2801:		}
;2802:	}
LABELV $1753
line 2779
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1752
line 2804
;2803:
;2804:	return qtrue;
CNSTI4 1
RETI4
LABELV $1751
endproc prop_visible 20 12
proc parentIndex 8 8
line 2807
;2805:}
;2806:
;2807:static int parentIndex(const char *parentName) {
line 2810
;2808:	int i;
;2809:
;2810:	for (i = itemCount; i >= 0; i--) {
ADDRLP4 0
ADDRGP4 itemCount
INDIRI4
ASGNI4
ADDRGP4 $1765
JUMPV
LABELV $1762
line 2811
;2811:		if (strcmp(itemArray[i].item_name, parentName) == 0) {
ADDRLP4 0
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray
ADDP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1766
line 2812
;2812:			return itemArray[i].order;
ADDRLP4 0
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray+1024
ADDP4
INDIRI4
RETI4
ADDRGP4 $1761
JUMPV
LABELV $1766
line 2814
;2813:		}
;2814:	}
LABELV $1763
line 2810
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $1765
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $1762
line 2817
;2815:
;2816:	// it could be one of the dynamics item
;2817:	for (i = dyn_itemCount; i >= 0; i--) {
ADDRLP4 0
ADDRGP4 dyn_itemCount
INDIRI4
ASGNI4
ADDRGP4 $1772
JUMPV
LABELV $1769
line 2818
;2818:		if (strcmp(dyn_itemArray[i].item_name, parentName) == 0) {
ADDRLP4 0
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray
ADDP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1773
line 2820
;2819:			// use sign to indicate that parent is in dyn_itemArray
;2820:			return -dyn_itemArray[i].order;
ADDRLP4 0
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray+1024
ADDP4
INDIRI4
NEGI4
RETI4
ADDRGP4 $1761
JUMPV
LABELV $1773
line 2822
;2821:		}
;2822:	}
LABELV $1770
line 2817
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $1772
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $1769
line 2825
;2823:
;2824:	// use previous item if parent not found, and warn user.
;2825:	Com_Printf("parent item '%s' not found. Parent must be placed before the item.\n", parentName);
ADDRGP4 $1776
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 2826
;2826:	return itemCount - 1;
ADDRGP4 itemCount
INDIRI4
CNSTI4 1
SUBI4
RETI4
LABELV $1761
endproc parentIndex 8 8
proc prop_parent 16 12
line 2829
;2827:}
;2828:
;2829:static qboolean prop_parent(item_t *itm, int handle) {
line 2831
;2830:	const char *temp;
;2831:	if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1778
line 2832
;2832:		int idx = parentIndex(temp);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 parentIndex
CALLI4
ASGNI4
ADDRLP4 8
ADDRLP4 12
INDIRI4
ASGNI4
line 2834
;2833:
;2834:		if (idx == 0) {
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1780
line 2835
;2835:			PC_SourceError(handle, "HUD item parent not found: %s \n", temp);
ADDRFP4 4
INDIRI4
ARGI4
ADDRGP4 $1782
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 2836
;2836:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1777
JUMPV
LABELV $1780
line 2838
;2837:		}
;2838:		else {
line 2839
;2839:			itm->parent = idx;
ADDRFP4 0
INDIRP4
CNSTI4 1028
ADDP4
ADDRLP4 8
INDIRI4
ASGNI4
line 2840
;2840:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1777
JUMPV
LABELV $1778
line 2843
;2841:		}
;2842:	}
;2843:	return qfalse;
CNSTI4 0
RETI4
LABELV $1777
endproc prop_parent 16 12
proc prop_valign 20 8
line 2846
;2844:}
;2845:
;2846:static qboolean prop_valign(item_t *itm, int handle) {
line 2848
;2847:	const char *temp;
;2848:	if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1784
line 2849
;2849:		if (temp[0] == 'T')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 84
NEI4 $1786
line 2850
;2850:			itm->propFlags |= PROP_VALIGN_TOP;
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
ADDRGP4 $1787
JUMPV
LABELV $1786
line 2851
;2851:		else if (temp[0] == 'M')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 77
NEI4 $1788
line 2852
;2852:			itm->propFlags |= PROP_VALIGN_MIDDLE;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 2
BORU4
ASGNU4
ADDRGP4 $1789
JUMPV
LABELV $1788
line 2853
;2853:		else if (temp[0] == 'B')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 66
NEI4 $1790
line 2854
;2854:			itm->propFlags |= PROP_VALIGN_BOTTOM;
ADDRLP4 16
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 4
BORU4
ASGNU4
ADDRGP4 $1791
JUMPV
LABELV $1790
line 2856
;2855:		else
;2856:		{
line 2857
;2857:			needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2858
;2858:			cacheTokenStr = (char *)temp;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2859
;2859:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1783
JUMPV
LABELV $1791
LABELV $1789
LABELV $1787
line 2861
;2860:		}
;2861:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1783
JUMPV
LABELV $1784
line 2863
;2862:	}
;2863:	return qfalse;
CNSTI4 0
RETI4
LABELV $1783
endproc prop_valign 20 8
proc prop_cvarTest 24 12
line 2866
;2864:}
;2865:
;2866:static qboolean prop_cvarTest(item_t *itm, int handle) {
line 2868
;2867:	const char *temp;
;2868:	if (!PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1793
line 2869
;2869:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1792
JUMPV
LABELV $1793
line 2871
;2870:	}
;2871:	else {
line 2873
;2872:		cvarTest_keywordHash_t *key;
;2873:		char *tmp = (char *)temp;
ADDRLP4 8
ADDRLP4 0
INDIRP4
ASGNP4
line 2874
;2874:		key = cvarTest_KeywordHash_Find(cvarTest_KeywordHash, tmp);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 cvarTest_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 12
ADDRLP4 16
INDIRP4
ASGNP4
line 2875
;2875:		if (!key) {
ADDRLP4 12
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1795
line 2876
;2876:			PC_SourceError(handle, "unknown cvar %s", tmp);
ADDRFP4 4
INDIRI4
ARGI4
ADDRGP4 $1797
ARGP4
ADDRLP4 8
INDIRP4
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 2877
;2877:		}
ADDRGP4 $1796
JUMPV
LABELV $1795
line 2878
;2878:		else {
line 2879
;2879:			itm->cvarTest_flags |= key->flag;
ADDRLP4 20
ADDRFP4 0
INDIRP4
CNSTI4 1084
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
ADDRLP4 12
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
line 2880
;2880:		}
LABELV $1796
line 2881
;2881:	}
line 2882
;2882:	return qtrue;
CNSTI4 1
RETI4
LABELV $1792
endproc prop_cvarTest 24 12
proc ParseFlags 12 8
line 2885
;2883:}
;2884:
;2885:static qboolean ParseFlags(const char *s, unsigned int *flags, int handle) {
line 2887
;2886:	flag_keywordHash_t *key;
;2887:	key = value_KeywordHash_Find(value_KeywordHash, (char *)s);
ADDRGP4 value_KeywordHash
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 value_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 2888
;2888:	if (!key) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1799
line 2890
;2889:		//PC_SourceError(handle, "HUD item unknown value/caption: %s", s);
;2890:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1798
JUMPV
LABELV $1799
line 2892
;2891:	}
;2892:	else {
line 2893
;2893:		*flags |= key->flag;
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
line 2894
;2894:		return qtrue;
CNSTI4 1
RETI4
LABELV $1798
endproc ParseFlags 12 8
proc prop_gradient 16 12
line 2898
;2895:	}
;2896:}
;2897:
;2898:static qboolean prop_gradient(item_t *itm, int handle) {
line 2900
;2899:	const char *s;
;2900:	if (PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1802
line 2901
;2901:		if (*s == '!') {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 33
NEI4 $1804
line 2902
;2902:			itm->propFlags |= PROP_GRADIENT_INVERT;
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 1024
BORU4
ASGNU4
line 2903
;2903:			if (!PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 12
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1806
line 2904
;2904:				Com_Printf("Error HUD item %s, can't parse property 'gradient': %s", itm->item_name, s);
ADDRGP4 $1808
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 2905
;2905:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1801
JUMPV
LABELV $1806
line 2907
;2906:			}
;2907:		}
LABELV $1804
line 2908
;2908:		return ParseFlags(s, &itm->gradientFlags, handle);
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 ParseFlags
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
RETI4
ADDRGP4 $1801
JUMPV
LABELV $1802
line 2910
;2909:	}
;2910:	else {
line 2911
;2911:		Com_Printf("Error HUD item %s, can't parse property 'gradient': %s", itm->item_name, s);
ADDRGP4 $1808
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 2912
;2912:		return qfalse;
CNSTI4 0
RETI4
LABELV $1801
endproc prop_gradient 16 12
proc prop_caption 16 12
line 2916
;2913:	}
;2914:}
;2915:
;2916:static qboolean prop_caption(item_t *itm, int handle) {
line 2918
;2917:	const char *s;
;2918:	if (PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1810
line 2919
;2919:		if (!ParseFlags(s, &itm->text.flags, handle)) {
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 ParseFlags
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1812
line 2920
;2920:			itm->text.caption = (char *)s;
ADDRFP4 0
INDIRP4
CNSTI4 1196
ADDP4
ADDRLP4 0
INDIRP4
ASGNP4
line 2921
;2921:			itm->text.flags |= VAL_TEXT;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
line 2922
;2922:		}
LABELV $1812
line 2923
;2923:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1809
JUMPV
LABELV $1810
line 2925
;2924:	}
;2925:	else {
line 2926
;2926:		Com_Printf("Error HUD item %s, can't parse property 'caption': %s", itm->item_name, s);
ADDRGP4 $1814
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 2927
;2927:		return qfalse;
CNSTI4 0
RETI4
LABELV $1809
endproc prop_caption 16 12
export items_KeywordHash_Add
proc items_KeywordHash_Add 8 4
line 2937
;2928:	}
;2929:}
;2930:
;2931:
;2932:/*
;2933:===============
;2934:Hud items list hash
;2935:===============
;2936:*/
;2937:void items_KeywordHash_Add(items_keywordHash_t *table[], items_keywordHash_t *key) {
line 2940
;2938:	int hash;
;2939:
;2940:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 2941
;2941:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2942
;2942:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 2943
;2943:}
LABELV $1815
endproc items_KeywordHash_Add 8 4
export items_KeywordHash_Find
proc items_KeywordHash_Find 16 8
line 2946
;2944:
;2945:items_keywordHash_t *items_KeywordHash_Find(items_keywordHash_t *table[], char *keyword)
;2946:{
line 2950
;2947:	items_keywordHash_t *key;
;2948:	int hash;
;2949:
;2950:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2951
;2951:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1820
JUMPV
LABELV $1817
line 2952
;2952:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1821
line 2953
;2953:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1816
JUMPV
LABELV $1821
line 2954
;2954:	}
LABELV $1818
line 2951
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1820
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1817
line 2955
;2955:	return NULL;
CNSTP4 0
RETP4
LABELV $1816
endproc items_KeywordHash_Find 16 8
export items_SetupKeywordHash
proc items_SetupKeywordHash 4 12
line 2960
;2956:}
;2957:
;2958:items_keywordHash_t *items_KeywordHash[KEYWORDHASH_SIZE];
;2959:
;2960:void items_SetupKeywordHash(void) {
line 2962
;2961:	int i;
;2962:	memset(items_KeywordHash, 0, sizeof(items_KeywordHash));
ADDRGP4 items_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 2963
;2963:	for (i = 0; item_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1827
JUMPV
LABELV $1824
line 2964
;2964:		items_KeywordHash_Add(items_KeywordHash, &item_Keywords[i]);
ADDRGP4 items_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 item_Keywords
ADDP4
ARGP4
ADDRGP4 items_KeywordHash_Add
CALLV
pop
line 2965
;2965:	}
LABELV $1825
line 2963
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1827
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 item_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1824
line 2966
;2966:}
LABELV $1823
endproc items_SetupKeywordHash 4 12
data
export specifics_item_Keywords
align 4
LABELV specifics_item_Keywords
address $1828
byte 4 0
address $1829
byte 4 0
address $1362
byte 4 0
address $1363
byte 4 0
address $1364
byte 4 0
address $1365
byte 4 0
address $1830
byte 4 0
byte 4 0
byte 4 0
export specifics_items_KeywordHash_Add
code
proc specifics_items_KeywordHash_Add 8 4
line 2986
;2967:
;2968:/*
;2969:===============
;2970:specifics items list hash
;2971:===============
;2972:*/
;2973:specifics_keywordHash_t specifics_item_Keywords[] = {
;2974:	{"INFO",			NULL},
;2975:	{"SetCvar",			NULL},
;2976:	{"HealthColors",	NULL},
;2977:	{"ArmorColors",		NULL},
;2978:	{"AmmoColors",		NULL},
;2979:	{"TeamsColors",		NULL},
;2980:	{"GameTypeIcons",	NULL},
;2981:	//{"WeaponIcons",	NULL},//TODO
;2982:	//{"AmmoIcons",		NULL},//TODO
;2983:	{NULL,				NULL}
;2984:};
;2985:
;2986:void specifics_items_KeywordHash_Add(specifics_keywordHash_t *table[], specifics_keywordHash_t *key) {
line 2989
;2987:	int hash;
;2988:
;2989:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 2990
;2990:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2991
;2991:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 2992
;2992:}
LABELV $1831
endproc specifics_items_KeywordHash_Add 8 4
export specifics_items_KeywordHash_Find
proc specifics_items_KeywordHash_Find 16 8
line 2995
;2993:
;2994:specifics_keywordHash_t *specifics_items_KeywordHash_Find(specifics_keywordHash_t *table[], char *keyword)
;2995:{
line 2999
;2996:	specifics_keywordHash_t *key;
;2997:	int hash;
;2998:
;2999:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 3000
;3000:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1836
JUMPV
LABELV $1833
line 3001
;3001:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1837
line 3002
;3002:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1832
JUMPV
LABELV $1837
line 3003
;3003:	}
LABELV $1834
line 3000
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ASGNP4
LABELV $1836
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1833
line 3004
;3004:	return NULL;
CNSTP4 0
RETP4
LABELV $1832
endproc specifics_items_KeywordHash_Find 16 8
export specifics_items_SetupKeywordHash
proc specifics_items_SetupKeywordHash 4 12
line 3009
;3005:}
;3006:
;3007:specifics_keywordHash_t *specifics_KeywordHash[KEYWORDHASH_SIZE];
;3008:
;3009:void specifics_items_SetupKeywordHash(void) {
line 3011
;3010:	int i;
;3011:	memset(specifics_KeywordHash, 0, sizeof(specifics_KeywordHash));
ADDRGP4 specifics_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3012
;3012:	for (i = 0; specifics_item_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1843
JUMPV
LABELV $1840
line 3013
;3013:		specifics_items_KeywordHash_Add(specifics_KeywordHash, &specifics_item_Keywords[i]);
ADDRGP4 specifics_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 3
LSHI4
ADDRGP4 specifics_item_Keywords
ADDP4
ARGP4
ADDRGP4 specifics_items_KeywordHash_Add
CALLV
pop
line 3014
;3014:	}
LABELV $1841
line 3012
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1843
ADDRLP4 0
INDIRI4
CNSTI4 3
LSHI4
ADDRGP4 specifics_item_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1840
line 3015
;3015:}
LABELV $1839
endproc specifics_items_SetupKeywordHash 4 12
data
export dyn_item_Keywords
align 4
LABELV dyn_item_Keywords
address $1844
address IcoWeapList_idx
byte 4 0
address $1845
address IcoWeapListSel_idx
byte 4 0
address $1846
address WeapListSelName_idx
byte 4 0
address $1847
address KillMsg_idx
byte 4 0
address $1848
address ItemMsg_idx
byte 4 0
address $1849
address WarmFightMsg_idx
byte 4 0
address $1850
address ServerMsg_idx
byte 4 0
address $1851
address IcoPowerUp_idx
byte 4 0
address $1852
address TeamOverlay_Sel_idx
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export dyn_items_KeywordHash_Add
code
proc dyn_items_KeywordHash_Add 8 4
line 3050
;3016:
;3017:/*
;3018:===============
;3019:Dynamics items list hash
;3020:===============
;3021:*/
;3022:item_t dyn_itemArray[MAX_HUD_ITEM];
;3023:int dyn_itemCount;
;3024:
;3025:int IcoWeapList_idx;
;3026:int IcoWeapListSel_idx;
;3027:int WeapListSelName_idx;
;3028:int IcoPowerUp_idx;
;3029:int WarmFightMsg_idx;
;3030:int KillMsg_idx;
;3031:int ItemMsg_idx;
;3032:int ServerMsg_idx;
;3033:int TeamOverlay_Sel_idx;
;3034:
;3035:dyn_items_keywordHash_t dyn_item_Keywords[] = {
;3036:	{"Icon_WeaponList",				&IcoWeapList_idx,		NULL},
;3037:	{"Icon_WeaponList_Selected",	&IcoWeapListSel_idx,	NULL},
;3038:	{"WeaponList_SelectedName",		&WeapListSelName_idx,	NULL},
;3039:	{"KillMessage",					&KillMsg_idx,			NULL},
;3040:	{"ItemMessage",					&ItemMsg_idx,			NULL},
;3041:	{"WarmupFightMessage",			&WarmFightMsg_idx,		NULL},
;3042:	{"ServerMessage",				&ServerMsg_idx,			NULL},
;3043:	{"Icon_PowerUp",				&IcoPowerUp_idx,		NULL},
;3044:	{"TeamOverlay_Selected",		&TeamOverlay_Sel_idx,	NULL},
;3045:	{NULL,							NULL,					NULL}
;3046:};
;3047:
;3048:dyn_items_keywordHash_t *dyn_KeywordHash[KEYWORDHASH_SIZE];
;3049:
;3050:void dyn_items_KeywordHash_Add(dyn_items_keywordHash_t *table[], dyn_items_keywordHash_t *key) {
line 3053
;3051:	int hash;
;3052:
;3053:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 3054
;3054:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 3055
;3055:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 3056
;3056:}
LABELV $1853
endproc dyn_items_KeywordHash_Add 8 4
export dyn_items_SetupKeywordHash
proc dyn_items_SetupKeywordHash 4 12
line 3058
;3057:
;3058:void dyn_items_SetupKeywordHash(void) {
line 3060
;3059:	int i;
;3060:	memset(dyn_KeywordHash, 0, sizeof(dyn_KeywordHash));
ADDRGP4 dyn_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3061
;3061:	for (i = 0; dyn_item_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1858
JUMPV
LABELV $1855
line 3062
;3062:		dyn_items_KeywordHash_Add(dyn_KeywordHash, &dyn_item_Keywords[i]);
ADDRGP4 dyn_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 dyn_item_Keywords
ADDP4
ARGP4
ADDRGP4 dyn_items_KeywordHash_Add
CALLV
pop
line 3063
;3063:	}
LABELV $1856
line 3061
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1858
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 dyn_item_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1855
line 3064
;3064:}
LABELV $1854
endproc dyn_items_SetupKeywordHash 4 12
export dyn_items_KeywordHash_Find
proc dyn_items_KeywordHash_Find 16 8
line 3067
;3065:
;3066:dyn_items_keywordHash_t *dyn_items_KeywordHash_Find(dyn_items_keywordHash_t *table[], char *keyword)
;3067:{
line 3071
;3068:	dyn_items_keywordHash_t *key;
;3069:	int hash;
;3070:
;3071:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 3072
;3072:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1863
JUMPV
LABELV $1860
line 3073
;3073:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1864
line 3074
;3074:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1859
JUMPV
LABELV $1864
line 3075
;3075:	}
LABELV $1861
line 3072
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1863
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1860
line 3076
;3076:	return NULL;
CNSTP4 0
RETP4
LABELV $1859
endproc dyn_items_KeywordHash_Find 16 8
export prop_KeywordHash_Add
proc prop_KeywordHash_Add 8 4
line 3093
;3077:}
;3078:
;3079:
;3080:/*
;3081:===============
;3082:properties list hash
;3083:===============
;3084:*/
;3085:typedef struct prop_keywordHash_s
;3086:{
;3087:	char *keyword;
;3088:	qboolean(*ownerDraw)(item_t *itm, int handle);
;3089:	struct prop_keywordHash_s *next;
;3090:} prop_keywordHash_t;
;3091:
;3092:
;3093:void prop_KeywordHash_Add(prop_keywordHash_t *table[], prop_keywordHash_t *key) {
line 3096
;3094:	int hash;
;3095:
;3096:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 3097
;3097:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 3098
;3098:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 3099
;3099:}
LABELV $1866
endproc prop_KeywordHash_Add 8 4
export prop_KeywordHash_Find
proc prop_KeywordHash_Find 16 8
line 3102
;3100:
;3101:prop_keywordHash_t *prop_KeywordHash_Find(prop_keywordHash_t *table[], char *keyword)
;3102:{
line 3106
;3103:	prop_keywordHash_t *key;
;3104:	int hash;
;3105:
;3106:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 3107
;3107:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1871
JUMPV
LABELV $1868
line 3108
;3108:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1872
line 3109
;3109:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1867
JUMPV
LABELV $1872
line 3110
;3110:	}
LABELV $1869
line 3107
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1871
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1868
line 3111
;3111:	return NULL;
CNSTP4 0
RETP4
LABELV $1867
endproc prop_KeywordHash_Find 16 8
data
export itemProperty_Keywords
align 4
LABELV itemProperty_Keywords
address $1874
address prop_name
byte 4 0
address $1875
address prop_rect
byte 4 0
address $1876
address prop_background
byte 4 0
address $1877
address prop_icon3D
byte 4 0
address $1878
address prop_cvarTest
byte 4 0
address $1879
address prop_verticalbar
byte 4 0
address $1880
address prop_textalign
byte 4 0
address $1881
address prop_Size
byte 4 0
address $1882
address prop_font
byte 4 0
address $1883
address prop_param
byte 4 0
address $1884
address prop_forecolor
byte 4 0
address $1885
address prop_backcolor
byte 4 0
address $1886
address prop_anchors
byte 4 0
address $1887
address prop_fill
byte 4 0
address $1888
address prop_BlinkWhenLow
byte 4 0
address $1889
address prop_time
byte 4 0
address $1890
address prop_visible
byte 4 0
address $1891
address prop_pulseScale
byte 4 0
address $1892
address prop_proportional
byte 4 0
address $1893
address prop_shadow
byte 4 0
address $1894
address prop_margin
byte 4 0
address $1895
address prop_valign
byte 4 0
address $1896
address prop_parent
byte 4 0
address $1897
address prop_gradient
byte 4 0
address $1898
address prop_caption
byte 4 0
address $1899
address prop_TeamPlayer
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export prop_SetupKeywordHash
code
proc prop_SetupKeywordHash 4 12
line 3220
;3112:}
;3113:
;3114:// CPMA compatibility
;3115:#ifdef CPMA_COMPAT
;3116:static qboolean prop_textstyle(item_t *itm, int handle) {
;3117:	int res;
;3118:	if (!PC_Int_Parse(handle, &res)) {
;3119:		return qfalse;
;3120:	}
;3121:	if (res == 1) {
;3122:		itm->text.styleflags |= DS_SHADOW;
;3123:	}
;3124:	//what other textstyle value do?
;3125:	return qtrue;
;3126:}
;3127:// do nothing, it's for CPMA compatibility
;3128:static qboolean prop_textoffset(item_t *itm, int handle) {
;3129:	int res;
;3130:	if (!PC_Int_Parse(handle, &res)) {
;3131:		return qfalse;
;3132:	}
;3133:	else {
;3134:		if (!PC_Int_Parse(handle, &res)) {
;3135:			return qfalse;
;3136:		}
;3137:	}
;3138:	return qtrue;
;3139:}
;3140:
;3141:// do nothing, it's for CPMA compatibility
;3142:static qboolean imagetc_Parse(int handle, margin_t *m) {
;3143:	int paramNb = 0;
;3144:	float res;
;3145:	if (PC_Float_Parse(handle, &res)) {
;3146:		paramNb++;
;3147:		if (PC_Float_Parse(handle, &res)) {
;3148:			paramNb++;
;3149:			if (PC_Float_Parse(handle, &res)) {
;3150:				paramNb++;
;3151:				if (PC_Float_Parse(handle, &res)) {
;3152:					paramNb++;
;3153:					return qtrue;
;3154:				}
;3155:			}
;3156:		}
;3157:	}
;3158:	return (paramNb > 0);
;3159:}
;3160:// do nothing, it's for CPMA compatibility
;3161:static qboolean prop_imagetc(item_t *itm, int handle) {
;3162:	if (!imagetc_Parse(handle, &itm->margin)) {
;3163:		return qfalse;
;3164:	}
;3165:	return qtrue;
;3166:}
;3167:#endif
;3168:
;3169:prop_keywordHash_t itemProperty_Keywords[] = {
;3170:	{"name",		prop_name,			NULL},
;3171:	{"rect",		prop_rect,			NULL},
;3172:	{"background",	prop_background,	NULL},
;3173:	{"icon3D",		prop_icon3D,		NULL},
;3174:	{"cvarTest",	prop_cvarTest,		NULL},
;3175:	{"verticalbar", prop_verticalbar,	NULL},
;3176:	{"textalign",	prop_textalign,		NULL},
;3177:	{"fontsize",	prop_Size,			NULL},
;3178:	{"font",		prop_font,			NULL},
;3179:	{"param",		prop_param,			NULL},
;3180:	{"forecolor",	prop_forecolor,		NULL},
;3181:	{"backcolor",	prop_backcolor,		NULL},
;3182:	{"anchors",		prop_anchors,		NULL},
;3183:	{"fill",		prop_fill,			NULL},
;3184:	{"blink",		prop_BlinkWhenLow,	NULL},
;3185:	{"time",		prop_time,			NULL},
;3186:	{"visible",		prop_visible,		NULL},
;3187:	{"pulseScale",	prop_pulseScale,	NULL},
;3188:	{"proportional",prop_proportional,	NULL},
;3189:	{"shadow",		prop_shadow,		NULL},
;3190:	{"margin",		prop_margin,		NULL},
;3191:	{"valign",		prop_valign,		NULL},
;3192:	{"parent",		prop_parent,		NULL},
;3193:	{"gradient",	prop_gradient,		NULL},
;3194:	{"caption",		prop_caption,		NULL},
;3195:	{"team_player",	prop_TeamPlayer,	NULL},
;3196:#ifdef CPMA_COMPAT
;3197:	// CPMA compatibility
;3198:	{"color",		prop_forecolor,		NULL},
;3199:	{"bgcolor",		prop_backcolor,		NULL},
;3200:	{"image",		prop_background,	NULL},
;3201:	{"textstyle",	prop_textstyle,		NULL}, // do nothing
;3202:	{"visflags",	prop_textstyle,		NULL}, // do nothing
;3203:	{"alignh",		prop_textalign,		NULL},
;3204:	{"text",		prop_caption,		NULL},
;3205:	{"textoffset",	prop_textoffset,	NULL},	// do nothing
;3206:	{"imagetc",		prop_imagetc,		NULL},	// do nothing
;3207:	{"monospace",	prop_proportional,	NULL},
;3208:#endif
;3209:	/*
;3210:	// only usefull in UIGAME
;3211:	{"name",		prop_HUDname,			NULL},	// name of the HUD file
;3212:	{"author",		prop_HUDauthor,		NULL},	// author of the HUD file
;3213:	{"description",	prop_HUDdescription,	NULL},	// HUD short description
;3214:	*/
;3215:	{NULL,			0,					NULL}
;3216:};
;3217:
;3218:prop_keywordHash_t *prop_KeywordHash[KEYWORDHASH_SIZE];
;3219:
;3220:void prop_SetupKeywordHash(void) {
line 3223
;3221:	int i;
;3222:
;3223:	memset(prop_KeywordHash, 0, sizeof(prop_KeywordHash));
ADDRGP4 prop_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3224
;3224:	for (i = 0; itemProperty_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1904
JUMPV
LABELV $1901
line 3225
;3225:		prop_KeywordHash_Add(prop_KeywordHash, &itemProperty_Keywords[i]);
ADDRGP4 prop_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 itemProperty_Keywords
ADDP4
ARGP4
ADDRGP4 prop_KeywordHash_Add
CALLV
pop
line 3226
;3226:	}
LABELV $1902
line 3224
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1904
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 itemProperty_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1901
line 3227
;3227:}
LABELV $1900
endproc prop_SetupKeywordHash 4 12
export itemProperties_Parse
proc itemProperties_Parse 1056 12
line 3235
;3228:
;3229:/*
;3230:=================
;3231:itemProperties_Parse
;3232:parse properties (rect, image, ...) of each item
;3233:=================
;3234:*/
;3235:qboolean itemProperties_Parse(item_t *itm, int handle) {
line 3239
;3236:	pc_token_t token;
;3237:	prop_keywordHash_t *key;
;3238:
;3239:	if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 1044
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1044
INDIRI4
CNSTI4 0
NEI4 $1906
line 3240
;3240:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1905
JUMPV
LABELV $1906
line 3243
;3241:	}
;3242:
;3243:	if (*token.string != '{') {
ADDRLP4 4+16
INDIRI1
CVII4 1
CNSTI4 123
EQI4 $1912
line 3244
;3244:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1905
JUMPV
LABELV $1911
line 3247
;3245:	}
;3246:
;3247:	while (1) {
line 3249
;3248:		// we can't unread token, so we check last token on parse error
;3249:		if (itemEnd) {
ADDRGP4 itemEnd
INDIRI4
CNSTI4 0
EQI4 $1914
line 3250
;3250:			itemEnd = qfalse;
ADDRGP4 itemEnd
CNSTI4 0
ASGNI4
line 3251
;3251:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1905
JUMPV
LABELV $1914
line 3254
;3252:		}
;3253:
;3254:		if (propertyEnd) {
ADDRGP4 propertyEnd
INDIRI4
CNSTI4 0
EQI4 $1916
line 3255
;3255:			key = prop_KeywordHash_Find(prop_KeywordHash, token.string);
ADDRGP4 prop_KeywordHash
ARGP4
ADDRLP4 4+16
ARGP4
ADDRLP4 1048
ADDRGP4 prop_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 1048
INDIRP4
ASGNP4
line 3256
;3256:			propertyEnd = qfalse;
ADDRGP4 propertyEnd
CNSTI4 0
ASGNI4
line 3257
;3257:		}	
ADDRGP4 $1917
JUMPV
LABELV $1916
line 3258
;3258:		else if (needCacheToken) {
ADDRGP4 needCacheToken
INDIRI4
CNSTI4 0
EQI4 $1919
line 3259
;3259:			if (*cacheTokenStr == ';' || *cacheTokenStr == ',') {
ADDRLP4 1048
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 59
EQI4 $1923
ADDRLP4 1048
INDIRI4
CNSTI4 44
NEI4 $1921
LABELV $1923
line 3260
;3260:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3261
;3261:				continue;
ADDRGP4 $1912
JUMPV
LABELV $1921
line 3263
;3262:			}
;3263:			key = prop_KeywordHash_Find(prop_KeywordHash, cacheTokenStr);
ADDRGP4 prop_KeywordHash
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1052
ADDRGP4 prop_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 1052
INDIRP4
ASGNP4
line 3265
;3264:			//resetTokenCache();
;3265:		}
ADDRGP4 $1920
JUMPV
LABELV $1919
line 3266
;3266:		else {
line 3267
;3267:			memset(&token, 0, sizeof(pc_token_t));
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1040
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3269
;3268:
;3269:			if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1924
line 3270
;3270:				PC_SourceError(handle, "end of file inside property");
ADDRFP4 4
INDIRI4
ARGI4
ADDRGP4 $1926
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3271
;3271:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1905
JUMPV
LABELV $1924
line 3273
;3272:			}
;3273:			else if (*token.string == '}') {
ADDRLP4 4+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1927
line 3274
;3274:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1905
JUMPV
LABELV $1927
line 3276
;3275:			}
;3276:			else if (*token.string == ';' || *token.string == ',') {
ADDRLP4 4+16
INDIRI1
CVII4 1
CNSTI4 59
EQI4 $1934
ADDRLP4 4+16
INDIRI1
CVII4 1
CNSTI4 44
NEI4 $1930
LABELV $1934
line 3277
;3277:				continue;
ADDRGP4 $1912
JUMPV
LABELV $1930
line 3280
;3278:			}
;3279:
;3280:			key = prop_KeywordHash_Find(prop_KeywordHash, token.string);
ADDRGP4 prop_KeywordHash
ARGP4
ADDRLP4 4+16
ARGP4
ADDRLP4 1052
ADDRGP4 prop_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 1052
INDIRP4
ASGNP4
line 3281
;3281:		}
LABELV $1920
LABELV $1917
line 3283
;3282:
;3283:		if (!key) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1936
line 3284
;3284:			PC_SourceError(handle, "unknown property keyword %s", token.string);
ADDRFP4 4
INDIRI4
ARGI4
ADDRGP4 $1938
ARGP4
ADDRLP4 4+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3285
;3285:			continue;
ADDRGP4 $1912
JUMPV
LABELV $1936
line 3288
;3286:		}
;3287:
;3288:		resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3290
;3289:
;3290:		if (!key->ownerDraw((item_t *)itm, handle)) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 1048
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1940
line 3291
;3291:			PC_SourceError(handle, "couldn't parse property keyword %s", token.string);
ADDRFP4 4
INDIRI4
ARGI4
ADDRGP4 $1942
ARGP4
ADDRLP4 4+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3292
;3292:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1905
JUMPV
LABELV $1940
line 3294
;3293:		}
;3294:	}
LABELV $1912
line 3247
ADDRGP4 $1911
JUMPV
line 3295
;3295:	return qfalse;
CNSTI4 0
RETI4
LABELV $1905
endproc itemProperties_Parse 1056 12
proc skipItem 1044 8
line 3299
;3296:}
;3297:
;3298:// read until end of item
;3299:static qboolean skipItem(int handle) {
ADDRGP4 $1946
JUMPV
LABELV $1945
line 3301
;3300:	pc_token_t token;
;3301:	while (*token.string != '}') {
line 3302
;3302:		if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1040
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1040
INDIRI4
CNSTI4 0
NEI4 $1949
line 3303
;3303:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1944
JUMPV
LABELV $1949
line 3305
;3304:		}
;3305:	}
LABELV $1946
line 3301
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1945
line 3306
;3306:	return qtrue;
CNSTI4 1
RETI4
LABELV $1944
endproc skipItem 1044 8
export cvar_update
proc cvar_update 8 8
line 3309
;3307:}
;3308:
;3309:qboolean cvar_update(int handle, vmCvar_t *cvar) {
line 3311
;3310:	int val;
;3311:	if (!PC_Int_Parse(handle, &val)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_Int_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1952
line 3312
;3312:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1951
JUMPV
LABELV $1952
line 3314
;3313:	}
;3314:	cvar->integer = val;
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ADDRLP4 0
INDIRI4
ASGNI4
line 3315
;3315:	return qtrue;
CNSTI4 1
RETI4
LABELV $1951
endproc cvar_update 8 8
proc script_Parse 1056 12
line 3319
;3316:}
;3317:
;3318:// Parse cvar_t and change cvar_t state
;3319:static qboolean script_Parse(int handle ) {
line 3323
;3320:	pc_token_t token;
;3321:	cvarTest_keywordHash_t *key;
;3322:
;3323:	if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1044
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1044
INDIRI4
CNSTI4 0
NEI4 $1955
line 3324
;3324:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1954
JUMPV
LABELV $1955
line 3327
;3325:	}
;3326:
;3327:	if (*token.string != '{') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 123
EQI4 $1961
line 3328
;3328:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1954
JUMPV
LABELV $1960
line 3331
;3329:	}
;3330:
;3331:	while (1) {
line 3333
;3332:		// we can't unread token, so we check last token on parse error
;3333:		if (itemEnd)
ADDRGP4 itemEnd
INDIRI4
CNSTI4 0
EQI4 $1963
line 3334
;3334:		{
line 3335
;3335:			itemEnd = qfalse;
ADDRGP4 itemEnd
CNSTI4 0
ASGNI4
line 3336
;3336:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1954
JUMPV
LABELV $1963
line 3339
;3337:		}
;3338:
;3339:		if (needCacheToken)
ADDRGP4 needCacheToken
INDIRI4
CNSTI4 0
EQI4 $1965
line 3340
;3340:		{
line 3341
;3341:			if (*cacheTokenStr == ';' || *cacheTokenStr == ',') {
ADDRLP4 1048
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 59
EQI4 $1969
ADDRLP4 1048
INDIRI4
CNSTI4 44
NEI4 $1967
LABELV $1969
line 3342
;3342:				continue;
ADDRGP4 $1961
JUMPV
LABELV $1967
line 3344
;3343:			}
;3344:			key = cvarTest_KeywordHash_Find(cvarTest_KeywordHash, cacheTokenStr);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1052
ADDRGP4 cvarTest_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 1040
ADDRLP4 1052
INDIRP4
ASGNP4
line 3345
;3345:			resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3346
;3346:		}
ADDRGP4 $1966
JUMPV
LABELV $1965
line 3348
;3347:		else
;3348:		{
line 3349
;3349:			memset(&token, 0, sizeof(pc_token_t));
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1040
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3351
;3350:
;3351:			if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1970
line 3352
;3352:				PC_SourceError(handle, "end of file inside script");
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $1972
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3353
;3353:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1954
JUMPV
LABELV $1970
line 3356
;3354:			}
;3355:
;3356:			if (*token.string == '}') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1973
line 3357
;3357:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1954
JUMPV
LABELV $1973
line 3359
;3358:			}
;3359:			if (*token.string == ';' || *token.string == ',') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
EQI4 $1980
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 44
NEI4 $1976
LABELV $1980
line 3360
;3360:				continue;
ADDRGP4 $1961
JUMPV
LABELV $1976
line 3362
;3361:			}
;3362:			key = cvarTest_KeywordHash_Find(cvarTest_KeywordHash, token.string);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRLP4 0+16
ARGP4
ADDRLP4 1052
ADDRGP4 cvarTest_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 1040
ADDRLP4 1052
INDIRP4
ASGNP4
line 3363
;3363:		}
LABELV $1966
line 3365
;3364:
;3365:		if (!key) {
ADDRLP4 1040
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1982
line 3366
;3366:			PC_SourceError(handle, "unknown script keyword %s", token.string);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $1984
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3367
;3367:			continue;
ADDRGP4 $1961
JUMPV
LABELV $1982
line 3370
;3368:		}
;3369:
;3370:		if (!cvar_update(handle, key->cvar)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 1040
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ARGP4
ADDRLP4 1048
ADDRGP4 cvar_update
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1986
line 3371
;3371:			PC_SourceError(handle, "couldn't parse script keyword %s", token.string);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $1988
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3372
;3372:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1954
JUMPV
LABELV $1986
line 3374
;3373:		}
;3374:	}
LABELV $1961
line 3331
ADDRGP4 $1960
JUMPV
line 3375
;3375:	return qfalse;
CNSTI4 0
RETI4
LABELV $1954
endproc script_Parse 1056 12
export parseColorItem
proc parseColorItem 1064 12
line 3379
;3376:}
;3377:
;3378:
;3379:qboolean parseColorItem(int handle, float array_colors[4][4]) {
line 3384
;3380:	pc_token_t token;
;3381:	cvarTest_keywordHash_t *key;
;3382:	int colorIdx;
;3383:
;3384:	if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1991
line 3385
;3385:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1990
JUMPV
LABELV $1991
line 3388
;3386:	}
;3387:
;3388:	if (*token.string != '{') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 123
EQI4 $1993
line 3389
;3389:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1990
JUMPV
LABELV $1993
line 3392
;3390:	}
;3391:
;3392:	colorIdx = 0;
ADDRLP4 1040
CNSTI4 0
ASGNI4
ADDRGP4 $1997
JUMPV
LABELV $1996
line 3394
;3393:
;3394:	while (1) {
line 3396
;3395:		// we can't unread token, so we check last token on parse error
;3396:		if (itemEnd)
ADDRGP4 itemEnd
INDIRI4
CNSTI4 0
EQI4 $1999
line 3397
;3397:		{
line 3398
;3398:			itemEnd = qfalse;
ADDRGP4 itemEnd
CNSTI4 0
ASGNI4
line 3399
;3399:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1990
JUMPV
LABELV $1999
line 3402
;3400:		}
;3401:
;3402:		if (needCacheToken)
ADDRGP4 needCacheToken
INDIRI4
CNSTI4 0
EQI4 $2001
line 3403
;3403:		{
line 3404
;3404:			if (*cacheTokenStr == ';' || *cacheTokenStr == ',') {
ADDRLP4 1052
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 59
EQI4 $2005
ADDRLP4 1052
INDIRI4
CNSTI4 44
NEI4 $2003
LABELV $2005
line 3405
;3405:				continue;
ADDRGP4 $1997
JUMPV
LABELV $2003
line 3407
;3406:			}
;3407:			key = cvarTest_KeywordHash_Find(cvarTest_KeywordHash, cacheTokenStr);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1056
ADDRGP4 cvarTest_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 1044
ADDRLP4 1056
INDIRP4
ASGNP4
line 3408
;3408:			resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3409
;3409:		}
ADDRGP4 $2002
JUMPV
LABELV $2001
line 3411
;3410:		else
;3411:		{
line 3412
;3412:			memset(&token, 0, sizeof(pc_token_t));
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1040
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3414
;3413:
;3414:			if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1052
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 0
NEI4 $2006
line 3415
;3415:				PC_SourceError(handle, "end of file inside hud file");
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $2008
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3416
;3416:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1990
JUMPV
LABELV $2006
line 3419
;3417:			}
;3418:
;3419:			if (*token.string == '}') { // exit the loop
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $2009
line 3420
;3420:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1990
JUMPV
LABELV $2009
line 3423
;3421:			}
;3422:
;3423:			if (*token.string == ';' || *token.string == ',') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
EQI4 $2016
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 44
NEI4 $2012
LABELV $2016
line 3424
;3424:				continue;
ADDRGP4 $1997
JUMPV
LABELV $2012
line 3427
;3425:			}
;3426:
;3427:			if (strcmp("color", token.string) == 0) {
ADDRGP4 $2019
ARGP4
ADDRLP4 0+16
ARGP4
ADDRLP4 1056
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1056
INDIRI4
CNSTI4 0
NEI4 $2017
line 3428
;3428:				if (!PC_Color_Parse(handle, &array_colors[colorIdx])) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 1040
INDIRI4
CNSTI4 4
LSHI4
ADDRFP4 4
INDIRP4
ADDP4
ARGP4
ADDRLP4 1060
ADDRGP4 PC_Color_Parse
CALLI4
ASGNI4
ADDRLP4 1060
INDIRI4
CNSTI4 0
NEI4 $2021
line 3429
;3429:					Com_Printf("Parse color item error <%s>\n", token.string);
ADDRGP4 $2023
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 3430
;3430:					return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1990
JUMPV
LABELV $2021
line 3432
;3431:				}
;3432:				colorIdx++;
ADDRLP4 1040
ADDRLP4 1040
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 3433
;3433:			}
LABELV $2017
line 3434
;3434:		}
LABELV $2002
line 3435
;3435:	}
LABELV $1997
line 3394
ADDRGP4 $1996
JUMPV
line 3436
;3436:	return qfalse;
CNSTI4 0
RETI4
LABELV $1990
endproc parseColorItem 1064 12
proc parse_one_gameType_icons 12 8
line 3440
;3437:}
;3438:
;3439:
;3440:static qboolean parse_one_gameType_icons(int handle, int GameTypeIdx) {
line 3442
;3441:	const char *s;
;3442:	if (!PC_String_Parse(handle, &s)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $2026
line 3443
;3443:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2025
JUMPV
LABELV $2026
line 3446
;3444:	}
;3445:
;3446:	cgs.media.gameTypeShader[GameTypeIdx] = trap_R_RegisterShaderNoMip(s);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 trap_R_RegisterShaderNoMip
CALLI4
ASGNI4
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cgs+150560+312
ADDP4
ADDRLP4 8
INDIRI4
ASGNI4
line 3447
;3447:	return qtrue;
CNSTI4 1
RETI4
LABELV $2025
endproc parse_one_gameType_icons 12 8
export parse_gameType_icons
proc parse_gameType_icons 1064 12
line 3451
;3448:}
;3449:
;3450:// parse GameTypeIcons
;3451:qboolean parse_gameType_icons(int handle) {
line 3456
;3452:	pc_token_t token;
;3453:	cvarTest_keywordHash_t *key;
;3454:	int GameTypeIdx;
;3455:
;3456:	if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $2031
line 3457
;3457:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2030
JUMPV
LABELV $2031
line 3460
;3458:	}
;3459:
;3460:	if (*token.string != '{') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 123
EQI4 $2033
line 3461
;3461:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2030
JUMPV
LABELV $2033
line 3464
;3462:	}
;3463:
;3464:	GameTypeIdx = 0;
ADDRLP4 1040
CNSTI4 0
ASGNI4
ADDRGP4 $2037
JUMPV
LABELV $2036
line 3466
;3465:
;3466:	while (1) {
line 3468
;3467:		// we can't unread token, so we check last token on parse error
;3468:		if (itemEnd)
ADDRGP4 itemEnd
INDIRI4
CNSTI4 0
EQI4 $2039
line 3469
;3469:		{
line 3470
;3470:			itemEnd = qfalse;
ADDRGP4 itemEnd
CNSTI4 0
ASGNI4
line 3471
;3471:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2030
JUMPV
LABELV $2039
line 3474
;3472:		}
;3473:
;3474:		if (needCacheToken)
ADDRGP4 needCacheToken
INDIRI4
CNSTI4 0
EQI4 $2041
line 3475
;3475:		{
line 3476
;3476:			if (*cacheTokenStr == ';' || *cacheTokenStr == ',') {
ADDRLP4 1052
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 59
EQI4 $2045
ADDRLP4 1052
INDIRI4
CNSTI4 44
NEI4 $2043
LABELV $2045
line 3477
;3477:				continue;
ADDRGP4 $2037
JUMPV
LABELV $2043
line 3479
;3478:			}
;3479:			key = cvarTest_KeywordHash_Find(cvarTest_KeywordHash, cacheTokenStr);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1056
ADDRGP4 cvarTest_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 1044
ADDRLP4 1056
INDIRP4
ASGNP4
line 3480
;3480:			resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3481
;3481:		}
ADDRGP4 $2042
JUMPV
LABELV $2041
line 3483
;3482:		else
;3483:		{
line 3484
;3484:			memset(&token, 0, sizeof(pc_token_t));
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1040
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3486
;3485:
;3486:			if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1052
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 0
NEI4 $2046
line 3487
;3487:				PC_SourceError(handle, "end of file inside hud file");
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $2008
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3488
;3488:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2030
JUMPV
LABELV $2046
line 3491
;3489:			}
;3490:
;3491:			if (*token.string == '}') { // exit the loop
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $2048
line 3492
;3492:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2030
JUMPV
LABELV $2048
line 3495
;3493:			}
;3494:
;3495:			if (*token.string == ';' || *token.string == ',') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
EQI4 $2055
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 44
NEI4 $2051
LABELV $2055
line 3496
;3496:				continue;
ADDRGP4 $2037
JUMPV
LABELV $2051
line 3499
;3497:			}
;3498:
;3499:			if (strcmp("background", token.string) == 0) {
ADDRGP4 $1876
ARGP4
ADDRLP4 0+16
ARGP4
ADDRLP4 1056
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1056
INDIRI4
CNSTI4 0
NEI4 $2056
line 3500
;3500:				if (!parse_one_gameType_icons(handle, GameTypeIdx)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 1040
INDIRI4
ARGI4
ADDRLP4 1060
ADDRGP4 parse_one_gameType_icons
CALLI4
ASGNI4
ADDRLP4 1060
INDIRI4
CNSTI4 0
NEI4 $2059
line 3501
;3501:					Com_Printf("GameTypeIcons parse error\n");
ADDRGP4 $2061
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 3502
;3502:					return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2030
JUMPV
LABELV $2059
line 3504
;3503:				}
;3504:				GameTypeIdx++;
ADDRLP4 1040
ADDRLP4 1040
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 3505
;3505:			}
LABELV $2056
line 3506
;3506:		}
LABELV $2042
line 3507
;3507:	}
LABELV $2037
line 3466
ADDRGP4 $2036
JUMPV
line 3508
;3508:	return qfalse;
CNSTI4 0
RETI4
LABELV $2030
endproc parse_gameType_icons 1064 12
proc parse_specifics 36 12
line 3511
;3509:}
;3510:
;3511:static qboolean parse_specifics(int handle, pc_token_t *token) {
line 3515
;3512:	specifics_keywordHash_t *key;
;3513:
;3514:	// Check if non-HUD part
;3515:	key = specifics_items_KeywordHash_Find(specifics_KeywordHash, token->string);
ADDRGP4 specifics_KeywordHash
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 4
ADDRGP4 specifics_items_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 3516
;3516:	if (!key) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2063
line 3517
;3517:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2062
JUMPV
LABELV $2063
line 3520
;3518:	}
;3519:
;3520:	if (strcmp("SetCvar", token->string) == 0) {
ADDRGP4 $1829
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $2065
line 3521
;3521:		script_Parse(handle);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 script_Parse
CALLI4
pop
line 3522
;3522:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2062
JUMPV
LABELV $2065
line 3524
;3523:	}
;3524:	else if (strcmp("INFO", token->string) == 0) {
ADDRGP4 $1828
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 12
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $2067
line 3526
;3525:		// 'INFO' properties are only needed in UIGAME 
;3526:		skipItem(handle);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 skipItem
CALLI4
pop
line 3527
;3527:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2062
JUMPV
LABELV $2067
line 3529
;3528:	}
;3529:	else if (strcmp("HealthColors", token->string) == 0) {
ADDRGP4 $1362
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 16
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $2069
line 3530
;3530:		parseColorItem(handle, health_colors);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 health_colors
ARGP4
ADDRGP4 parseColorItem
CALLI4
pop
line 3531
;3531:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2062
JUMPV
LABELV $2069
line 3533
;3532:	}
;3533:	else if (strcmp("ArmorColors", token->string) == 0) {
ADDRGP4 $1363
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 20
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $2071
line 3534
;3534:		parseColorItem(handle, armor_colors);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 armor_colors
ARGP4
ADDRGP4 parseColorItem
CALLI4
pop
line 3535
;3535:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2062
JUMPV
LABELV $2071
line 3537
;3536:	}
;3537:	else if (strcmp("AmmoColors", token->string) == 0) {
ADDRGP4 $1364
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 24
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $2073
line 3538
;3538:		parseColorItem(handle, ammo_colors);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 ammo_colors
ARGP4
ADDRGP4 parseColorItem
CALLI4
pop
line 3539
;3539:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2062
JUMPV
LABELV $2073
line 3541
;3540:	}
;3541:	else if (strcmp("TeamsColors", token->string) == 0) {
ADDRGP4 $1365
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 28
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $2075
line 3542
;3542:		parseColorItem(handle, teams_colors);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 teams_colors
ARGP4
ADDRGP4 parseColorItem
CALLI4
pop
line 3543
;3543:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2062
JUMPV
LABELV $2075
line 3545
;3544:	}
;3545:	else if (strcmp("GameTypeIcons", token->string) == 0) {
ADDRGP4 $1830
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 32
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $2077
line 3546
;3546:		parse_gameType_icons(handle);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 parse_gameType_icons
CALLI4
pop
line 3547
;3547:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2062
JUMPV
LABELV $2077
line 3549
;3548:	}
;3549:	else {
line 3550
;3550:		PC_SourceError(handle, "unknown specific_items keyword %s \n", token->string);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $2079
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3551
;3551:		return qfalse;
CNSTI4 0
RETI4
LABELV $2062
endproc parse_specifics 36 12
proc parse_dynamics 12 8
line 3557
;3552:	}
;3553:}
;3554:
;3555:static const struct item_t EmptyItem;
;3556:
;3557:static qboolean parse_dynamics(int handle, pc_token_t *token) {
line 3561
;3558:	dyn_items_keywordHash_t *key;
;3559:
;3560:	// Check if non-HUD part
;3561:	key = dyn_items_KeywordHash_Find(dyn_KeywordHash, token->string);
ADDRGP4 dyn_KeywordHash
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 4
ADDRGP4 dyn_items_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 3562
;3562:	if (!key) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2081
line 3563
;3563:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2080
JUMPV
LABELV $2081
line 3565
;3564:	}
;3565:	else {
line 3566
;3566:		dyn_itemArray[dyn_itemCount] = EmptyItem;
ADDRGP4 dyn_itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray
ADDP4
ADDRGP4 EmptyItem
INDIRB
ASGNB 1212
line 3569
;3567:
;3568:		// in order to find parent index
;3569:		dyn_itemArray[dyn_itemCount].order = itemCount;
ADDRGP4 dyn_itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray+1024
ADDP4
ADDRGP4 itemCount
INDIRI4
ASGNI4
line 3572
;3570:
;3571:		// keep item name (may be overwritten by name property)
;3572:		strcpy(dyn_itemArray[dyn_itemCount].item_name, token->string);
ADDRGP4 dyn_itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray
ADDP4
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 3575
;3573:
;3574:		// associate with index, by using pointer
;3575:		*key->idx = dyn_itemCount;
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ADDRGP4 dyn_itemCount
INDIRI4
ASGNI4
line 3578
;3576:
;3577:		// item matched, parse its properties
;3578:		itemProperties_Parse(&dyn_itemArray[dyn_itemCount], handle);
ADDRGP4 dyn_itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray
ADDP4
ARGP4
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 itemProperties_Parse
CALLI4
pop
line 3580
;3579:
;3580:		dyn_itemCount++;
ADDRLP4 8
ADDRGP4 dyn_itemCount
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 3581
;3581:		return qtrue;
CNSTI4 1
RETI4
LABELV $2080
endproc parse_dynamics 12 8
export HUDitems_Parse
proc HUDitems_Parse 1072 12
line 3586
;3582:	}
;3583:}
;3584:
;3585:
;3586:qboolean HUDitems_Parse( int handle ) {
line 3591
;3587:	pc_token_t token;
;3588:	items_keywordHash_t *key;
;3589:
;3590:	// clear the HUD items arrays
;3591:	memset(&itemArray, 0, sizeof(itemArray));
ADDRGP4 itemArray
ARGP4
CNSTI4 0
ARGI4
CNSTI4 310272
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3592
;3592:	memset(&dyn_itemArray, 0, sizeof(dyn_itemArray));
ADDRGP4 dyn_itemArray
ARGP4
CNSTI4 0
ARGI4
CNSTI4 310272
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3593
;3593:	itemCount = dyn_itemCount = 0;
ADDRLP4 1044
CNSTI4 0
ASGNI4
ADDRGP4 dyn_itemCount
ADDRLP4 1044
INDIRI4
ASGNI4
ADDRGP4 itemCount
ADDRLP4 1044
INDIRI4
ASGNI4
ADDRGP4 $2086
JUMPV
LABELV $2085
line 3595
;3594:
;3595:	while (1) {
line 3596
;3596:		memset(&token, 0, sizeof(pc_token_t));
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1040
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3598
;3597:
;3598:		if ( !trap_PC_ReadToken( handle, &token ) ) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $2088
line 3599
;3599:			if ( *token.string == '#' )
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 35
NEI4 $2090
line 3600
;3600:				return qfalse; // stop on preprocessor error
CNSTI4 0
RETI4
ADDRGP4 $2084
JUMPV
LABELV $2090
line 3602
;3601:			
;3602:			return qtrue; // EOF
CNSTI4 1
RETI4
ADDRGP4 $2084
JUMPV
LABELV $2088
line 3605
;3603:		}
;3604:
;3605:		if (*token.string == '}') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $2093
line 3606
;3606:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2084
JUMPV
LABELV $2093
line 3609
;3607:		}
;3608:
;3609:		if (*token.string == '{') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 123
NEI4 $2096
line 3610
;3610:			continue;
ADDRGP4 $2086
JUMPV
LABELV $2096
line 3613
;3611:		}
;3612:		// std separators
;3613:		else if (*token.string == ',' || *token.string == ';') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 44
EQI4 $2103
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
NEI4 $2099
LABELV $2103
line 3614
;3614:			continue;
ADDRGP4 $2086
JUMPV
LABELV $2099
line 3617
;3615:		}
;3616:		// CPMA compatibility (not anymore compatible)
;3617:		else if (*token.string == '!') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 33
NEI4 $2104
line 3618
;3618:			continue;
ADDRGP4 $2086
JUMPV
LABELV $2104
line 3621
;3619:		}
;3620:
;3621:		if (parse_specifics(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1052
ADDRGP4 parse_specifics
CALLI4
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 0
EQI4 $2107
line 3622
;3622:			continue;
ADDRGP4 $2086
JUMPV
LABELV $2107
line 3625
;3623:		}
;3624:
;3625:		if (parse_dynamics(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1056
ADDRGP4 parse_dynamics
CALLI4
ASGNI4
ADDRLP4 1056
INDIRI4
CNSTI4 0
EQI4 $2109
line 3626
;3626:			continue;
ADDRGP4 $2086
JUMPV
LABELV $2109
line 3629
;3627:		}
;3628:
;3629:		key = items_KeywordHash_Find(items_KeywordHash, token.string);
ADDRGP4 items_KeywordHash
ARGP4
ADDRLP4 0+16
ARGP4
ADDRLP4 1060
ADDRGP4 items_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 1040
ADDRLP4 1060
INDIRP4
ASGNP4
line 3631
;3630:
;3631:		if ( !key ) {
ADDRLP4 1040
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2112
line 3632
;3632:			PC_SourceError(handle, "unknown HUD keyword item %s \n", token.string);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $2114
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3633
;3633:			continue;
ADDRGP4 $2086
JUMPV
LABELV $2112
line 3635
;3634:		}
;3635:		else {
line 3636
;3636:			itemArray[itemCount] = EmptyItem;
ADDRGP4 itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray
ADDP4
ADDRGP4 EmptyItem
INDIRB
ASGNB 1212
line 3639
;3637:
;3638:			// in order to find parent index
;3639:			itemArray[itemCount].order = itemCount;
ADDRLP4 1064
ADDRGP4 itemCount
INDIRI4
ASGNI4
ADDRLP4 1064
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray+1024
ADDP4
ADDRLP4 1064
INDIRI4
ASGNI4
line 3642
;3640:
;3641:			// keep item name (may be overwritten by name property)
;3642:			strcpy(itemArray[itemCount].item_name, token.string);
ADDRGP4 itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray
ADDP4
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 3645
;3643:			
;3644:			// item matched, parse its properties
;3645:			itemProperties_Parse(&itemArray[itemCount], handle);
ADDRGP4 itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray
ADDP4
ARGP4
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 itemProperties_Parse
CALLI4
pop
line 3648
;3646:
;3647:			// use pointer to associate specific draw function with item
;3648:			itemArray[itemCount].DrawItem = *key->draw_item;
ADDRGP4 itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray+1208
ADDP4
ADDRLP4 1040
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ASGNP4
line 3650
;3649:
;3650:			itemCount++;
ADDRLP4 1068
ADDRGP4 itemCount
ASGNP4
ADDRLP4 1068
INDIRP4
ADDRLP4 1068
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 3651
;3651:		}
line 3652
;3652:	}
LABELV $2086
line 3595
ADDRGP4 $2085
JUMPV
line 3653
;3653:	return qfalse;
CNSTI4 0
RETI4
LABELV $2084
endproc HUDitems_Parse 1072 12
export HUD_FullParse
proc HUD_FullParse 20 8
line 3657
;3654:}
;3655:
;3656:
;3657:qboolean HUD_FullParse( const char *filePath ) {
line 3661
;3658:	int handle;
;3659:	qboolean res;
;3660:
;3661:	resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3663
;3662:
;3663:	Com_Printf("<%s> loading... \n", filePath);
ADDRGP4 $2120
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 3665
;3664:
;3665:	handle = trap_PC_LoadSource( filePath );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 trap_PC_LoadSource
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRI4
ASGNI4
line 3667
;3666:
;3667:	if ( !handle ) {
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $2121
line 3668
;3668:		Com_Printf("HUD file not found <%s>\n", filePath);
ADDRGP4 $2123
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 3669
;3669:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2119
JUMPV
LABELV $2121
line 3672
;3670:	}
;3671:	
;3672:	res = HUDitems_Parse( handle );
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUDitems_Parse
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 3674
;3673:
;3674:	if (res) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $2124
line 3675
;3675:		loadedHUDfilePath = String_Alloc(filePath);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 String_Alloc
CALLP4
ASGNP4
ADDRGP4 loadedHUDfilePath
ADDRLP4 16
INDIRP4
ASGNP4
line 3676
;3676:	}
LABELV $2124
line 3678
;3677:
;3678:	trap_PC_FreeSource(handle);
ADDRLP4 0
INDIRI4
ARGI4
ADDRGP4 trap_PC_FreeSource
CALLI4
pop
line 3679
;3679:	return res;
ADDRLP4 4
INDIRI4
RETI4
LABELV $2119
endproc HUD_FullParse 20 8
export CG_CheckHUD
proc CG_CheckHUD 1036 12
line 3690
;3680:}
;3681:
;3682:
;3683:/*
;3684:=================
;3685:CG_Load_Selected_HUD()
;3686:read cvar_t 'cg_hudFiles'
;3687:and load HUD
;3688:=================
;3689:*/
;3690:qboolean CG_CheckHUD( void ) {
line 3694
;3691:	char buff[1024];
;3692:	char *hudSet;
;3693:
;3694:	memset(buff, 0, sizeof(buff));
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1024
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3696
;3695:
;3696:	trap_Cvar_VariableStringBuffer("cg_hudFiles", buff, sizeof(buff));
ADDRGP4 $2127
ARGP4
ADDRLP4 0
ARGP4
CNSTI4 1024
ARGI4
ADDRGP4 trap_Cvar_VariableStringBuffer
CALLV
pop
line 3697
;3697:	hudSet = buff;
ADDRLP4 1024
ADDRLP4 0
ASGNP4
line 3698
;3698:	if (hudSet[0] == '\0') {
ADDRLP4 1024
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $2128
line 3699
;3699:		hudSet = DEFAULT_HUD;
ADDRLP4 1024
ADDRGP4 $2130
ASGNP4
line 3700
;3700:	}
LABELV $2128
line 3703
;3701:
;3702:	// don't load anything if same HUD
;3703:	if (strcmp(loadedHUDfilePath, hudSet) == 0) {
ADDRGP4 loadedHUDfilePath
INDIRP4
ARGP4
ADDRLP4 1024
INDIRP4
ARGP4
ADDRLP4 1028
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1028
INDIRI4
CNSTI4 0
NEI4 $2131
line 3704
;3704:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2126
JUMPV
LABELV $2131
line 3708
;3705:	}
;3706:
;3707:	// load HUD
;3708:	return HUD_FullParse( hudSet );
ADDRLP4 1024
INDIRP4
ARGP4
ADDRLP4 1032
ADDRGP4 HUD_FullParse
CALLI4
ASGNI4
ADDRLP4 1032
INDIRI4
RETI4
LABELV $2126
endproc CG_CheckHUD 1036 12
export String_Init
proc String_Init 4 0
line 3717
;3709:}
;3710:
;3711:
;3712:/*
;3713:=================
;3714:String_Init
;3715:=================
;3716:*/
;3717:void String_Init(void) {
line 3719
;3718:	int i;
;3719:	for (i = 0; i < HASH_TABLE_SIZE; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $2134
line 3720
;3720:		strHandle[i] = NULL;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 strHandle
ADDP4
CNSTP4 0
ASGNP4
line 3721
;3721:	}
LABELV $2135
line 3719
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 2048
LTI4 $2134
line 3722
;3722:	strHandleCount = 0;
ADDRGP4 strHandleCount
CNSTI4 0
ASGNI4
line 3723
;3723:	strPoolIndex = 0;
ADDRGP4 strPoolIndex
CNSTI4 0
ASGNI4
line 3724
;3724:	UI_InitMemory();
ADDRGP4 UI_InitMemory
CALLV
pop
line 3727
;3725:	// done once, but as we want to go fast,
;3726:	// we use keyword hash tables
;3727:	items_SetupKeywordHash();
ADDRGP4 items_SetupKeywordHash
CALLV
pop
line 3728
;3728:	specifics_items_SetupKeywordHash();
ADDRGP4 specifics_items_SetupKeywordHash
CALLV
pop
line 3729
;3729:	dyn_items_SetupKeywordHash();
ADDRGP4 dyn_items_SetupKeywordHash
CALLV
pop
line 3730
;3730:	prop_SetupKeywordHash();
ADDRGP4 prop_SetupKeywordHash
CALLV
pop
line 3731
;3731:	flag_SetupKeywordHash();
ADDRGP4 flag_SetupKeywordHash
CALLV
pop
line 3732
;3732:	cvarTest_SetupKeywordHash();
ADDRGP4 cvarTest_SetupKeywordHash
CALLV
pop
line 3733
;3733:	GT_Vis_SetupKeywordHash();
ADDRGP4 GT_Vis_SetupKeywordHash
CALLV
pop
line 3734
;3734:	value_SetupKeywordHash();
ADDRGP4 value_SetupKeywordHash
CALLV
pop
line 3735
;3735:}
LABELV $2133
endproc String_Init 4 0
data
align 4
LABELV $2139
address $87
export String_Alloc
code
proc String_Alloc 40 8
line 3743
;3736:
;3737:
;3738:/*
;3739:=================
;3740:String_Alloc
;3741:=================
;3742:*/
;3743:const char *String_Alloc( const char *p ) {
line 3749
;3744:	int len;
;3745:	unsigned hash;
;3746:	stringDef_t *str, *last;
;3747:	static const char *staticNULL = "";
;3748:
;3749:	if (p == NULL) {
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2140
line 3750
;3750:		return NULL;
CNSTP4 0
RETP4
ADDRGP4 $2138
JUMPV
LABELV $2140
line 3753
;3751:	}
;3752:
;3753:	if (*p == 0) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $2142
line 3754
;3754:		return staticNULL;
ADDRGP4 $2139
INDIRP4
RETP4
ADDRGP4 $2138
JUMPV
LABELV $2142
line 3757
;3755:	}
;3756:
;3757:	hash = hashForString(p);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 hashForString
CALLU4
ASGNU4
ADDRLP4 8
ADDRLP4 16
INDIRU4
ASGNU4
line 3759
;3758:
;3759:	str = strHandle[hash];
ADDRLP4 0
ADDRLP4 8
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 strHandle
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $2145
JUMPV
LABELV $2144
line 3760
;3760:	while (str) {
line 3761
;3761:		if (strcmp(p, str->str) == 0) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $2147
line 3762
;3762:			return str->str;
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
RETP4
ADDRGP4 $2138
JUMPV
LABELV $2147
line 3764
;3763:		}
;3764:		str = str->next;
ADDRLP4 0
ADDRLP4 0
INDIRP4
INDIRP4
ASGNP4
line 3765
;3765:	}
LABELV $2145
line 3760
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2144
line 3767
;3766:
;3767:	len = strlen(p);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strlen
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 20
INDIRI4
ASGNI4
line 3768
;3768:	if (len + strPoolIndex + 1 < STRING_POOL_SIZE) {
ADDRLP4 12
INDIRI4
ADDRGP4 strPoolIndex
INDIRI4
ADDI4
CNSTI4 1
ADDI4
CNSTI4 65536
GEI4 $2149
line 3769
;3769:		int ph = strPoolIndex;
ADDRLP4 24
ADDRGP4 strPoolIndex
INDIRI4
ASGNI4
line 3770
;3770:		strcpy(&strPool[strPoolIndex], p);
ADDRGP4 strPoolIndex
INDIRI4
ADDRGP4 strPool
ADDP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 3771
;3771:		strPoolIndex += len + 1;
ADDRLP4 28
ADDRGP4 strPoolIndex
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRI4
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ADDI4
ASGNI4
line 3773
;3772:
;3773:		str = strHandle[hash];
ADDRLP4 0
ADDRLP4 8
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 strHandle
ADDP4
INDIRP4
ASGNP4
line 3774
;3774:		last = str;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRGP4 $2152
JUMPV
LABELV $2151
line 3775
;3775:		while (str && str->next) {
line 3776
;3776:			last = str;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
line 3777
;3777:			str = str->next;
ADDRLP4 0
ADDRLP4 0
INDIRP4
INDIRP4
ASGNP4
line 3778
;3778:		}
LABELV $2152
line 3775
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $2154
ADDRLP4 0
INDIRP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2151
LABELV $2154
line 3780
;3779:
;3780:		str = HUD_Alloc(sizeof(stringDef_t));
CNSTI4 8
ARGI4
ADDRLP4 36
ADDRGP4 HUD_Alloc
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 36
INDIRP4
ASGNP4
line 3781
;3781:		if (!str) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2155
line 3782
;3782:			return NULL;
CNSTP4 0
RETP4
ADDRGP4 $2138
JUMPV
LABELV $2155
line 3784
;3783:		}
;3784:		str->next = NULL;
ADDRLP4 0
INDIRP4
CNSTP4 0
ASGNP4
line 3785
;3785:		str->str = &strPool[ph];
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 24
INDIRI4
ADDRGP4 strPool
ADDP4
ASGNP4
line 3786
;3786:		if (last) {
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $2157
line 3787
;3787:			last->next = str;
ADDRLP4 4
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 3788
;3788:		}
ADDRGP4 $2158
JUMPV
LABELV $2157
line 3789
;3789:		else {
line 3790
;3790:			strHandle[hash] = str;
ADDRLP4 8
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 strHandle
ADDP4
ADDRLP4 0
INDIRP4
ASGNP4
line 3791
;3791:		}
LABELV $2158
line 3792
;3792:		return &strPool[ph];
ADDRLP4 24
INDIRI4
ADDRGP4 strPool
ADDP4
RETP4
ADDRGP4 $2138
JUMPV
LABELV $2149
line 3794
;3793:	}
;3794:	return NULL;
CNSTP4 0
RETP4
LABELV $2138
endproc String_Alloc 40 8
bss
align 4
LABELV EmptyItem
skip 1212
export prop_KeywordHash
align 4
LABELV prop_KeywordHash
skip 2048
export dyn_KeywordHash
align 4
LABELV dyn_KeywordHash
skip 2048
export specifics_KeywordHash
align 4
LABELV specifics_KeywordHash
skip 2048
export items_KeywordHash
align 4
LABELV items_KeywordHash
skip 2048
export GT_Vis_KeywordHash
align 4
LABELV GT_Vis_KeywordHash
skip 2048
export value_KeywordHash
align 4
LABELV value_KeywordHash
skip 2048
export flag_KeywordHash
align 4
LABELV flag_KeywordHash
skip 2048
export cvarTest_KeywordHash
align 4
LABELV cvarTest_KeywordHash
skip 2048
export cacheTokenStr
align 4
LABELV cacheTokenStr
skip 4
export propertyEnd
align 4
LABELV propertyEnd
skip 4
export itemEnd
align 4
LABELV itemEnd
skip 4
export needCacheToken
align 4
LABELV needCacheToken
skip 4
align 4
LABELV strHandle
skip 8192
align 1
LABELV strPool
skip 65536
import CG_Cvar_Get
align 4
LABELV outOfMemory
skip 4
align 4
LABELV allocPoint
skip 4
align 1
LABELV memoryPool
skip 131072
import trap_R_AddLinearLightToScene
import trap_R_AddRefEntityToScene2
import linearLight
import intShaderTime
import CG_NewParticleArea
import initparticles
import CG_ParticleExplosion
import CG_ParticleMisc
import CG_ParticleDust
import CG_ParticleSparks
import CG_ParticleBulletDebris
import CG_ParticleSnowFlurry
import CG_AddParticleShrapnel
import CG_ParticleSmoke
import CG_ParticleSnow
import CG_AddParticles
import CG_ClearParticles
import trap_GetEntityToken
import trap_getCameraInfo
import trap_startCamera
import trap_loadCamera
import trap_SnapVector
import trap_CIN_SetExtents
import trap_CIN_DrawCinematic
import trap_CIN_RunCinematic
import trap_CIN_StopCinematic
import trap_CIN_PlayCinematic
import trap_Key_GetKey
import trap_Key_SetCatcher
import trap_Key_GetCatcher
import trap_Key_IsDown
import trap_R_RegisterFont
import trap_MemoryRemaining
import testPrintFloat
import testPrintInt
import trap_SetUserCmdValue
import trap_GetUserCmd
import trap_GetCurrentCmdNumber
import trap_GetServerCommand
import trap_GetSnapshot
import trap_GetCurrentSnapshotNumber
import trap_GetGameState
import trap_GetGlconfig
import trap_VR_KeepLeftAngles
import trap_VR_keepLeftMuzzlePos
import trap_VR_KeepSpawnAngles
import trap_VR_KeepRightAngles
import trap_VR_keepRightMuzzlePos
import CG_ChangeFrameResolution
import trap_R_RenderHUD
import trap_R_inPVS
import trap_R_RemapShader
import trap_R_LerpTag
import trap_R_ModelBounds
import trap_R_DrawStretchPic
import trap_R_SetColor
import trap_R_RenderScene
import trap_R_LightForPoint
import trap_R_AddAdditiveLightToScene
import trap_R_AddLightToScene
import trap_R_AddPolysToScene
import trap_R_AddPolyToScene
import trap_R_AddRefEntityToScene
import trap_R_ClearScene
import trap_R_RegisterShaderNoMip
import trap_R_RegisterShader
import trap_R_RegisterSkin
import trap_R_RegisterModel
import trap_R_LoadWorldMap
import trap_S_StopBackgroundTrack
import trap_S_StartBackgroundTrack
import trap_S_RegisterSound
import trap_S_Respatialize
import trap_S_UpdateEntityPosition
import trap_S_AddRealLoopingSound
import trap_S_AddLoopingSound
import trap_S_ClearLoopingSounds
import trap_S_StartLocalSound
import trap_S_StopLoopingSound
import trap_S_StartSound
import trap_CM_MarkFragments
import trap_CM_TransformedCapsuleTrace
import trap_CM_TransformedBoxTrace
import trap_CM_CapsuleTrace
import trap_CM_BoxTrace
import trap_CM_TransformedPointContents
import trap_CM_PointContents
import trap_CM_TempBoxModel
import trap_CM_InlineModel
import trap_CM_NumInlineModels
import trap_CM_LoadMap
import trap_UpdateScreen
import trap_SendClientCommand
import trap_RemoveCommand
import trap_AddCommand
import trap_RealTime
import trap_SendConsoleCommand
import trap_FS_Seek
import trap_FS_FCloseFile
import trap_FS_Write
import trap_FS_Read
import trap_FS_FOpenFile
import trap_Args
import trap_Argv
import trap_Argc
import trap_Cvar_VariableValue
import trap_Cvar_VariableStringBuffer
import trap_Cvar_Set
import trap_Cvar_Update
import trap_Cvar_Register
import trap_Milliseconds
import trap_Error
import trap_Print
import CG_VR_Keyboard
import CG_VR_Menu
import CG_CheckChangedPredictableEvents
import CG_TransitionPlayerState
import CG_Respawn
import CG_PlayBufferedVoiceChats
import CG_VoiceChatLocal
import CG_LoadVoiceChats
import CG_ShaderStateChanged
import CG_SetConfigValues
import CG_ParseSysteminfo
import CG_ParseServerinfo
import CG_ExecuteNewServerCommands
import CG_InitConsoleCommands
import CG_ConsoleCommand
import CG_ScoreboardClick
import CG_DrawOldTourneyScoreboard
import CG_DrawOldScoreboard
import CG_DrawInformation
import CG_LoadingClient
import CG_LoadingItem
import CG_LoadingString
import CG_ProcessSnapshots
import CG_MakeExplosion
import CG_Bleed
import CG_BigExplode
import CG_GibPlayer
import CG_ScorePlum
import CG_SpawnEffect
import CG_BubbleTrail
import CG_SmokePuff
import CG_AddLocalEntities
import CG_AllocLocalEntity
import CG_InitLocalEntities
import CG_ImpactMark
import CG_AddMarks
import CG_InitMarkPolys
import CG_OutOfAmmoChange
import CG_DrawWeaponSelect_V
import CG_DrawWeaponSelect_H
import CG_DrawCrosshair3D
import CG_GetPlayerWeaponAxis
import CG_AddPlayerWeapon
import CG_AddViewWeapon
import CG_GrappleTrail
import CG_RailTrail
import CG_Bullet
import CG_ShotgunFire
import CG_MissileHitPlayer
import CG_MissileHitWall
import CG_FireWeapon
import CG_RegisterItemVisuals
import CG_RegisterWeapon
import CG_LaserNeeded
import CG_LaserSight
import CG_CalculateWeaponPosition
import CG_DrawWeaponSelector
import CG_WeaponSelectorSelect_f
import CG_Weapon_f
import CG_PrevWeapon_f
import CG_NextWeapon_f
import CG_PositionRotatedEntityOnTag
import CG_PositionEntityOnTag
import CG_AdjustPositionForMover
import CG_Beam
import CG_AddPacketEntities
import CG_SetEntitySoundPosition
import CG_PainEvent
import CG_EntityEvent
import CG_PlaceString
import CG_CheckEvents
import CG_PlayDroppedEvents
import CG_LoadDeferredPlayers
import CG_PredictPlayerState
import CG_Trace
import CG_PointContents
import CG_BuildSolidList
import CG_CustomSound
import CG_GetModelHeight
import CG_NewClientInfo
import CG_AddRefEntityWithPowerups
import CG_ResetPlayerEntity
import CG_Player
import CG_TrackClientTeamChange
import CG_ForceModelChange
import CG_ShowResponseHead
import CG_Draw3DModel
import CG_Text_Height
import CG_Text_Width
import CG_Text_Paint
import CG_DrawTeamBackground
import CG_DrawFlagModel
import CG_DrawActive
import CG_DrawHead
import CG_CenterPrint
import CG_AddLagometerSnapshotInfo
import CG_AddLagometerFrameInfo
import teamChat2
import teamChat1
import systemChat
import drawTeamOverlayModificationCount
import numSortedTeamPlayers
import sortedTeamPlayers
import CG_SelectFont
import CG_LoadFonts
import CG_DrawString
import CG_DrawTopBottom
import CG_DrawSides
import CG_DrawRect
import UI_DrawProportionalString
import CG_GetColorForHealth
import CG_ColorForHealth
import CG_TileClear
import CG_TeamColor
import CG_FadeColorTime
import CG_FadeColor
import CG_DrawStrlen
import CG_DrawStringExt
import CG_DrawGradientPic
import CG_DrawPic
import CG_FillScreen
import CG_FillRect
import CG_AdjustFrom640
import CG_DrawActiveFrame
import CG_AddBufferedSound
import CG_ZoomUp_f
import CG_ZoomDown_f
import CG_TestModelPrevSkin_f
import CG_TestModelNextSkin_f
import CG_TestModelPrevFrame_f
import CG_TestModelNextFrame_f
import CG_TestGun_f
import CG_TestModel_f
import CG_SetScoreCatcher
import CG_BuildSpectatorString
import CG_SetScoreSelection
import CG_RankRunFrame
import CG_EventHandling
import CG_MouseEvent
import CG_KeyEvent
import CG_LoadMenus
import CG_LastAttacker
import CG_CrosshairPlayer
import CG_UpdateCvars
import CG_StartMusic
import CG_Error
import CG_Printf
import CG_Argv
import CG_ConfigString
import laserBeam
import vr_controller_type
import menu_distance
import VR_angle_hide_torso
import VR_hide_torso
import showVirtualKeyboard
import eventnames
import cg_followKiller
import cg_fovAdjust
import cg_deadBodyDarken
import cg_teamColors
import cg_teamModel
import cg_enemyColors
import cg_enemyModel
import cg_hitSounds
import cg_currentSelectedPlayer
import cg_trueLightning
import cg_oldPlasma
import cg_oldRocket
import cg_oldRail
import cg_noProjectileTrail
import cg_noTaunt
import cg_bigFont
import cg_smallFont
import cg_cameraMode
import cg_timescale
import cg_timescaleFadeSpeed
import cg_timescaleFadeEnd
import cg_cameraOrbitDelay
import cg_cameraOrbit
import cg_smoothClients
import cg_allowDeathCam
import cg_itemTimer
import cg_scorePlum
import cg_noVoiceText
import cg_noVoiceChats
import cg_teamChatsOnly
import cg_drawFriend
import cg_deferPlayers
import cg_predictItems
import cg_blood
import cg_paused
import cg_buildScript
import cg_forceModel
import cg_stats
import cg_teamChatHeight
import cg_teamChatTime
import cg_drawSpeed
import cg_drawAttacker
import cg_drawPing
import cg_lagometer
import cg_thirdPerson
import cg_thirdPersonAngle
import cg_thirdPersonRange
import cg_zoomFov
import cg_fov
import cg_simpleItems
import cg_ignore
import cg_autoswitch
import cg_tracerLength
import cg_tracerWidth
import cg_tracerChance
import cg_viewsize
import cg_drawGun
import cg_gun_z
import cg_gun_y
import cg_gun_x
import cg_gun_frame
import cg_brassTime
import cg_addMarks
import cg_footsteps
import cg_showmiss
import cg_noPlayerAnims
import cg_nopredict
import cg_errorDecay
import cg_railTrailRadius
import cg_railTrailTime
import cg_debugEvents
import cg_debugPosition
import cg_debugAnim
import cg_animSpeed
import cg_draw2D
import cg_drawStatus
import cg_crosshairHealth
import cg_crosshairSize
import cg_crosshairY
import cg_crosshairX
import cg_drawWeaponSelect
import cg_teamOverlayUserinfo
import cg_drawTeamOverlay
import cg_drawRewards
import cg_drawCrosshairNames
import cg_drawCrosshair
import cg_drawAmmoWarning
import cg_drawIcons
import cg_draw3dIcons
import cg_drawSnapshot
import cg_drawFPS
import cg_drawTimer
import cg_gibs
import cg_shadows
import cg_swingSpeed
import cg_bobroll
import cg_bobpitch
import cg_bobup
import cg_runroll
import cg_runpitch
import cg_centertime
import cg_markPolys
import cg_items
import cg_weapons
import cg_entities
import cg
import cgs
import cg_weaponSelectorSimple2DIcons
import cg_debugWeaponAiming
import cg_fragMessage
import cg_playerShadow
import cg_weaponbob
import client_weapon
import CG_DrawAttacker_icon
import CG_DrawTeamPlayerPowerup
import CG_Draw_Icon_Ammo
import CG_Draw_Icon_Armor
import CG_DrawStatusBarHead
import playerTeam
import getPlayerHealth
import getPlayerLocation
import getTeamPlayerName
export FPS
align 4
LABELV FPS
skip 4
export TeamOverlay_Sel_idx
align 4
LABELV TeamOverlay_Sel_idx
skip 4
export ServerMsg_idx
align 4
LABELV ServerMsg_idx
skip 4
export ItemMsg_idx
align 4
LABELV ItemMsg_idx
skip 4
import Attacker_idx
export KillMsg_idx
align 4
LABELV KillMsg_idx
skip 4
export WarmFightMsg_idx
align 4
LABELV WarmFightMsg_idx
skip 4
export IcoPowerUp_idx
align 4
LABELV IcoPowerUp_idx
skip 4
export WeapListSelName_idx
align 4
LABELV WeapListSelName_idx
skip 4
export IcoWeapListSel_idx
align 4
LABELV IcoWeapListSel_idx
skip 4
export IcoWeapList_idx
align 4
LABELV IcoWeapList_idx
skip 4
import item_Keywords
export dyn_itemCount
align 4
LABELV dyn_itemCount
skip 4
export dyn_itemArray
align 4
LABELV dyn_itemArray
skip 310272
import itemCount
import itemArray
export teams_colors
align 4
LABELV teams_colors
skip 64
export ammo_colors
align 4
LABELV ammo_colors
skip 64
export armor_colors
align 4
LABELV armor_colors
skip 64
export health_colors
align 4
LABELV health_colors
skip 64
import VRMOD_IN_Button
import VRMOD_togglePlayerLaserBeam
import VRMOD_IN_Grab
import VRMOD_IN_Triggers
import VRMOD_IN_Joystick
import VRMOD_CL_MouseEvent
import VRMOD_CL_VRInit
import VRMOD_CL_KeepLeftAngles
import VRMOD_CL_KeepRightAngles
import VRMOD_CL_KeepRightPos
import VRMOD_CL_Finish_VR_Move
import VRMOD_CL_handle_controllers
import VRMOD_CL_Get_HMD_Position
import VRMOD_CL_Get_HMD_Angles
import VRMOD_CL_GestureCrouchCheck
import positional_movementForward
import positional_movementSideways
import BigEndian
import replace1
import Q_stradd
import Q_strcpy
import BG_StripColor
import BG_CleanName
import DecodedString
import EncodedString
import strtok
import Q_stristr
import BG_sprintf
import BG_PlayerTouchesItem
import BG_PlayerStateToEntityStateExtraPolate
import BG_PlayerStateToEntityState
import BG_TouchJumpPad
import BG_AddPredictableEventToPlayerstate
import BG_EvaluateTrajectoryDelta
import BG_EvaluateTrajectory
import BG_CanItemBeGrabbed
import BG_FindItemForHoldable
import BG_FindItemForPowerup
import BG_FindItemForWeapon
import BG_FindItem
import bg_numItems
import bg_itemlist
import Pmove
import PM_UpdateViewAngles
import Com_Printf
import Com_Error
import Info_NextPair
import Info_ValidateKeyValue
import Info_Validate
import Info_SetValueForKey_Big
import Info_SetValueForKey
import Info_ValueForKey
import va
import Q_CleanStr
import Q_PrintStrlen
import Q_strcat
import Q_strncpyz
import Q_strrchr
import Q_strupr
import Q_strlwr
import Q_stricmpn
import Q_strncmp
import Q_stricmp
import Q_isalpha
import Q_isupper
import Q_islower
import Q_isprint
import locase
import trap_PC_FreeSource
import trap_PC_LoadSource
import trap_PC_ReadToken
import trap_PC_SourceFileAndLine
import Com_sprintf
import Parse3DMatrix
import Parse2DMatrix
import Parse1DMatrix
import SkipRestOfLine
import SkipBracedSection
import COM_MatchToken
import Com_Split
import COM_ParseSep
import Com_InitSeparators
import SkipTillSeparators
import COM_ParseWarning
import COM_ParseError
import COM_Compress
import COM_ParseExt
import COM_Parse
import COM_GetCurrentParseLine
import COM_BeginParseSession
import COM_DefaultExtension
import COM_StripExtension
import COM_SkipPath
import hex_to_color
import Com_Clamp
import PerpendicularVector
import AngleVectors
import MatrixMultiply
import MakeNormalVectors
import RotateAroundDirection
import RotatePointAroundVector
import ProjectPointOnPlane
import PlaneFromPoints
import AngleDelta
import AngleNormalize180
import AngleNormalize360
import AnglesSubtract
import AngleSubtract
import LerpAngle
import AngleMod
import BoxOnPlaneSide
import SetPlaneSignbits
import AxisCopy
import AxisClear
import AnglesToAxis
import vectoangles
import Q_crandom
import Q_random
import Q_rand
import Q_acos
import Q_log2
import VectorRotate
import Vector4Scale
import VectorNormalize2
import VectorNormalize
import CrossProduct
import VectorInverse
import VectorNormalizeFast
import DistanceSquared
import Distance
import VectorLengthSquared
import VectorLength
import VectorCompare
import AddPointToBounds
import ClearBounds
import RadiusFromBounds
import NormalizeColor
import ColorBytes4
import ColorBytes3
import _VectorMA
import _VectorScale
import _VectorCopy
import _VectorAdd
import _VectorSubtract
import _DotProduct
import ByteToDir
import DirToByte
import ClampFloat
import ClampShort
import ClampChar
import Q_rsqrt
import Q_fabs
import axisDefault
import vec3_origin
import g_color_table
import colorDkGrey
import colorMdGrey
import colorLtGrey
import colorWhite
import colorCyan
import colorMagenta
import colorYellow
import colorBlue
import colorGreen
import colorRed
import colorBlack
import bytedirs
import Hunk_Alloc
import acos
import fabs
import abs
import tan
import atan2
import cos
import sin
import sqrt
import floor
import ceil
import memcpy
import memset
import memmove
import Q_sscanf
import ED_vsprintf
import atoi
import atof
import toupper
import tolower
import strncpy
import strstr
import strchr
import strcmp
import strcpy
import strcat
import strlen
import rand
import srand
import qsort
lit
align 1
LABELV $2130
byte 1 104
byte 1 117
byte 1 100
byte 1 47
byte 1 104
byte 1 117
byte 1 100
byte 1 95
byte 1 99
byte 1 108
byte 1 97
byte 1 115
byte 1 115
byte 1 105
byte 1 99
byte 1 46
byte 1 99
byte 1 102
byte 1 103
byte 1 0
align 1
LABELV $2127
byte 1 99
byte 1 103
byte 1 95
byte 1 104
byte 1 117
byte 1 100
byte 1 70
byte 1 105
byte 1 108
byte 1 101
byte 1 115
byte 1 0
align 1
LABELV $2123
byte 1 72
byte 1 85
byte 1 68
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 32
byte 1 110
byte 1 111
byte 1 116
byte 1 32
byte 1 102
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 32
byte 1 60
byte 1 37
byte 1 115
byte 1 62
byte 1 10
byte 1 0
align 1
LABELV $2120
byte 1 60
byte 1 37
byte 1 115
byte 1 62
byte 1 32
byte 1 108
byte 1 111
byte 1 97
byte 1 100
byte 1 105
byte 1 110
byte 1 103
byte 1 46
byte 1 46
byte 1 46
byte 1 32
byte 1 10
byte 1 0
align 1
LABELV $2114
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 72
byte 1 85
byte 1 68
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 10
byte 1 0
align 1
LABELV $2079
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 115
byte 1 112
byte 1 101
byte 1 99
byte 1 105
byte 1 102
byte 1 105
byte 1 99
byte 1 95
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 115
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 10
byte 1 0
align 1
LABELV $2061
byte 1 71
byte 1 97
byte 1 109
byte 1 101
byte 1 84
byte 1 121
byte 1 112
byte 1 101
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 115
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 101
byte 1 114
byte 1 114
byte 1 111
byte 1 114
byte 1 10
byte 1 0
align 1
LABELV $2023
byte 1 80
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 99
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 101
byte 1 114
byte 1 114
byte 1 111
byte 1 114
byte 1 32
byte 1 60
byte 1 37
byte 1 115
byte 1 62
byte 1 10
byte 1 0
align 1
LABELV $2019
byte 1 99
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $2008
byte 1 101
byte 1 110
byte 1 100
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 32
byte 1 105
byte 1 110
byte 1 115
byte 1 105
byte 1 100
byte 1 101
byte 1 32
byte 1 104
byte 1 117
byte 1 100
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 0
align 1
LABELV $1988
byte 1 99
byte 1 111
byte 1 117
byte 1 108
byte 1 100
byte 1 110
byte 1 39
byte 1 116
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 115
byte 1 99
byte 1 114
byte 1 105
byte 1 112
byte 1 116
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1984
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 115
byte 1 99
byte 1 114
byte 1 105
byte 1 112
byte 1 116
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1972
byte 1 101
byte 1 110
byte 1 100
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 32
byte 1 105
byte 1 110
byte 1 115
byte 1 105
byte 1 100
byte 1 101
byte 1 32
byte 1 115
byte 1 99
byte 1 114
byte 1 105
byte 1 112
byte 1 116
byte 1 0
align 1
LABELV $1942
byte 1 99
byte 1 111
byte 1 117
byte 1 108
byte 1 100
byte 1 110
byte 1 39
byte 1 116
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 101
byte 1 114
byte 1 116
byte 1 121
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1938
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 101
byte 1 114
byte 1 116
byte 1 121
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1926
byte 1 101
byte 1 110
byte 1 100
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 32
byte 1 105
byte 1 110
byte 1 115
byte 1 105
byte 1 100
byte 1 101
byte 1 32
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 101
byte 1 114
byte 1 116
byte 1 121
byte 1 0
align 1
LABELV $1899
byte 1 116
byte 1 101
byte 1 97
byte 1 109
byte 1 95
byte 1 112
byte 1 108
byte 1 97
byte 1 121
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $1898
byte 1 99
byte 1 97
byte 1 112
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 0
align 1
LABELV $1897
byte 1 103
byte 1 114
byte 1 97
byte 1 100
byte 1 105
byte 1 101
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $1896
byte 1 112
byte 1 97
byte 1 114
byte 1 101
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $1895
byte 1 118
byte 1 97
byte 1 108
byte 1 105
byte 1 103
byte 1 110
byte 1 0
align 1
LABELV $1894
byte 1 109
byte 1 97
byte 1 114
byte 1 103
byte 1 105
byte 1 110
byte 1 0
align 1
LABELV $1893
byte 1 115
byte 1 104
byte 1 97
byte 1 100
byte 1 111
byte 1 119
byte 1 0
align 1
LABELV $1892
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 111
byte 1 114
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 97
byte 1 108
byte 1 0
align 1
LABELV $1891
byte 1 112
byte 1 117
byte 1 108
byte 1 115
byte 1 101
byte 1 83
byte 1 99
byte 1 97
byte 1 108
byte 1 101
byte 1 0
align 1
LABELV $1890
byte 1 118
byte 1 105
byte 1 115
byte 1 105
byte 1 98
byte 1 108
byte 1 101
byte 1 0
align 1
LABELV $1889
byte 1 116
byte 1 105
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $1888
byte 1 98
byte 1 108
byte 1 105
byte 1 110
byte 1 107
byte 1 0
align 1
LABELV $1887
byte 1 102
byte 1 105
byte 1 108
byte 1 108
byte 1 0
align 1
LABELV $1886
byte 1 97
byte 1 110
byte 1 99
byte 1 104
byte 1 111
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1885
byte 1 98
byte 1 97
byte 1 99
byte 1 107
byte 1 99
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $1884
byte 1 102
byte 1 111
byte 1 114
byte 1 101
byte 1 99
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $1883
byte 1 112
byte 1 97
byte 1 114
byte 1 97
byte 1 109
byte 1 0
align 1
LABELV $1882
byte 1 102
byte 1 111
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $1881
byte 1 102
byte 1 111
byte 1 110
byte 1 116
byte 1 115
byte 1 105
byte 1 122
byte 1 101
byte 1 0
align 1
LABELV $1880
byte 1 116
byte 1 101
byte 1 120
byte 1 116
byte 1 97
byte 1 108
byte 1 105
byte 1 103
byte 1 110
byte 1 0
align 1
LABELV $1879
byte 1 118
byte 1 101
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 97
byte 1 108
byte 1 98
byte 1 97
byte 1 114
byte 1 0
align 1
LABELV $1878
byte 1 99
byte 1 118
byte 1 97
byte 1 114
byte 1 84
byte 1 101
byte 1 115
byte 1 116
byte 1 0
align 1
LABELV $1877
byte 1 105
byte 1 99
byte 1 111
byte 1 110
byte 1 51
byte 1 68
byte 1 0
align 1
LABELV $1876
byte 1 98
byte 1 97
byte 1 99
byte 1 107
byte 1 103
byte 1 114
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 0
align 1
LABELV $1875
byte 1 114
byte 1 101
byte 1 99
byte 1 116
byte 1 0
align 1
LABELV $1874
byte 1 110
byte 1 97
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $1852
byte 1 84
byte 1 101
byte 1 97
byte 1 109
byte 1 79
byte 1 118
byte 1 101
byte 1 114
byte 1 108
byte 1 97
byte 1 121
byte 1 95
byte 1 83
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 0
align 1
LABELV $1851
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 95
byte 1 80
byte 1 111
byte 1 119
byte 1 101
byte 1 114
byte 1 85
byte 1 112
byte 1 0
align 1
LABELV $1850
byte 1 83
byte 1 101
byte 1 114
byte 1 118
byte 1 101
byte 1 114
byte 1 77
byte 1 101
byte 1 115
byte 1 115
byte 1 97
byte 1 103
byte 1 101
byte 1 0
align 1
LABELV $1849
byte 1 87
byte 1 97
byte 1 114
byte 1 109
byte 1 117
byte 1 112
byte 1 70
byte 1 105
byte 1 103
byte 1 104
byte 1 116
byte 1 77
byte 1 101
byte 1 115
byte 1 115
byte 1 97
byte 1 103
byte 1 101
byte 1 0
align 1
LABELV $1848
byte 1 73
byte 1 116
byte 1 101
byte 1 109
byte 1 77
byte 1 101
byte 1 115
byte 1 115
byte 1 97
byte 1 103
byte 1 101
byte 1 0
align 1
LABELV $1847
byte 1 75
byte 1 105
byte 1 108
byte 1 108
byte 1 77
byte 1 101
byte 1 115
byte 1 115
byte 1 97
byte 1 103
byte 1 101
byte 1 0
align 1
LABELV $1846
byte 1 87
byte 1 101
byte 1 97
byte 1 112
byte 1 111
byte 1 110
byte 1 76
byte 1 105
byte 1 115
byte 1 116
byte 1 95
byte 1 83
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 78
byte 1 97
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $1845
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 95
byte 1 87
byte 1 101
byte 1 97
byte 1 112
byte 1 111
byte 1 110
byte 1 76
byte 1 105
byte 1 115
byte 1 116
byte 1 95
byte 1 83
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 0
align 1
LABELV $1844
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 95
byte 1 87
byte 1 101
byte 1 97
byte 1 112
byte 1 111
byte 1 110
byte 1 76
byte 1 105
byte 1 115
byte 1 116
byte 1 0
align 1
LABELV $1830
byte 1 71
byte 1 97
byte 1 109
byte 1 101
byte 1 84
byte 1 121
byte 1 112
byte 1 101
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 115
byte 1 0
align 1
LABELV $1829
byte 1 83
byte 1 101
byte 1 116
byte 1 67
byte 1 118
byte 1 97
byte 1 114
byte 1 0
align 1
LABELV $1828
byte 1 73
byte 1 78
byte 1 70
byte 1 79
byte 1 0
align 1
LABELV $1814
byte 1 69
byte 1 114
byte 1 114
byte 1 111
byte 1 114
byte 1 32
byte 1 72
byte 1 85
byte 1 68
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 44
byte 1 32
byte 1 99
byte 1 97
byte 1 110
byte 1 39
byte 1 116
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 101
byte 1 114
byte 1 116
byte 1 121
byte 1 32
byte 1 39
byte 1 99
byte 1 97
byte 1 112
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 39
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1808
byte 1 69
byte 1 114
byte 1 114
byte 1 111
byte 1 114
byte 1 32
byte 1 72
byte 1 85
byte 1 68
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 44
byte 1 32
byte 1 99
byte 1 97
byte 1 110
byte 1 39
byte 1 116
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 101
byte 1 114
byte 1 116
byte 1 121
byte 1 32
byte 1 39
byte 1 103
byte 1 114
byte 1 97
byte 1 100
byte 1 105
byte 1 101
byte 1 110
byte 1 116
byte 1 39
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1797
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 99
byte 1 118
byte 1 97
byte 1 114
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1782
byte 1 72
byte 1 85
byte 1 68
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 101
byte 1 110
byte 1 116
byte 1 32
byte 1 110
byte 1 111
byte 1 116
byte 1 32
byte 1 102
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 10
byte 1 0
align 1
LABELV $1776
byte 1 112
byte 1 97
byte 1 114
byte 1 101
byte 1 110
byte 1 116
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 32
byte 1 110
byte 1 111
byte 1 116
byte 1 32
byte 1 102
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 46
byte 1 32
byte 1 80
byte 1 97
byte 1 114
byte 1 101
byte 1 110
byte 1 116
byte 1 32
byte 1 109
byte 1 117
byte 1 115
byte 1 116
byte 1 32
byte 1 98
byte 1 101
byte 1 32
byte 1 112
byte 1 108
byte 1 97
byte 1 99
byte 1 101
byte 1 100
byte 1 32
byte 1 98
byte 1 101
byte 1 102
byte 1 111
byte 1 114
byte 1 101
byte 1 32
byte 1 116
byte 1 104
byte 1 101
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 46
byte 1 10
byte 1 0
align 1
LABELV $1718
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 80
byte 1 76
byte 1 65
byte 1 89
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1717
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 83
byte 1 72
byte 1 79
byte 1 87
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 73
byte 1 78
byte 1 70
byte 1 79
byte 1 0
align 1
LABELV $1716
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 83
byte 1 80
byte 1 69
byte 1 67
byte 1 84
byte 1 65
byte 1 84
byte 1 79
byte 1 82
byte 1 0
align 1
LABELV $1715
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 66
byte 1 76
byte 1 85
byte 1 69
byte 1 95
byte 1 79
byte 1 82
byte 1 95
byte 1 82
byte 1 69
byte 1 68
byte 1 0
align 1
LABELV $1714
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 83
byte 1 80
byte 1 69
byte 1 67
byte 1 0
align 1
LABELV $1713
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 82
byte 1 69
byte 1 68
byte 1 0
align 1
LABELV $1712
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 66
byte 1 76
byte 1 85
byte 1 69
byte 1 0
align 1
LABELV $1711
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 71
byte 1 84
byte 1 95
byte 1 70
byte 1 82
byte 1 69
byte 1 69
byte 1 90
byte 1 69
byte 1 0
align 1
LABELV $1710
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 71
byte 1 84
byte 1 95
byte 1 67
byte 1 84
byte 1 70
byte 1 0
align 1
LABELV $1709
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 71
byte 1 84
byte 1 95
byte 1 84
byte 1 68
byte 1 77
byte 1 0
align 1
LABELV $1708
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 71
byte 1 84
byte 1 95
byte 1 70
byte 1 70
byte 1 65
byte 1 0
align 1
LABELV $1707
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 71
byte 1 84
byte 1 95
byte 1 84
byte 1 79
byte 1 85
byte 1 82
byte 1 78
byte 1 65
byte 1 77
byte 1 69
byte 1 78
byte 1 84
byte 1 0
align 1
LABELV $1706
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 80
byte 1 76
byte 1 65
byte 1 89
byte 1 0
align 1
LABELV $1692
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 80
byte 1 76
byte 1 65
byte 1 89
byte 1 69
byte 1 82
byte 1 83
byte 1 95
byte 1 78
byte 1 66
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 0
align 1
LABELV $1691
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 78
byte 1 65
byte 1 77
byte 1 69
byte 1 0
align 1
LABELV $1690
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 76
byte 1 79
byte 1 67
byte 1 65
byte 1 84
byte 1 73
byte 1 79
byte 1 78
byte 1 0
align 1
LABELV $1689
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 84
byte 1 73
byte 1 77
byte 1 69
byte 1 95
byte 1 76
byte 1 73
byte 1 77
byte 1 73
byte 1 84
byte 1 0
align 1
LABELV $1688
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 67
byte 1 65
byte 1 80
byte 1 84
byte 1 85
byte 1 82
byte 1 69
byte 1 95
byte 1 76
byte 1 73
byte 1 77
byte 1 73
byte 1 84
byte 1 0
align 1
LABELV $1687
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 70
byte 1 82
byte 1 65
byte 1 71
byte 1 95
byte 1 76
byte 1 73
byte 1 77
byte 1 73
byte 1 84
byte 1 0
align 1
LABELV $1686
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 67
byte 1 65
byte 1 80
byte 1 70
byte 1 82
byte 1 65
byte 1 71
byte 1 95
byte 1 76
byte 1 73
byte 1 77
byte 1 73
byte 1 84
byte 1 0
align 1
LABELV $1685
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 83
byte 1 78
byte 1 65
byte 1 80
byte 1 83
byte 1 72
byte 1 79
byte 1 84
byte 1 0
align 1
LABELV $1684
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 70
byte 1 79
byte 1 76
byte 1 76
byte 1 79
byte 1 87
byte 1 95
byte 1 78
byte 1 65
byte 1 77
byte 1 69
byte 1 0
align 1
LABELV $1683
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 83
byte 1 80
byte 1 69
byte 1 69
byte 1 68
byte 1 0
align 1
LABELV $1682
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 70
byte 1 80
byte 1 83
byte 1 0
align 1
LABELV $1681
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 72
byte 1 79
byte 1 76
byte 1 68
byte 1 65
byte 1 66
byte 1 76
byte 1 69
byte 1 95
byte 1 73
byte 1 84
byte 1 69
byte 1 77
byte 1 0
align 1
LABELV $1680
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 84
byte 1 73
byte 1 77
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1679
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 83
byte 1 67
byte 1 79
byte 1 82
byte 1 69
byte 1 0
align 1
LABELV $1678
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 87
byte 1 69
byte 1 65
byte 1 80
byte 1 79
byte 1 78
byte 1 0
align 1
LABELV $1677
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 65
byte 1 77
byte 1 77
byte 1 79
byte 1 0
align 1
LABELV $1676
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 65
byte 1 82
byte 1 77
byte 1 79
byte 1 82
byte 1 0
align 1
LABELV $1675
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 72
byte 1 69
byte 1 65
byte 1 76
byte 1 84
byte 1 72
byte 1 0
align 1
LABELV $1653
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 70
byte 1 73
byte 1 82
byte 1 73
byte 1 78
byte 1 71
byte 1 0
align 1
LABELV $1652
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 80
byte 1 73
byte 1 67
byte 1 75
byte 1 85
byte 1 80
byte 1 95
byte 1 73
byte 1 84
byte 1 69
byte 1 77
byte 1 0
align 1
LABELV $1651
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 80
byte 1 79
byte 1 87
byte 1 69
byte 1 82
byte 1 85
byte 1 80
byte 1 95
byte 1 49
byte 1 0
align 1
LABELV $1650
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 82
byte 1 69
byte 1 68
byte 1 95
byte 1 70
byte 1 76
byte 1 65
byte 1 71
byte 1 95
byte 1 84
byte 1 65
byte 1 75
byte 1 69
byte 1 78
byte 1 0
align 1
LABELV $1649
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 66
byte 1 76
byte 1 85
byte 1 69
byte 1 95
byte 1 70
byte 1 76
byte 1 65
byte 1 71
byte 1 95
byte 1 84
byte 1 65
byte 1 75
byte 1 69
byte 1 78
byte 1 0
align 1
LABELV $1648
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 66
byte 1 76
byte 1 73
byte 1 78
byte 1 75
byte 1 0
align 1
LABELV $1647
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 68
byte 1 73
byte 1 83
byte 1 67
byte 1 79
byte 1 78
byte 1 78
byte 1 69
byte 1 67
byte 1 84
byte 1 69
byte 1 68
byte 1 0
align 1
LABELV $1646
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 90
byte 1 69
byte 1 82
byte 1 79
byte 1 95
byte 1 86
byte 1 65
byte 1 76
byte 1 85
byte 1 69
byte 1 0
align 1
LABELV $1645
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 87
byte 1 65
byte 1 82
byte 1 77
byte 1 85
byte 1 80
byte 1 0
align 1
LABELV $1644
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 79
byte 1 85
byte 1 84
byte 1 95
byte 1 79
byte 1 70
byte 1 95
byte 1 65
byte 1 77
byte 1 77
byte 1 79
byte 1 0
align 1
LABELV $1643
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 76
byte 1 79
byte 1 87
byte 1 95
byte 1 65
byte 1 77
byte 1 77
byte 1 79
byte 1 95
byte 1 87
byte 1 65
byte 1 82
byte 1 78
byte 1 73
byte 1 78
byte 1 71
byte 1 0
align 1
LABELV $1642
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 80
byte 1 77
byte 1 70
byte 1 95
byte 1 70
byte 1 79
byte 1 76
byte 1 76
byte 1 79
byte 1 87
byte 1 0
align 1
LABELV $1641
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 76
byte 1 79
byte 1 67
byte 1 65
byte 1 76
byte 1 95
byte 1 83
byte 1 69
byte 1 82
byte 1 86
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1640
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 73
byte 1 78
byte 1 95
byte 1 77
byte 1 69
byte 1 78
byte 1 85
byte 1 0
align 1
LABELV $1639
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 78
byte 1 69
byte 1 86
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1638
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 73
byte 1 78
byte 1 95
byte 1 83
byte 1 67
byte 1 79
byte 1 82
byte 1 69
byte 1 0
align 1
LABELV $1561
byte 1 110
byte 1 117
byte 1 109
byte 1 98
byte 1 101
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1541
byte 1 109
byte 1 101
byte 1 110
byte 1 117
byte 1 115
byte 1 99
byte 1 114
byte 1 101
byte 1 101
byte 1 110
byte 1 50
byte 1 0
align 1
LABELV $1538
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 65
byte 1 84
byte 1 84
byte 1 65
byte 1 67
byte 1 75
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1535
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 80
byte 1 79
byte 1 87
byte 1 69
byte 1 82
byte 1 85
byte 1 80
byte 1 0
align 1
LABELV $1532
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 79
byte 1 82
byte 1 68
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1529
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 65
byte 1 77
byte 1 77
byte 1 79
byte 1 0
align 1
LABELV $1526
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 65
byte 1 82
byte 1 77
byte 1 79
byte 1 82
byte 1 0
align 1
LABELV $1523
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 72
byte 1 69
byte 1 65
byte 1 68
byte 1 95
byte 1 65
byte 1 78
byte 1 73
byte 1 77
byte 1 0
align 1
LABELV $1520
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 72
byte 1 69
byte 1 65
byte 1 68
byte 1 0
align 1
LABELV $1517
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 82
byte 1 69
byte 1 68
byte 1 95
byte 1 70
byte 1 76
byte 1 65
byte 1 71
byte 1 0
align 1
LABELV $1514
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 66
byte 1 76
byte 1 85
byte 1 69
byte 1 95
byte 1 70
byte 1 76
byte 1 65
byte 1 71
byte 1 0
align 1
LABELV $1511
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 72
byte 1 79
byte 1 76
byte 1 68
byte 1 65
byte 1 66
byte 1 76
byte 1 69
byte 1 95
byte 1 73
byte 1 84
byte 1 69
byte 1 77
byte 1 0
align 1
LABELV $1508
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 71
byte 1 65
byte 1 77
byte 1 69
byte 1 95
byte 1 84
byte 1 89
byte 1 80
byte 1 69
byte 1 0
align 1
LABELV $1468
byte 1 116
byte 1 114
byte 1 117
byte 1 101
byte 1 0
align 1
LABELV $1464
byte 1 102
byte 1 97
byte 1 108
byte 1 115
byte 1 101
byte 1 0
align 1
LABELV $1425
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 101
byte 1 114
byte 1 114
byte 1 111
byte 1 114
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $1367
byte 1 82
byte 1 101
byte 1 100
byte 1 84
byte 1 101
byte 1 97
byte 1 109
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $1366
byte 1 66
byte 1 108
byte 1 117
byte 1 101
byte 1 84
byte 1 101
byte 1 97
byte 1 109
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $1365
byte 1 84
byte 1 101
byte 1 97
byte 1 109
byte 1 115
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1364
byte 1 65
byte 1 109
byte 1 109
byte 1 111
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1363
byte 1 65
byte 1 114
byte 1 109
byte 1 111
byte 1 114
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1362
byte 1 72
byte 1 101
byte 1 97
byte 1 108
byte 1 116
byte 1 104
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1344
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 67
byte 1 114
byte 1 111
byte 1 115
byte 1 115
byte 1 104
byte 1 97
byte 1 105
byte 1 114
byte 1 0
align 1
LABELV $1343
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 65
byte 1 109
byte 1 109
byte 1 111
byte 1 87
byte 1 97
byte 1 114
byte 1 110
byte 1 105
byte 1 110
byte 1 103
byte 1 0
align 1
LABELV $1342
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 82
byte 1 101
byte 1 119
byte 1 97
byte 1 114
byte 1 100
byte 1 115
byte 1 0
align 1
LABELV $1341
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 83
byte 1 116
byte 1 97
byte 1 116
byte 1 117
byte 1 115
byte 1 0
align 1
LABELV $1340
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 83
byte 1 110
byte 1 97
byte 1 112
byte 1 115
byte 1 104
byte 1 111
byte 1 116
byte 1 0
align 1
LABELV $1339
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 80
byte 1 105
byte 1 110
byte 1 103
byte 1 0
align 1
LABELV $1338
byte 1 99
byte 1 103
byte 1 95
byte 1 108
byte 1 97
byte 1 103
byte 1 111
byte 1 109
byte 1 101
byte 1 116
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $1337
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 84
byte 1 105
byte 1 109
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $1336
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 83
byte 1 112
byte 1 101
byte 1 101
byte 1 100
byte 1 0
align 1
LABELV $1335
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 70
byte 1 80
byte 1 83
byte 1 0
align 1
LABELV $1334
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 51
byte 1 100
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 115
byte 1 0
align 1
LABELV $1333
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 115
byte 1 0
align 1
LABELV $1332
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 67
byte 1 114
byte 1 111
byte 1 115
byte 1 115
byte 1 104
byte 1 97
byte 1 105
byte 1 114
byte 1 78
byte 1 97
byte 1 109
byte 1 101
byte 1 115
byte 1 0
align 1
LABELV $1331
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 84
byte 1 101
byte 1 97
byte 1 109
byte 1 79
byte 1 118
byte 1 101
byte 1 114
byte 1 108
byte 1 97
byte 1 121
byte 1 0
align 1
LABELV $1330
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 65
byte 1 116
byte 1 116
byte 1 97
byte 1 99
byte 1 107
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $1329
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 87
byte 1 101
byte 1 97
byte 1 112
byte 1 111
byte 1 110
byte 1 83
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 0
align 1
LABELV $1309
byte 1 101
byte 1 120
byte 1 112
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 32
byte 1 105
byte 1 110
byte 1 116
byte 1 101
byte 1 103
byte 1 101
byte 1 114
byte 1 32
byte 1 98
byte 1 117
byte 1 116
byte 1 32
byte 1 102
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 10
byte 1 0
align 1
LABELV $1284
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 44
byte 1 32
byte 1 108
byte 1 105
byte 1 110
byte 1 101
byte 1 32
byte 1 37
byte 1 100
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $1275
byte 1 72
byte 1 85
byte 1 68
byte 1 95
byte 1 65
byte 1 108
byte 1 108
byte 1 111
byte 1 99
byte 1 58
byte 1 32
byte 1 70
byte 1 97
byte 1 105
byte 1 108
byte 1 117
byte 1 114
byte 1 101
byte 1 46
byte 1 32
byte 1 79
byte 1 117
byte 1 116
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 109
byte 1 101
byte 1 109
byte 1 111
byte 1 114
byte 1 121
byte 1 33
byte 1 0
align 1
LABELV $1169
byte 1 37
byte 1 50
byte 1 105
byte 1 0
align 1
LABELV $1155
byte 1 116
byte 1 105
byte 1 109
byte 1 101
byte 1 58
byte 1 37
byte 1 105
byte 1 32
byte 1 115
byte 1 110
byte 1 97
byte 1 112
byte 1 58
byte 1 37
byte 1 105
byte 1 32
byte 1 99
byte 1 109
byte 1 100
byte 1 58
byte 1 37
byte 1 105
byte 1 0
align 1
LABELV $1147
byte 1 37
byte 1 105
byte 1 102
byte 1 112
byte 1 115
byte 1 0
align 1
LABELV $1144
byte 1 37
byte 1 105
byte 1 58
byte 1 37
byte 1 48
byte 1 50
byte 1 105
byte 1 0
align 1
LABELV $1143
byte 1 37
byte 1 105
byte 1 58
byte 1 37
byte 1 105
byte 1 58
byte 1 37
byte 1 48
byte 1 50
byte 1 105
byte 1 0
align 1
LABELV $1128
byte 1 37
byte 1 105
byte 1 0
align 1
LABELV $1125
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1122
byte 1 37
byte 1 49
byte 1 46
byte 1 48
byte 1 105
byte 1 117
byte 1 112
byte 1 115
byte 1 0
align 1
LABELV $1121
byte 1 37
byte 1 49
byte 1 46
byte 1 48
byte 1 105
byte 1 0
align 1
LABELV $970
byte 1 69
byte 1 118
byte 1 101
byte 1 114
byte 1 121
byte 1 111
byte 1 110
byte 1 101
byte 1 0
align 1
LABELV $967
byte 1 37
byte 1 100
byte 1 0
align 1
LABELV $966
byte 1 99
byte 1 103
byte 1 95
byte 1 115
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 80
byte 1 108
byte 1 97
byte 1 121
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $965
byte 1 99
byte 1 103
byte 1 95
byte 1 115
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 80
byte 1 108
byte 1 97
byte 1 121
byte 1 101
byte 1 114
byte 1 78
byte 1 97
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $927
byte 1 99
byte 1 109
byte 1 100
byte 1 32
byte 1 118
byte 1 116
byte 1 101
byte 1 108
byte 1 108
byte 1 32
byte 1 37
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $923
byte 1 116
byte 1 101
byte 1 97
byte 1 109
byte 1 116
byte 1 97
byte 1 115
byte 1 107
byte 1 32
byte 1 37
byte 1 105
byte 1 10
byte 1 0
align 1
LABELV $918
byte 1 99
byte 1 109
byte 1 100
byte 1 32
byte 1 118
byte 1 115
byte 1 97
byte 1 121
byte 1 95
byte 1 116
byte 1 101
byte 1 97
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $912
byte 1 102
byte 1 111
byte 1 108
byte 1 108
byte 1 111
byte 1 119
byte 1 102
byte 1 108
byte 1 97
byte 1 103
byte 1 99
byte 1 97
byte 1 114
byte 1 114
byte 1 105
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $911
byte 1 111
byte 1 110
byte 1 102
byte 1 111
byte 1 108
byte 1 108
byte 1 111
byte 1 119
byte 1 99
byte 1 97
byte 1 114
byte 1 114
byte 1 105
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $909
byte 1 114
byte 1 101
byte 1 116
byte 1 117
byte 1 114
byte 1 110
byte 1 102
byte 1 108
byte 1 97
byte 1 103
byte 1 0
align 1
LABELV $908
byte 1 111
byte 1 110
byte 1 103
byte 1 101
byte 1 116
byte 1 102
byte 1 108
byte 1 97
byte 1 103
byte 1 0
align 1
LABELV $906
byte 1 99
byte 1 97
byte 1 109
byte 1 112
byte 1 0
align 1
LABELV $905
byte 1 111
byte 1 110
byte 1 99
byte 1 97
byte 1 109
byte 1 112
byte 1 0
align 1
LABELV $903
byte 1 43
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 49
byte 1 48
byte 1 59
byte 1 32
byte 1 119
byte 1 97
byte 1 105
byte 1 116
byte 1 59
byte 1 32
byte 1 45
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 49
byte 1 48
byte 1 0
align 1
LABELV $902
byte 1 102
byte 1 111
byte 1 108
byte 1 108
byte 1 111
byte 1 119
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $901
byte 1 111
byte 1 110
byte 1 102
byte 1 111
byte 1 108
byte 1 108
byte 1 111
byte 1 119
byte 1 0
align 1
LABELV $899
byte 1 43
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 57
byte 1 59
byte 1 32
byte 1 119
byte 1 97
byte 1 105
byte 1 116
byte 1 59
byte 1 32
byte 1 45
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 57
byte 1 0
align 1
LABELV $898
byte 1 112
byte 1 97
byte 1 116
byte 1 114
byte 1 111
byte 1 108
byte 1 0
align 1
LABELV $897
byte 1 111
byte 1 110
byte 1 112
byte 1 97
byte 1 116
byte 1 114
byte 1 111
byte 1 108
byte 1 0
align 1
LABELV $895
byte 1 43
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 56
byte 1 59
byte 1 32
byte 1 119
byte 1 97
byte 1 105
byte 1 116
byte 1 59
byte 1 32
byte 1 45
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 56
byte 1 0
align 1
LABELV $894
byte 1 100
byte 1 101
byte 1 102
byte 1 101
byte 1 110
byte 1 100
byte 1 0
align 1
LABELV $893
byte 1 111
byte 1 110
byte 1 100
byte 1 101
byte 1 102
byte 1 101
byte 1 110
byte 1 115
byte 1 101
byte 1 0
align 1
LABELV $891
byte 1 43
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 55
byte 1 59
byte 1 32
byte 1 119
byte 1 97
byte 1 105
byte 1 116
byte 1 59
byte 1 32
byte 1 45
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 55
byte 1 0
align 1
LABELV $890
byte 1 111
byte 1 102
byte 1 102
byte 1 101
byte 1 110
byte 1 115
byte 1 101
byte 1 0
align 1
LABELV $889
byte 1 111
byte 1 110
byte 1 111
byte 1 102
byte 1 102
byte 1 101
byte 1 110
byte 1 115
byte 1 101
byte 1 0
align 1
LABELV $126
byte 1 99
byte 1 111
byte 1 109
byte 1 95
byte 1 109
byte 1 97
byte 1 120
byte 1 102
byte 1 112
byte 1 115
byte 1 0
align 1
LABELV $87
byte 1 0
